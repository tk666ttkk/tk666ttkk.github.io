<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>driverlicense</title>
    <url>/2023/09/07/drivelicense/</url>
    <content><![CDATA[<h1 id="简简单单的练车日记"><a href="#简简单单的练车日记" class="headerlink" title="简简单单的练车日记"></a>简简单单的练车日记</h1><h2 id="科目一"><a href="#科目一" class="headerlink" title="科目一"></a>科目一</h2><p>哦对对对，科目一花了三天刷题，一天时间来模拟。91分飘过。</p>
<h2 id="科目二"><a href="#科目二" class="headerlink" title="科目二"></a>科目二</h2><p>8.31号开始练车，第一天熟悉地形和开车的手感，然后练了两天的侧方位，练了一天的直角转弯和曲线行驶，(<em>这里的一天指单指的45分钟或一小时</em>) ,约了18号的科二，2个星期搞定。一个星期也就练车3天，一天45分钟，但是一人一车是真的爽，教练就指导你一个，但是这教练仅仅只教了一遍点位，（此处省略C语言），抽烟，脾气不是一般的暴躁，不得不说这很符合教练的刻板印象。收了我100空调费。还是说全国的驾校教练都是统一的吗?但是总归来说，正常的教练还是希望你考证过的，不然一堆人堆积在那，驾校领导以为这个教练水平有问题，带个学员没几个考证的，可能考证之后还会有绩效什么之类的，总的来说还是希望你考过的，但是这过程注定不是轻松的。</p>
<p>倒库教了一遍就会了，9.8号所有科目都会了，再模拟几遍即可。</p>
<h3 id="技巧篇"><a href="#技巧篇" class="headerlink" title="技巧篇"></a>技巧篇</h3><p>1.车速一定是慢的，快了不好调整回来。</p>
<p>2.打方向盘一定要快，车速慢，方向盘必须快。</p>
<p>3.记点位即可，科二都是点位的。</p>
<p>4.科三还没练，不知道技巧。</p>
<h3 id="侧方位停车"><a href="#侧方位停车" class="headerlink" title="侧方位停车"></a>侧方位停车</h3><p>1.挂倒档 看右边 直角消失右边打满<br>2.看左边 看到第一个角 左边半圈 第二个角 左边回一圈 后车轮压压线 左边打满<br>3.倒到车身平行 然后左转向灯 挂D1档<br>4.车左角压线 右回半圈 雨刮器压线右边两圈<br>车身平行往左边回一圈回正</p>
<p>车子不要踩死 要压着</p>
<h3 id="直角转弯"><a href="#直角转弯" class="headerlink" title="直角转弯"></a>直角转弯</h3><p>1.雨刷器的右边沿着边线的左边<br>2.打左转向灯 门把手垂直那根线 左边打满<br>3.等车头对准s弯道中间 往右边回正<br>4.车头最左角碰右边的线 左边一圈<br>5.出去带80度 左角带进来了30厘米80度就回掉<br>6.左角刚好要碰左边的线 右边一圈<br>7.雨刹器刚好碰过线 右边一圈<br>右边出去了大于一个拳头 就带右边50度<br>人对准中间那棵树 回正方向盘</p>
<h3 id="左边倒车入库"><a href="#左边倒车入库" class="headerlink" title="左边倒车入库"></a>左边倒车入库</h3><p>1.左边后视镜离线刚要碰上线立马往左边方向盘打死<br>2.左边后视镜 车屁股遮住第一二条虚线 在第三条虚线中间时回 半圈 觉得宽了就往左边加<br>3.看右边后视镜 直角出来一个拳头了边倒右边回一圈<br>4.倒车到那根线与自己身子一样<br>5.出库  左边一圈加九十度 左边后视镜快碰到第一根虚线 回九十度 车身一平行 回正</p>
<h3 id="右边出库"><a href="#右边出库" class="headerlink" title="右边出库"></a>右边出库</h3><p>1.车出去 车侧边三分之一到线 右边一圈加九十度<br>2.一直不动到肩膀超过左边的那根线 肩膀平行过一点 停下倒车<br>3.倒车到直角的时候 右边打满 车屁股到最后一根虚线一半的地方 左边回半圈<br>4.看左边后视镜 直到平行多出一个拳头 左边回一圈<br>5.倒车到那根线与自己身子一样 到进库的地方停车</p>
<p>看左边是一个拳头回正<br>看右边是大半个拳头回正</p>
<h2 id="科目三"><a href="#科目三" class="headerlink" title="科目三"></a>科目三</h2><h2 id="科目四"><a href="#科目四" class="headerlink" title="科目四"></a>科目四</h2>]]></content>
      <categories>
        <category>日常生活</category>
      </categories>
  </entry>
  <entry>
    <title>linux</title>
    <url>/2023/09/08/linux/</url>
    <content><![CDATA[<h1 id="一-：开始："><a href="#一-：开始：" class="headerlink" title="一 ：开始："></a>一 ：开始：</h1><p>操作ctrl+alt+f2:进入shell界面 ctrl+alt+f1:进入图像界面ls &#x2F;usr&#x2F;sbin&#x2F; | grep service 查找子文件是否存在</p>
<h1 id="二：基本操作："><a href="#二：基本操作：" class="headerlink" title="二：基本操作："></a>二：基本操作：</h1><p>基本文件编辑cd:进入文件 vim：</p>
<p>文本编辑器（一 “:”进入命令模式 u 回撤 w 保存 q 退出 wq保存并退出!q强制退出 set nu 显示行号                i&#x2F;a当前光标头尾插入，I&#x2F;A行头尾插入 o&#x2F;O下上一行插入                     </p>
<p>普通模式 数字&amp;yy 复制 数字&amp;p 粘贴 数字&amp;dd 删除          </p>
<p>剪切一个字符 X 剪切光标的前一个字符            </p>
<p>y&#x2F;d&amp;w 复制删除一个单词 y&#x2F;d&amp;$复制删除光标之前      y&#x2F;d&amp;^复制删除光标之后            </p>
<p>r 替换字符 R 进入替换模式            </p>
<p>^行头 $行尾 w下一个词头 b上一个词头 e当前词尾 gg页头 G页尾 数字N&amp;G移动到目标行      </p>
<p>&#x2F;查找 n查找下一个 N查找上一个         </p>
<p>s&#x2F;old&#x2F;new替换首个 s&#x2F;old&#x2F;new&#x2F;g替换整行 %s&#x2F;old&#x2F;new替换所有行的首个                         %s&#x2F;old&#x2F;new&#x2F;g替换全篇)</p>
<h1 id="三：网络编辑"><a href="#三：网络编辑" class="headerlink" title="三：网络编辑"></a>三：网络编辑</h1><h2 id="windows网络高级设置："><a href="#windows网络高级设置：" class="headerlink" title="windows网络高级设置："></a>windows网络高级设置：</h2><p>可查看vmware虚拟网卡的ip（NAT）ping ip地址 进行网络连接cmd下：ipconfig查看所有连接网络的IP地址linux下: ifconfig查看所有连接网络的IP地址</p>
<h2 id="修改静态ip："><a href="#修改静态ip：" class="headerlink" title="修改静态ip："></a>修改静态ip：</h2><p>vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33添加#IP地址 IPADDR&#x3D;192.168.xxx.100(从100开始对应相应的主机名称)    #网关 GATEWAY&#x3D;192.168.xxx.2   #域名解释器 DNS1&#x3D;192.168.xxx.2重启网络配置：service network restart</p>
<h2 id="修改主机名："><a href="#修改主机名：" class="headerlink" title="修改主机名："></a>修改主机名：</h2><p>hostname set-hostname xx创建主机名和ip地址的映射关系: vim &#x2F;etc&#x2F;hosts192.168.32.100 hadoop100…</p>
<h1 id="四：远程登录cmd"><a href="#四：远程登录cmd" class="headerlink" title="四：远程登录cmd"></a>四：远程登录cmd</h1><p>：ssh root@hadoop100 yes 输入密码进入 linux 退出exit用XSell操作和Xftp传文件</p>
<h1 id="五：系统管理进程："><a href="#五：系统管理进程：" class="headerlink" title="五：系统管理进程："></a>五：系统管理进程：</h1><p>正在执行的程序或命令服务(.d结尾)：需要一直存在的进程，由守护进程来执行，形成服务。类似mysql80的自动启动（常驻后台）systemctl start&#x2F;stop&#x2F;restart&#x2F;status 服务名</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>lqb</title>
    <url>/2023/09/08/lq/</url>
    <content><![CDATA[<h1 id="近几年的题目分类："><a href="#近几年的题目分类：" class="headerlink" title="近几年的题目分类："></a>近几年的题目分类：</h1><h2 id="2022填空："><a href="#2022填空：" class="headerlink" title="2022填空："></a>2022填空：</h2><p>1.大数（BigInteger）2.回文字串（String.compareTo（new StringBuider().reverse().toString()）&#x3D;&#x3D;0 ）只有String之间才能进行比较3.次数最多的字母(HashMap List Collections)Collections.sort(list);桶排序   4.数组排序数组（非常好用）：Arrays.sort();<br>6.最大子矩阵暴力循环（四重循环）左上角开始循环矩阵，寻找子矩阵中的最大值最小值，计算limit，每次记录矩阵的最大面积，最后遍历结束即可输出最大的子矩阵；<br>7.</p>
<h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><p>1.ASCII码2.卡片拼数字  数位拆分：Arrays.fill(a,2021);3.直线:Set 不含重复元素的集合(纯纯考数学，不写了)4.货物摆放：ArrayList保存因子，暴力</p>
<h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p>1.ASCII码(译码 -&gt; 编码)2.纪念日( 日期)3.核酸4.分配口罩（位运算）1&lt;&lt;5 &#x3D; 将二进制下的1左移5位 即 2^6i &amp; (1&lt;&lt;j) :i &amp; (2^6) 表示i和2^6的按位与，即检测i的j位是否为1 ,为1给第一家，为0给第二家 i&#x3D;5 101 : for(j:0循环) i &amp; (1&lt;&lt;j) i &amp;(1) 101                                     1 数位相同，结果为1，分配给第一家医院 )    </p>
<h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><p>1.组队（签到题）2.不同的字串（HashSet）3.数列求值（开long，取余）4.数的分解（排列组合）</p>
<h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><p>（只会写第一题，好难！！！s）1.签到题2.求圆内的小方格(模拟坐标，判断直线)数学题3.复数（纯纯数学。。。。。）4.测试次数（二分 + 动态规划 ）</p>
<h1 id="按照题型分类的考点"><a href="#按照题型分类的考点" class="headerlink" title="按照题型分类的考点:"></a>按照题型分类的考点:</h1><p>题目的数据范围决定了变量的数据类型</p>
<h2 id="快读"><a href="#快读" class="headerlink" title="快读:"></a>快读:</h2><p> BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(System.in));读数据：long n &#x3D; Long.parseLong(in.readLine());字符串 : String str &#x3D; in.readLine(); 数组 :String nums[] &#x3D; in.readLine().split(“ “)；   int[] arr &#x3D; new int[nums.length];   for (int i &#x3D; 0; i &lt; nums.length; i++) {  arr[i] &#x3D; Integer.parseInt(nums[i]);} 多个数据：      String nums[] &#x3D; in.readLine().split(“ “)； int n &#x3D; Integer.parseInt(nums[0]);  int m &#x3D; Integer.parseInt(nums[1]);  多行输入：StringBuilder sb &#x3D; new StringBuilder();String line;while ((line &#x3D; in.readLine()) !&#x3D; null &amp;&amp; !line.isEmpty()) {  sb.append(line).append(“\n”);}String input &#x3D; sb.toString();</p>
<h2 id="快写"><a href="#快写" class="headerlink" title="快写:"></a>快写:</h2><p> PrintWriter out &#x3D; new PrintWriter(new OutputStreamWriter(System.out));out.print(n);out.flush();</p>
<h2 id="1-搜索spfa（路径）"><a href="#1-搜索spfa（路径）" class="headerlink" title="1.搜索spfa（路径）"></a>1.搜索spfa（路径）</h2><p>求单源起点到任意点的距离，图的权值有题目决定设置中间节点和距离简单的dfs（灌溉，长草，扫雷,受伤的皇后）板子题难一点的dfs（全球变暖，滑雪，剪格子）滑雪：dp数组保存最大的距离     剪格子：回溯，剪枝全球变暖：简单的bfs（迷宫带路径输出，01迷宫）队列操作，取节点，用节点，进节点难一点的bfs（青蛙跳杯子）每次比较队列里的不同的字符串，字符串保存在set集合中，每次bfs和当前两串‘*’之间的距离，</p>
<h2 id="2-字符串StringBuilder"><a href="#2-字符串StringBuilder" class="headerlink" title="2.字符串StringBuilder"></a>2.字符串StringBuilder</h2><p>StringBuffer 回文：String.compareto (StringB(String str).reverse.toString) &#x3D;&#x3D; 0;桶排序：记录每个字符串中每个字母出现的次数int book []&#x3D;new int [26];for(int i:n){book[str.charAt(i)-‘A’]++;}sysout((char)(‘A’+i));取所有子串：for(int i&#x3D;0;i&lt;n;i++){for(int j&#x3D;i;j&lt;n;j++){ String str &#x3D; s.subString(i,j+1);}}是否单调递增：abb型：最长平衡子串：Excel：卡片：数组存放每一张卡片，循环字符串数组减去。删除字符：留下的字典序最小，while(t&gt;0){ 每次比较两个字符即可; t–;}</p>
<h2 id="3-数论欧拉筛"><a href="#3-数论欧拉筛" class="headerlink" title="3.数论欧拉筛"></a>3.数论欧拉筛</h2><p>– 求解范围内的质数以及判断某个数是否是质数：private static boolean isprime(int n){  if(n&lt;2){return false;}<br>  boolean [] isprime &#x3D; new boolean[n+1];  Arrays.fill(isprime,true);    &#x2F;&#x2F;通过标记每个质数的倍数来筛选出所有的合数，如果一个数没有  for(int i&#x3D;2;i * i &lt;&#x3D; n;i++){    if(isprime[i]){    for(int j&#x3D; i * i;j&lt;&#x3D;n;j+&#x3D;i){      isprime[j] &#x3D; false;    }  }}  return isprime[n];}因子&#x2F;质因子分解–求解质因子个数：private static int zyfj(int n) {  if(n&lt;2) {    return 0;  }  int count&#x3D;0;  for(int i&#x3D;2;i<em>i&lt;&#x3D;n;i++){    while(n % i&#x3D;&#x3D;0) {      count++;      n&#x2F;&#x3D;i;    }  }  if(n&gt;1) {    count++;  }  return count;}唯一分解定理–求解约数个数：private static int wyfj(int n) {  int count &#x3D;1;  for(int i&#x3D;2;i</em>i&lt;&#x3D;n;i++) {    int ans &#x3D;0;    while(n % i &#x3D;&#x3D;0) {      ans++;      n&#x2F;&#x3D;i;    }    if(ans&gt;0) {      count *&#x3D; (ans+1);    }  }  if(n&gt;1) {    count *&#x3D;2;  }  return count;}<br>仓库：所有的因子添加到集合中，遍历找答案纯质数：数位拆分判断每一位是否为质数，boolean数组保存0-9[]的数是否为质数大数：BigInteger,含有mod，mutiply，divide，pow, abs, 利用大数的gcd求(1-n的)lcm：等差数列：d &#x3D; (an - a1) &#x2F; (n-1); Sn &#x3D; n * (an+a1) &#x2F; 2;等比数列：q &#x3D; an &#x2F; a1 ^ (1&#x2F;(n-1)); Sn &#x3D; a1 * (1-q^n) &#x2F; (1-q); 斐波那契数列：每60项数字的余数形成一个周期；分数的表示：printf(“%d &#x2F; %d”,a,b);小数的表示：printf(“%.2f”,（double) a);阶乘约数：求100!有多少个约数，(1-100)的唯一分解定理，桶排序存放因子的出现的次数；等差素数数列：模拟数字和公差 ,while(isp(a+j)){a &#x3D; a+j; cnt++;}寻找10个连续素数的公差 约数个数：取sqrt，每次+2；大数取余，%即可取后n位；</p>
<h2 id="4-日期判断日期的合法性以及模拟一个日期："><a href="#4-日期判断日期的合法性以及模拟一个日期：" class="headerlink" title="4.日期判断日期的合法性以及模拟一个日期："></a>4.日期判断日期的合法性以及模拟一个日期：</h2><p>记得重置二月份的天数：day[2] &#x3D; 28;格式化日期：SimpleDateFormat sdf &#x3D; new SDF(“yyyy-MM-dd HH:mm:ss”);将long-&gt;Date : Date d &#x3D; new Date(long start);将Date-&gt;long : long start &#x3D; sdf.parse(“2023-04-08 00:00:00”).getTime();跑步锻炼：每天星期一跑步：new Date(long start).toString.contains(“01 “); – 1后面含空格</p>
<h2 id="5-模拟枚举枚举："><a href="#5-模拟枚举枚举：" class="headerlink" title="5.模拟枚举枚举："></a>5.模拟枚举枚举：</h2><p>顺子日期：刷题统计：每天打卡题数形成数组，模拟天数（注意i++的位置）和日期换瓶盖：模拟瓶盖数和饮料总数<br>模拟：天干地支：两个数组分别存放天干地支，分别模拟1960年前后的年份，前面天干地支–，后面天干地支++，注意达到数组界限时，天干地支取数组上界或下界；玩具：直接找规律模拟即可纸张尺寸：A1，for(int i&#x3D;48;i&lt;c[1];i++){ } – 太妙了，模拟的是Ax尺寸的尺寸的次数翻硬币：两个数组，遍历，若元素不同则翻动两个硬币，三元符号表示： c[i] &#x3D;&#x3D;’<em>‘?’o’:’</em>‘;</p>
<h2 id="6-二分贪心贪心"><a href="#6-二分贪心贪心" class="headerlink" title="6.二分贪心贪心:"></a>6.二分贪心贪心:</h2><p>答疑：题目要求的是在中间时刻开始时，(即前一次答疑结束到下一次答疑的开始)，数组含多个元素的快速排序：Arrays.sort(nums,(a,b) -&gt; (a[0]+a[1]+a[2]) - (b[0]+b[1]+b[2]))for(int i&#x3D;0;i&lt;n;i++){for(int j&#x3D;0;j&lt;3;j++){ sum+&#x3D;nums[i][j]; if(j &#x3D;&#x3D; 1) ans+&#x3D;sum; }}谈判：付账：判断一个人的钱乘以n是否恰好等于总数   money *(n-1)&lt;s?需要付完 : 选择方差最小的金额付款; </p>
<p>二分：int l&#x3D;0,r &#x3D; 10000;while(l&lt;&#x3D;r){  int mid &#x3D; (l+r)&gt;&gt;1;  if(check()){ ret &#x3D; mid ; r &#x3D; mid -1;}else{ l &#x3D; mid+1;}} ret即是答案递增三元组：双指针，a和c数组分别模拟一个指针的移动，遍历b数组，直到找到满足条件的下标；数组a找最后一个，数组c找第一个分巧克力：按题目要求是分成正方形,即二分的题目求出符合题意的check()即可，count +&#x3D; (ab[i][0] &#x2F; mid) * (ab[i][1] &#x2F; mid );路标：两个路标之间的距离&lt;mid,不需要设置，否则在当前路标设置一个距离为mid的路标，不断重复模拟合适的mid。</p>
<h2 id="7-基础知识"><a href="#7-基础知识" class="headerlink" title="7.基础知识"></a>7.基础知识</h2><p>拷贝：答案存在小数+1的情况；ASCII码:’0’:48 A’65’ a’97’进制转换：Integer.toHex &#x2F; toOct &#x2F; toBina (将十进制转化为16 &#x2F; 8 &#x2F; 2 进制)一次向List添加多个数据ArrayList&lt;&gt;list &#x3D; new ; list.addAll(Arrays.asList(2,3,23,32,32,23,32));读文件 String Path &#x3D; “D:\lq\b.txt”;BuffR in &#x3D; new br(new inps(new fileinpt(new file(Path))));String line &#x3D; “”; while(){(line &#x3D; in.readline())!&#x3D; null}</p>
<h2 id="8-暴力位运算："><a href="#8-暴力位运算：" class="headerlink" title="8.暴力位运算："></a>8.暴力位运算：</h2><p>(左移)两家医院分15批口罩，求分得的口罩数的差值尽可能的小&#x2F;&#x2F;模拟1-2^15种所有的可能sfor(int i&#x3D;0;i&lt;(1&lt;&lt;15);i++) {      int sum1&#x3D;0;int sum2&#x3D;0;      &#x2F;&#x2F;j表示枚举每次的口罩将给那一家医院，在15位二进制数的      &#x2F;&#x2F;情况下，1给第一家,0给第二家      for(int j&#x3D;0;j&lt;15;j++) {        if( (i &amp; (1&lt;&lt;j) ) !&#x3D;0) {          sum1 +&#x3D;nums[j];        }else {          sum2 +&#x3D;nums[j];        }      }      &#x2F;&#x2F;每一种情况下，两家医院口罩数量的差值，保留最小的na一个      ans &#x3D; Math.min(ans, Math.abs(sum1 -sum2));    }<br>倍数问题：一个数组找三个数，是k的倍数，求三数之和从尾部开始暴力，for(int i&#x3D;n-1;i&gt;&#x3D;2;i–) {                for(int j&#x3D;i-1;j&gt;&#x3D;1;j–) {                  for(int q &#x3D; j-1;q&gt;&#x3D;0;q–) {                     &#x2F;&#x2F;剪枝 if(sum&lt;ans) break;                           &#x2F;&#x2F;后面都小于，不必再判断                           if(a[i]+a[j]+a[j-1]&lt;ans) {                             break;}}                           &#x2F;&#x2F;后面都小于，不必再判断                             if(a[i]+a[i-1]+a[i-2]&lt;ans) {                               break;                                    }&#x2F;&#x2F;(60%)<br>灯塔：暴力枚举每个点，计算它到灯塔的距离是否小于半径，即可判断能否被照到递增序列：暴力枚举每个点的中心散发的左下，右上，右下，同一行，同一列的直线是否递增<br>真-暴力: &#x2F;&#x2F;直接暴力三重循环  int count &#x3D; 0;  for (int i &#x3D; 0; i &lt; 30; i++) {    for (int j &#x3D; 0; j &lt; 50; j++) {        int num &#x3D; a[i][j];        &#x2F;&#x2F;每一行        for(int t &#x3D; i+1;t&lt;30;t++) {          if(num&lt;a[t][j]) {            count++;          }        }                &#x2F;&#x2F;每一列        for(int t&#x3D;j+1;t&lt;50;t++) {          if(num&lt;a[i][t]) {            count++;          }        }        &#x2F;&#x2F;左下斜线        for(int t &#x3D; i+1,tt &#x3D;j-1;t&lt;30&amp;&amp;tt&gt;&#x3D;0;t++,tt–){          if(num&lt;a[t][tt]) {            count++;          }        }        &#x2F;&#x2F;右上斜线        for(int t &#x3D; i-1,tt&#x3D;j+1;t&gt;&#x3D;0&amp;&amp;tt&lt;50;t–,tt++) {          if(num&lt;a[t][tt]) {            count++;          }        }        &#x2F;&#x2F;右下斜线        for(int t&#x3D;i+1,tt&#x3D;j+1;t&lt;30&amp;&amp;tt&lt;50;t++,tt++) {          if(num&lt;a[t][tt]) {            count++;          }        }      }    }<br>2019分解： 分解为3个不同数的和，有顺序：i取前1&#x2F;3,j取i后面，k取j后面，能保证取到的数不重复for(int i&#x3D;1;i&lt;s&#x2F;3+1;i++) {      for(int j&#x3D;i+1;j&lt;s;j++) {        for(int k&#x3D;j+1;k&lt;s;k++) {<br>卡片：三种卡片有6个不同的组合，n人至少需要i个：两层循环解决；4平方和：拉格朗日定理可以取相同的数：20 &#x3D; 0 0 2 4，后面的数一定是最大的，for (int i1&#x3D;0;i1<em>i1&lt;&#x3D;n;i1++)     for (int i2&#x3D;i1;i2</em>i2&lt;&#x3D;n;i2++)       for (int i3&#x3D;i2;i3<em>i3&lt;&#x3D;n;i3++)         for (int i4&#x3D;i3;i4</em>i4&lt;&#x3D;n;i4++)           if (i1<em>i1+i2</em>i2+i3<em>i3+i4</em>i4&#x3D;&#x3D;n) {</p>
<p>字母阵列：求中心散射的八个方向直线上形成”lanqiao”直接枚举8个点的方向：for(int i&#x3D;0;i&lt;n;i++) {        for(int j&#x3D;0;j&lt;n;j++) {          if(zhi[i][j]&#x3D;&#x3D;’L’) {&#x2F;&#x2F;向8个方向寻找搜索            if(j+6&lt;n&amp;&amp;zhi[i][j+1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i][j+2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i][j+3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i][j+4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i][j+5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i][j+6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向右寻找            }            if(i+6&lt;n&amp;&amp;zhi[i+1][j]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+2][j]&#x3D;&#x3D;’N’&amp;&amp;zhi[i+3][j]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i+4][j]&#x3D;&#x3D;’I’&amp;&amp;zhi[i+5][j]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+6][j]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向下寻找            }            if(j-6&gt;&#x3D;0&amp;&amp;zhi[i][j-1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i][j-2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i][j-3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i][j-4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i][j-5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i][j-6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向左寻找            }            if(i-6&gt;&#x3D;0&amp;&amp;zhi[i-1][j]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-2][j]&#x3D;&#x3D;’N’&amp;&amp;zhi[i-3][j]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i-4][j]&#x3D;&#x3D;’I’&amp;&amp;zhi[i-5][j]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-6][j]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向上寻找            }            if(j+6&lt;n&amp;&amp;i+6&lt;n&amp;&amp;zhi[i+1][j+1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+2][j+2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i+3][j+3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i+4][j+4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i+5][j+5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+6][j+6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向右下寻找            }            if(j-6&gt;&#x3D;0&amp;&amp;i+6&lt;n&amp;&amp;zhi[i+1][j-1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+2][j-2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i+3][j-3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i+4][j-4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i+5][j-5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+6][j-6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向左下寻找            }            if(i-6&gt;&#x3D;0&amp;&amp;j-6&gt;&#x3D;0&amp;&amp;zhi[i-1][j-1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-2][j-2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i-3][j-3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i-4][j-4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i-5][j-5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-6][j-6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向左上寻找            }            if(i-6&gt;&#x3D;0&amp;&amp;j+6&lt;n&amp;&amp;zhi[i-1][j+1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-2][j+2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i-3][j+3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i-4][j+4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i-5][j+5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-6][j+6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向右上寻找            }<br>最大子矩阵：四层循环遍历矩阵，从左上角遍历到右下角,每次取不同的子块来遍历，子矩阵最大最小值&lt;limit     for(int i&#x3D;N;i&gt;0;i–) {      for(int j&#x3D;M;j&gt;0;j–) { &#x2F;&#x2F; i*j的矩阵(右下角的坐标)        for(int x&#x3D;0;x&lt;&#x3D;N-i;x++) {          for(int y&#x3D;0;y&lt;&#x3D;M-j;y++) { &#x2F;&#x2F;左上角坐标            int max &#x3D; find_max(i,j,x,y);            int min &#x3D; find_min(i,j,x,y);<br>private static int find_max(int i, int j, int x, int y) {    &#x2F;&#x2F; 寻找最大值    int res &#x3D; Integer.MIN_VALUE;    for(int n&#x3D;x;n&lt;x+i;n++) {      for(int m&#x3D;y;m&lt;y+j;m++) {        res &#x3D; Math.max(res, arr[n][m]);      }    }    return res;  }</p>
<h1 id="其他知识点："><a href="#其他知识点：" class="headerlink" title="其他知识点："></a>其他知识点：</h1><p>1M&#x3D;1024kb 1kb&#x3D;1024字节 1字节&#x3D;8bit ASCII码：A:65 a:97<br>计算机算法：枚举、排序、搜索、计数、贪心、动态规划、图论、数论、博弈论<em>、概率论</em>、计算几何<em>、字符串算法等。数据结构：数组、对象&#x2F;结构、字符串、队列、栈、树、图、堆、平衡树&#x2F;线段树、复杂数据结构</em>、嵌套数据结构<em>等 暴力枚举需要注意变量的重置为0，即枚举下一个新的数时，需要将之前计算的值清零<br>ArrayList.addAll(Arrays.aslist(xx,xx,xx))ArrayList<Integer> arr &#x3D; new ArrayList<E>();添加数据到数组中，多用于求因子类的题目 remove()去掉首项 get()[从0开始]取元素Arrays.sort(数组自然排序)<br>基础：1.数位拆分 x % y x &#x2F; y &#x2F;&#x2F;计算一个数字每个位数之和public static int getsum(int num){int sum&#x3D;0;while(num !&#x3D;0){  sum +&#x3D; num %10;  num &#x2F;&#x3D;10;}return sum;}&#x2F;&#x2F;模拟字母public static String gename(int n){StringBuilder sb &#x3D; new StringBuilder();while(n&gt;0){n–;sb.append((char)(‘A’ + n % 26));n &#x2F;&#x3D;26;     }return sb.reverse().toString();   }}2.进制模拟String hexNum &#x3D; Integer.toHexString(var).toUpperCase();&#x2F;&#x2F;将十进制转化为十六进制且全部字母都为大写 Integer.toBinaryString(var) 十进制转为二进制 Integer.toOctalString(var)十进制转化八进制 匹配二进制 “^[01]+$” 八进制 “^[0-7]+$” 十六进制 “^[a-fA-F0-9]+$”<br>其他进制转化为十进制String Bin &#x3D; “01”;int x &#x3D; Integrt.parseInt(binary,2);int y &#x3D; Integer.parseInt(octal,8);String Hex &#x3D; “ABD”;int z &#x3D; Integer.parseInt(hex,16);<br>3.最大公约数 &amp; 最小公倍数public static int gcd(int x,int y) {      return y&#x3D;&#x3D;0?x:gcd(y,x % y);    }public static int lcm(int x,int y){    return x * y &#x2F; gcd(x,y);}4.位运算：if(i &amp; (1&gt;&gt;j) )!&#x3D;0 {};5.高精度模拟：printf(“%.2f”,a);6.素数初步： private static boolean isP(int num){  if(num &lt;&#x3D;1){  return false;} for(int i&#x3D;2;i&lt;&#x3D;Math.sqrt(num);i++){if(num % i &#x3D;&#x3D;0){return false;}}return true;}<br>7.余数及相关：%8.大数系列：BigInteger类大数可以+-<em>&#x2F; % 等操作(一般对数字进行的操作都会有)add,subtract,mod,BigInteger num &#x3D; new BigIntger(“20”);BigInteger ans &#x3D; new BigInteger(“1”);for(int i&#x3D;1;i&lt;&#x3D;22;i++){     ans &#x3D; ans.mutiply(num);}9.唯一分解定理：10.日期类：&#x2F;&#x2F;判断是否是闰年public static boolean isLeap(int year){ return (year % 4 &#x3D;&#x3D;0 &amp;&amp; year % 100 !&#x3D;0) || year % 400 &#x3D;&#x3D;0};&#x2F;&#x2F;计算某个月的天数public static int getDays(int year,int month){if(month &#x3D;&#x3D;2){  return isLeap(year)?29:28;}else if(month &#x3D;&#x3D; 4||month &#x3D;&#x3D;6||month&#x3D;&#x3D;9||month&#x3D;&#x3D;11){  return 30;}else{ return 31;}}<br>runningMax:例子SimpleDateformatlong (模拟毫秒数，以毫秒为单位模拟一天的增加)日期之间不能比较。但是转换为毫秒数之后可以相比Date(模拟日期) d &#x3D; new Date(long);SimpleDateFormat sdf &#x3D; new SimpleDateFormat(“yyyy-HH-dd hh:mm:ss”);用来格式化日期的格式，即题目给的日期格式Long start &#x3D; sdf.parse(“2022-02-02 02:02:02”).getTime(); &#x2F;&#x2F;将指定的格式化日期转化为相应的毫秒数Date d &#x3D; new Date(start);&#x2F;&#x2F;再将指定的毫秒数转为对应的日期sysout d.toString();&#x2F;&#x2F;输出日期&#x2F;&#x2F;模拟一天过去start &#x3D; new Date(start).getTime() + 24<em>60<em>60</em>1000L;<br>Calender(模拟日期)<br>字符串：<br> &#x2F;&#x2F;取一个字符串的所有的子串        for(int i&#x3D;0 ; i&lt;str.length(); i++){          for(int k&#x3D; i; k&lt;str.length(); k++){            String res &#x3D; str.substring(i,k+1);            System.<strong>out**.println(res)          }        }回文字符串使用一个方法private static boolean ishuiwen(String str){  int left &#x3D;0;int right &#x3D;str.length()-1;while(left &lt; right){if(str.charAt(leftt) !&#x3D; str.charAt(right)){  return false;}left++;right–;}sreturn true;}简单字符串统计：桶排序：int []a &#x3D; new int [n];char [] c &#x3D; a.tocharArray();a[(chatAt(c) - ‘A’)]++&#x2F;&#x2F;得出相应字母在数组中保存的数量(char)( i + ‘A’) &#x2F;&#x2F; 输出相对应的字母String 1.比较：compareTo() 返回0 表示相等2.String[] arr &#x3D; str.split(“”);切割字符串,形成字符串数组<br>Stringbuffer StringBuilder (反转：reverse())String 转型 int : str.valueOf();int 转型 String : 1 +“ ”   有字串的题目可以使用老白嫖方法-》》详情见字串分值<br>解密：模拟：周期串：困难串：<br>OJ几类格式训练：字符串hash+二分：正则表达式：<br>排序：冒泡+插入+选择+希尔+计数+堆排序….java对象排序：<br>数据结构：栈和队列：链表：Set<String> set &#x3D; new HashSet&lt;&gt;();set.add();set.contains();去重:(求不同的字符串子串）HashMap&lt;Character,Integer&gt; map &#x3D; new HashMap&lt;&gt;();(本质就是一个函数映射的关系，一个值对应一个数量,如 a ：2 ，b : 3）求出现字符最多的次数map.put( c , map.getorDefalut(c,0) +1);map.get(Object o);&#x2F;&#x2F;求一个值的数量循环map中的元素for(char c : map.keyset(){  map.get(c) ;}ArrayList<Integer> list &#x3D; new ArrayList&lt;&gt;();Collections.sort(list);&#x2F;&#x2F;运用集合对动态数组进行排序TreeMap 哈希表<br>穷举-模拟：   百钱白鸡凶手分糖果接雨水<br>递归：汉诺塔连分数<br>分治：归并快排快速幂<br>搜索：DFS:矩阵搜索，最短路径，迷宫1.设置矩阵的范围2.访问数组 visited[] ，访问一个位置后，修改它的值3.初始化需要求的数值（面积，数的和等）4.上下左右四个方向递归BFS<br>回溯剪枝<br>贪心：找零动态规划：1.返回值（避免重复遍历，只要dp[i][j] !&#x3D;0）if(dp[i][j!&#x3D;0]){return dp[i][j];}2.设置初值int max &#x3D;1;3.模拟每个位置的上下左右移动for(int k&#x3D;0;k&lt;4;k++){int x &#x3D; i+dx[k]; int y &#x3D; j + dy[k];}4.判断条件if(不符合的情况){continue;}5.状态转移方程(注意是否要+1)是取最大值还是数的和6.保存所求值LCSLISLPS最大子矩阵背包专题<br>二叉树：前中后层次遍历建树遍历二叉树还原字典树哈夫曼编码并查集<br>图：图的存储1.邻接矩阵2.邻接表<br>DFS<br>BFS最小生成树最短路径：有模板Dijkstra 算法是一种贪心算法，用于求加权图的单源最短路径问题，其中所有边的权重都必须是非负数。这个算法的基本思路是从起点开始，先确定起点到所有点的最短路径，然后不断扩大已确定最短路径的节点集合，直到到达终点。<br>难点：素数进阶矩阵快速幂前缀和与差分具体题目：</strong>“k倍区间”</em></em></em><em>一维数组的前缀和数组a[1,2,3,4,5] 前缀和sum[1,3,6,10,15] 余数[1,1,0,0,1] 余数(数量)[2,3];&#x2F;&#x2F;余数等于数组相应下标的个数</em>*   **余数为0的自成一个k倍区间 count+&#x3D;v[0];**<strong>余数不为0(余数相同)1.存储余数的数量。两两组合(求和公式)可以构成一个k倍区间 count+&#x3D;(v[i] *( v[ i ] - 1 ) ) &#x2F;2</strong> **2.存储余数。的根据同余定理，如果两个前缀和对 k 取余数的结果相同，那么它们的差or和一定是 k 的倍数(23%2 &#x3D; 1 ;13% 2&#x3D;&#x3D;1；|(13+-23)| %2 &#x3D;&#x3D;0)**小木棍 - 剪枝过关数位DPs区间DP状压DP线段树</p>
]]></content>
      <categories>
        <category>lqb</category>
      </categories>
      <tags>
        <tag>lqb</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2023/09/09/mst/</url>
    <content><![CDATA[<h1 id="学成在线项目的面试题："><a href="#学成在线项目的面试题：" class="headerlink" title="学成在线项目的面试题："></a>学成在线项目的面试题：</h1><h2 id="1-Maven："><a href="#1-Maven：" class="headerlink" title="1.Maven："></a>1.Maven：</h2><p>mvn clean compile test package install deploy 清除target 编译源代码 执行单元测试 打包 打包并保存到本地 打包并上传到服务器 </p>
<h3 id="1-1依赖版本冲突怎么处理："><a href="#1-1依赖版本冲突怎么处理：" class="headerlink" title="1.1依赖版本冲突怎么处理："></a>1.1依赖版本冲突怎么处理：</h3><p>1.使用exclusion排除依赖 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 排除 Spring Boot 依赖的日志包冲突 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.通常在父工程对依赖版本进行曲管理</p>
<p>在父工程的pom.xml文件中使用dependencymanager进行依赖版本的管理即可。</p>
<p>1.2</p>
<h2 id="2-Mysql"><a href="#2-Mysql" class="headerlink" title="2.Mysql"></a>2.Mysql</h2><h3 id="2-1Mysql-常见的存储引擎和区别："><a href="#2-1Mysql-常见的存储引擎和区别：" class="headerlink" title="2.1Mysql 常见的存储引擎和区别："></a>2.1Mysql 常见的存储引擎和区别：</h3><h4 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1.InnoDB"></a>1.InnoDB</h4><p>1.支持事务控制</p>
<p>2.使用的锁粒度默认为行级锁，可以支持更高的并发，也支持表锁。</p>
<p>3.支持外键约束；外键约束其实降低了表的查询速度，增加了表之间的耦合度。</p>
<h4 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2.MyISAM"></a>2.MyISAM</h4><p>1.不提供事务支持</p>
<p>2.只支持表级锁</p>
<p>3.不支持外键</p>
<h4 id="3-memory"><a href="#3-memory" class="headerlink" title="3.memory"></a>3.memory</h4><p>数据存储在内存中</p>
<h4 id="4-总结："><a href="#4-总结：" class="headerlink" title="4.总结："></a>4.总结：</h4><p>InnoDB用于事务处理，具有ACID事务支持等特性，应用中需执行大量的insert &amp;&amp; update 等操作</p>
<p>MyISAM管理非事务表，提供高速存储和检索以及全文搜索的能力，应用需执行大量select</p>
<h3 id="2-2Mysql建表注意事项"><a href="#2-2Mysql建表注意事项" class="headerlink" title="2.2Mysql建表注意事项:"></a>2.2Mysql建表注意事项:</h3><h4 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1.存储引擎"></a>1.存储引擎</h4><p>是否支持事务控制</p>
<h4 id="2-字段类型选择"><a href="#2-字段类型选择" class="headerlink" title="2.字段类型选择"></a>2.字段类型选择</h4><p>日期：datetime （时分秒） date（年月日）</p>
<p>字符：固定长度 char 不定长 varchar</p>
<p>长文本: text longtest</p>
<p>图片等二进制数据：blob，longblob</p>
<p>金额: DECIMAL</p>
<p>数值类型：确保取值范围足够的前提下使用较小空间的类型</p>
<h4 id="3-字段"><a href="#3-字段" class="headerlink" title="3.字段"></a>3.字段</h4><p>3.1自然主键（id就好）建议使用int unsigned类型, 该主键不能有业务意义，特殊场景使用bigint</p>
<p>3.2如果要存储test，blob字段建议单独建表，在使用外键关联</p>
<p>3.3尽量不要定义外键，保证表的独立性，可以存在外键意义的字段</p>
<p>3.4设置字段的默认值，并写清楚注释，注意字段的约束（非空，唯一，主键等）</p>
<h3 id="2-3Mysql如何查询树形表"><a href="#2-3Mysql如何查询树形表" class="headerlink" title="2.3Mysql如何查询树形表"></a>2.3Mysql如何查询树形表</h3><p>树形表的标记字段是parentid即父节点的id</p>
<p>有两种方法：</p>
<p>1）当层级固定时可以使用表的自连接</p>
<p>2）如果想灵活查询每一个层级可以使用mysql递归的方法，使用 with RESCURSIVE</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">with recursive t1 <span class="title function_">as</span> <span class="params">(</span></span><br><span class="line"><span class="params">    select * from course_category where id=#&#123;id&#125;</span></span><br><span class="line"><span class="params">    union all</span></span><br><span class="line"><span class="params">    select t2.* from course_category t2 inner join t1 on t1.id = t2.parentid</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">select * from t1</span><br><span class="line">order by t1.id</span><br></pre></td></tr></table></figure>

<h2 id="3-SpingBoot"><a href="#3-SpingBoot" class="headerlink" title="3.SpingBoot"></a>3.SpingBoot</h2><h3 id="3-1springBoot接口开发常用的注解有哪些："><a href="#3-1springBoot接口开发常用的注解有哪些：" class="headerlink" title="3.1springBoot接口开发常用的注解有哪些："></a>3.1springBoot接口开发常用的注解有哪些：</h3><p>1.@Controller标记此类是控制器，可以返回视图解析器指定的html页面，通过@ResponseBody可以将结果返回json，xml数据</p>
<p>2.RestController相当于@ResponseBody+@Controller实现rest接口开发，返回json数据，不能返回html页面。</p>
<p>3.RequestMapping定义接口地址，类或方法上方，支持http的post，put，get</p>
<p>4.PostMapping 定义post接口，添加记录，复杂条件的查询接口</p>
<p>5.GetMapping 定义get接口，查询接口</p>
<p>6.PutMapping 定义put接口，修改接口</p>
<p>7.DeleteMapping 定义delete接口，删除接口，</p>
<p>8.@RequestBody 定义在方法上，将json串数据转为java对象。</p>
<p>9.@PathVarible 接收请求路径中的占位符的值，地址传参</p>
<p>10.@ApiOperation swagger 注解，对接口方法进行说明</p>
<p>11.@Autowired 基于类型注入service接口，从容器中找到service的javabean</p>
<p>12.@Resource 基于名称注入，失败则转化为进行基于类型注入</p>
<p>13.@Api swagger 注解，读接口类进行说明</p>
<h3 id="3-2请求参数的合法性校验"><a href="#3-2请求参数的合法性校验" class="headerlink" title="3.2请求参数的合法性校验"></a>3.2请求参数的合法性校验</h3><h4 id="3-2-1数据的校验"><a href="#3-2-1数据的校验" class="headerlink" title="3.2.1数据的校验"></a>3.2.1数据的校验</h4><p>必填项校验，数据格式校验（非空，是否符合日期格式）</p>
<p>基于JSR303校验框架实现，SpringBoot提供了JSR-303的支持，它就是spring-boot-starter-validation,它包含很多校验规则，只需要在模型类中通过注解指定校验规则，在controller方法上开启。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.content.api;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ApiOperation(&quot;新增课程&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/course&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CourseBaseInfoDto <span class="title function_">createCourseBase</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(ValidationGroups.Inster.class)</span> AddCourseDto addCourseDto)</span>&#123;</span><br><span class="line"></span><br><span class="line">        SecurityUtil.<span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> SecurityUtil.getUser();</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">//获取到用户所属机构的id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">companyId1</span> <span class="operator">=</span> user.getCompanyId();</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">companyId</span> <span class="operator">=</span> Long.parseLong(companyId1);</span><br><span class="line"><span class="comment">//        int i = 1/0;</span></span><br><span class="line">        <span class="type">CourseBaseInfoDto</span> <span class="variable">courseBase</span> <span class="operator">=</span> courseBaseInfoService.createCourseBase(companyId, addCourseDto);</span><br><span class="line">        <span class="keyword">return</span> courseBase;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.content.model.dto;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(value=&quot;AddCourseDto&quot;, description=&quot;新增课程基本信息&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddCourseDto</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@NotEmpty(message = &quot;新增课程名称不能为空&quot;,groups=&#123;ValidationGroups.Inster.class&#125;)</span></span><br><span class="line"> <span class="meta">@NotEmpty(message = &quot;修改课程名称不能为空&quot;,groups=&#123;ValidationGroups.Update.class&#125;)</span></span><br><span class="line"><span class="comment">// @NotEmpty(message = &quot;课程名称不能为空&quot;)</span></span><br><span class="line"> <span class="meta">@ApiModelProperty(value = &quot;课程名称&quot;, required = true)</span></span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@NotEmpty(message = &quot;适用人群不能为空&quot;)</span></span><br><span class="line"> <span class="meta">@Size(message = &quot;适用人群内容过少&quot;,min = 10)</span></span><br><span class="line"> <span class="meta">@ApiModelProperty(value = &quot;适用人群&quot;, required = true)</span></span><br><span class="line"> <span class="keyword">private</span> String users;</span><br></pre></td></tr></table></figure>

<p>校验分组：不同类型的校验需要不同的组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.base.exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 用于分级校验，定义一些常用的组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/14 9:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidationGroups</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Inster</span>&#123;&#125;;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Update</span>&#123;&#125;;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Delete</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2业务逻辑的校验"><a href="#3-2-2业务逻辑的校验" class="headerlink" title="3.2.2业务逻辑的校验"></a>3.2.2业务逻辑的校验</h4><p>在service中校验即可，例如判断只有本机构才能修改本机构的课程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据合法性校验</span></span><br><span class="line"><span class="comment">//根据具体的业务逻辑去校验</span></span><br><span class="line"><span class="comment">//本机构只能修改本机构的课程</span></span><br><span class="line"><span class="keyword">if</span>(!companyId.equals(courseBase.getCompanyId()))&#123;</span><br><span class="line">    XueChengPlusException.cast(<span class="string">&quot;本机构只能修改本机构的课程&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Mybatis"><a href="#4-Mybatis" class="headerlink" title="4.Mybatis"></a>4.Mybatis</h2><h3 id="4-1Mybatis分页插件原理"><a href="#4-1Mybatis分页插件原理" class="headerlink" title="4.1Mybatis分页插件原理:"></a>4.1Mybatis分页插件原理:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.auth.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *；</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;P&gt;</span></span><br><span class="line"><span class="comment"> *        Mybatis-Plus 配置</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.xuecheng.ucenter.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 新的分页插件</span></span><br><span class="line"><span class="comment">    * 需要设置 MybatisConfiguration#useDeprecatedExecutor = false</span></span><br><span class="line"><span class="comment">    * 避免缓存出现问题(该属性会在旧插件移除后一同移除)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">      interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">      <span class="keyword">return</span> interceptor;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现原理：首先将分页参数放到ThreadLocal中，拦截执行的sql，根据数据库类型添加对应的分页语句重写sql，例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">（<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> a）<span class="comment">--&gt; (select count(*) from table where a ) 和 （select * from table where a limit）</span></span><br></pre></td></tr></table></figure>

<p>计算出total总条数，pageNum当前第几页，pageSize每页大小和当前页的数据，是否为首尾页和总页数等，</p>
<h3 id="4-2Mybatis的ResultType-和-ResultMap的区别"><a href="#4-2Mybatis的ResultType-和-ResultMap的区别" class="headerlink" title="4.2Mybatis的ResultType 和 ResultMap的区别"></a>4.2Mybatis的ResultType 和 ResultMap的区别</h3><p>Result指定映射的类型，只要查询字段名和类型的属性名匹配即可自动映射，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectTreeNodes&quot;</span>  parameterType=<span class="string">&quot;string&quot;</span> resultType=<span class="string">&quot;com.xuecheng.content.model.dto.CourseCategoryTreeDto&quot;</span>&gt;</span><br><span class="line">    with recursive t1 <span class="title function_">as</span> <span class="params">(</span></span><br><span class="line"><span class="params">        select * from course_category where id=#&#123;id&#125;</span></span><br><span class="line"><span class="params">        union all</span></span><br><span class="line"><span class="params">        select t2.* from course_category t2 inner join t1 on t1.id = t2.parentid</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">    select * from t1</span><br><span class="line">    order by t1.id</span><br><span class="line"></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>ResultMap 自定义映射规则，不匹配，实现一对一，一对多的映射。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 通用查询映射结果 --&gt;</span><br><span class="line">&lt;resultMap id=<span class="string">&quot;BaseResultMap&quot;</span> type=<span class="string">&quot;com.xuecheng.content.model.po.CourseCategory&quot;</span>&gt;</span><br><span class="line">    &lt;id column=<span class="string">&quot;id&quot;</span> property=<span class="string">&quot;id&quot;</span> /&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;name&quot;</span> property=<span class="string">&quot;name&quot;</span> /&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;label&quot;</span> property=<span class="string">&quot;label&quot;</span> /&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;parentid&quot;</span> property=<span class="string">&quot;parentid&quot;</span> /&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;is_show&quot;</span> property=<span class="string">&quot;isShow&quot;</span> /&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;orderby&quot;</span> property=<span class="string">&quot;orderby&quot;</span> /&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;is_leaf&quot;</span> property=<span class="string">&quot;isLeaf&quot;</span> /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-和-的区别"><a href="#4-3-和-的区别" class="headerlink" title="4.3 #{} 和${} 的区别"></a>4.3 #{} 和${} 的区别</h3><p>#{} 是标记一个占位符，可以防止sql注入</p>
<p>${} 用于在动态sql中拼接字符串，可能导致sql注入</p>
<h2 id="5-系统如何进行异常处理"><a href="#5-系统如何进行异常处理" class="headerlink" title="5.系统如何进行异常处理"></a>5.系统如何进行异常处理</h2><p>自定义一个统一的异常处理器，去捕获并处理异常</p>
<p>1)处理自定义异常</p>
<p>自定义一个异常类，里面有各种异常的信息，主动抛出自定义类的异常对象，并指出详细异常信息，异常处理器捕获日志记录并响应给用户</p>
<p>2）处理未知异常</p>
<p>异常由异常处理器统一捕获，记录异常日志，统一响应500错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.base.exception;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 通用错误信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/6 11:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">CommonError</span> &#123;</span><br><span class="line"></span><br><span class="line">   UNKOWN_ERROR(<span class="string">&quot;执行过程异常，请重试。&quot;</span>),</span><br><span class="line">   PARAMS_ERROR(<span class="string">&quot;非法参数&quot;</span>),</span><br><span class="line">   OBJECT_NULL(<span class="string">&quot;对象为空&quot;</span>),</span><br><span class="line">   QUERY_NULL(<span class="string">&quot;查询结果为空&quot;</span>),</span><br><span class="line">   REQUEST_NULL(<span class="string">&quot;请求参数为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String errMessage;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getErrMessage</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errMessage;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">CommonError</span><span class="params">( String errMessage)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.errMessage = errMessage;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.base.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *；</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/12 17:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="comment">//@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//对项目的自定义异常类型进行处理</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="meta">@ExceptionHandler(XueChengPlusException.class)</span></span><br><span class="line">   <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line"> <span class="keyword">public</span> RestErrorResponse <span class="title function_">customException</span><span class="params">(XueChengPlusException e)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录异常</span></span><br><span class="line">    log.error(<span class="string">&quot;系统异常&#123;&#125;&quot;</span>,e.getErrMessage(),e);</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析出异常信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">errMessage</span> <span class="operator">=</span> e.getErrMessage();</span><br><span class="line">    <span class="type">RestErrorResponse</span> <span class="variable">restErrorResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestErrorResponse</span>(errMessage);</span><br><span class="line">    <span class="keyword">return</span> restErrorResponse;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//MethodArgumentNotValidException</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> RestErrorResponse <span class="title function_">methodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException e)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> e.getBindingResult();</span><br><span class="line">        <span class="comment">//存储错误信息</span></span><br><span class="line">        List&lt;String&gt; errors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        bindingResult.getFieldErrors().stream().forEach(item-&gt;&#123;</span><br><span class="line">            errors.add(item.getDefaultMessage());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将list中的错误信息拼接起来</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">errMessage</span> <span class="operator">=</span> StringUtils.join(errors, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="comment">//记录异常</span></span><br><span class="line">        log.error(<span class="string">&quot;系统异常&#123;&#125;&quot;</span>,e.getMessage(),errMessage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析出异常信息</span></span><br><span class="line">        <span class="type">RestErrorResponse</span> <span class="variable">restErrorResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestErrorResponse</span>(errMessage);</span><br><span class="line">        <span class="keyword">return</span> restErrorResponse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> RestErrorResponse <span class="title function_">exception</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.error(<span class="string">&quot;【系统异常】&#123;&#125;&quot;</span>,e.getMessage(),e);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span>(e.getMessage().equals(<span class="string">&quot;不允许访问&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestErrorResponse</span>(<span class="string">&quot;没有操作此功能的权限&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestErrorResponse</span>(CommonError.UNKOWN_ERROR.getErrMessage());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-什么情况下事务回失效："><a href="#6-什么情况下事务回失效：" class="headerlink" title="6.什么情况下事务回失效："></a>6.什么情况下事务回失效：</h2><h3 id="1-在方法中捕获异常没有抛出"><a href="#1-在方法中捕获异常没有抛出" class="headerlink" title="1)在方法中捕获异常没有抛出"></a>1)在方法中捕获异常没有抛出</h3><p>没有throw该异常</p>
<h3 id="2）非事务方法调用事务方法"><a href="#2）非事务方法调用事务方法" class="headerlink" title="2）非事务方法调用事务方法"></a>2）非事务方法调用事务方法</h3><p>此时需要以代理对象去调用，</p>
<p>1.注入当前的service,创建当前的代理对象 </p>
<p>@AutoWired</p>
<p>MediaFileService currentProxy;</p>
<p>2.在事务方法上声明@Transcation</p>
<h3 id="3）事务方法内部调用事务方法"><a href="#3）事务方法内部调用事务方法" class="headerlink" title="3）事务方法内部调用事务方法"></a>3）事务方法内部调用事务方法</h3><p>在一个事务方法中，不是通过当前代理对象去调用另一个事务方法，不会新建另一个新的事务。</p>
<p>@Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</p>
<h3 id="4-Transactional标记的方法不是public"><a href="#4-Transactional标记的方法不是public" class="headerlink" title="4)@Transactional标记的方法不是public"></a>4)@Transactional标记的方法不是public</h3><h3 id="5-抛出的异常与rollbackFor指定的异常不匹配"><a href="#5-抛出的异常与rollbackFor指定的异常不匹配" class="headerlink" title="5)抛出的异常与rollbackFor指定的异常不匹配"></a>5)抛出的异常与rollbackFor指定的异常不匹配</h3><p>可以在@Transaction()注解中自定义当抛出特定的异常时才需要进行事务控制，进行回滚。</p>
<p>例如 @Transaction(rollbackFor(XxException.class)) </p>
<h3 id="6）数据库表不支持事务处理"><a href="#6）数据库表不支持事务处理" class="headerlink" title="6）数据库表不支持事务处理"></a>6）数据库表不支持事务处理</h3><p>MYISLAM做存储引擎</p>
<h3 id="7）springboot的传播行为导致事务的失效"><a href="#7）springboot的传播行为导致事务的失效" class="headerlink" title="7）springboot的传播行为导致事务的失效"></a>7）springboot的传播行为导致事务的失效</h3><p>@Transaction(PROPAGATION_REQUIRES_NEW)注解中添加需要的代码</p>
<table>
<thead>
<tr>
<th>传播行为</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>当前方法必须在一个事务中运行。如果当前存在事务，方法将加入到当前事务中，如果没有事务，它将创建一个新事务。这是默认的传播行为。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>创建一个新事务，如果当前存在事务，则将其挂起。新事务独立于当前事务运行。成功提交会影响数据库，失败只会影响新事务。</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>当前方法必须在一个事务中运行，但可以创建一个嵌套事务。嵌套事务有自己的保存点，可以回滚到嵌套事务的开始，不影响外部事务。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>方法可以在事务中运行，如果没有事务，则在非事务状态下运行。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>方法在非事务状态下运行，如果当前存在事务，将其挂起，执行完方法后不会提交事务。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>方法绝对不能在事务中运行，如果当前存在事务，将抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>方法必须在一个已存在的事务中运行，如果没有事务存在，将抛出异常。</td>
</tr>
</tbody></table>
<h3 id="8）总结：只有通过当前代理对象调用的方法才能正确进行事务控制"><a href="#8）总结：只有通过当前代理对象调用的方法才能正确进行事务控制" class="headerlink" title="8）总结：只有通过当前代理对象调用的方法才能正确进行事务控制"></a>8）总结：只有通过当前代理对象调用的方法才能正确进行事务控制</h3><h2 id="7-断点续传"><a href="#7-断点续传" class="headerlink" title="7.断点续传"></a>7.断点续传</h2><p>1）前端对文件进行分块 chunk001</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageResult&lt;MediaFiles&gt; <span class="title function_">queryMediaFiels</span><span class="params">(Long companyId, PageParams pageParams, QueryMediaParamsDto queryMediaParamsDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建查询条件对象</span></span><br><span class="line">    LambdaQueryWrapper&lt;MediaFiles&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分页对象</span></span><br><span class="line">    Page&lt;MediaFiles&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageParams.getPageNo(), pageParams.getPageSize());</span><br><span class="line">    <span class="comment">// 查询数据内容获得结果</span></span><br><span class="line">    Page&lt;MediaFiles&gt; pageResult = mediaFilesMapper.selectPage(page, queryWrapper);</span><br><span class="line">    <span class="comment">// 获取数据列表</span></span><br><span class="line">    List&lt;MediaFiles&gt; list = pageResult.getRecords();</span><br><span class="line">    <span class="comment">// 获取数据总数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> pageResult.getTotal();</span><br><span class="line">    <span class="comment">// 构建结果集</span></span><br><span class="line">    PageResult&lt;MediaFiles&gt; mediaListResult = <span class="keyword">new</span> <span class="title class_">PageResult</span>&lt;&gt;(list, total, pageParams.getPageNo(), pageParams.getPageSize());</span><br><span class="line">    <span class="keyword">return</span> mediaListResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）前端使用多线程一块一块上传，上传前给服务端发送信息，核验当前当前分块是否已经上传，否则继续上传。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkFile</span><span class="params">(String fileMd5)</span> &#123;</span><br><span class="line">    <span class="comment">//先查询数据库</span></span><br><span class="line">    <span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> mediaFilesMapper.selectById(fileMd5);</span><br><span class="line">    <span class="keyword">if</span>(mediaFiles!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//桶</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bucket</span> <span class="operator">=</span> mediaFiles.getBucket();</span><br><span class="line">        <span class="comment">//objectname</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> mediaFiles.getFilePath();</span><br><span class="line">        <span class="comment">//如果数据库存在再查询 minio</span></span><br><span class="line">        <span class="type">GetObjectArgs</span> <span class="variable">getObjectArgs</span> <span class="operator">=</span> GetObjectArgs.builder()</span><br><span class="line">                .bucket(bucket)</span><br><span class="line">                .object(filePath)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//查询远程服务获取到一个流对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FilterInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> minioClient.getObject(getObjectArgs);</span><br><span class="line">            <span class="keyword">if</span>(inputStream!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//文件已存在</span></span><br><span class="line">                <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件不存在</span></span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）等到所有分块上传完毕，服务端合并所有分块，校验分块的完整性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkChunk</span><span class="params">(String fileMd5, <span class="type">int</span> chunkIndex)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据md5得到分块文件所在目录的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFileFolderPath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果数据库存在再查询 minio</span></span><br><span class="line">    <span class="type">GetObjectArgs</span> <span class="variable">getObjectArgs</span> <span class="operator">=</span> GetObjectArgs.builder()</span><br><span class="line">            .bucket(bucket_video)</span><br><span class="line">            .object(chunkFileFolderPath+chunkIndex)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">//查询远程服务获取到一个流对象</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FilterInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> minioClient.getObject(getObjectArgs);</span><br><span class="line">        <span class="keyword">if</span>(inputStream!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//文件已存在</span></span><br><span class="line">            <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件不存在</span></span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分块文件全都上传到了服务器，服务器按顺序进行合并，就是将每一个分块文件按照内容顺序一次写入一个文件中，使用字节流进行读文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">uploadChunk</span><span class="params">(String fileMd5, <span class="type">int</span> chunk, String localChunkFilePath)</span> &#123;</span><br><span class="line">    <span class="comment">//分块文件的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFilePath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5) + chunk;</span><br><span class="line">    <span class="comment">//获取mimeType</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> getMimeType(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//将分块文件上传到minio</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> addMediaFilesToMinIO(localChunkFilePath, mimeType, bucket_video, chunkFilePath);</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.validfail(<span class="literal">false</span>,<span class="string">&quot;上传分块文件失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上传成功</span></span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">mergechunks</span><span class="params">(Long companyId, String fileMd5, <span class="type">int</span> chunkTotal, UploadFileParamsDto uploadFileParamsDto)</span> &#123;</span><br><span class="line">        <span class="comment">//分块文件所在目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">chunkFileFolderPath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5);</span><br><span class="line">        <span class="comment">//找到所有的分块文件</span></span><br><span class="line">        List&lt;ComposeSource&gt; sources = Stream.iterate(<span class="number">0</span>, i -&gt; ++i).limit(chunkTotal).map(i -&gt; ComposeSource.builder().bucket(bucket_video).object(chunkFileFolderPath + i).build()).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">//源文件名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> uploadFileParamsDto.getFilename();</span><br><span class="line">        <span class="comment">//扩展名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> filename.substring(filename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="comment">//合并后文件的objectname</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> getFilePathByMd5(fileMd5, extension);</span><br><span class="line">        <span class="comment">//指定合并后的objectName等信息</span></span><br><span class="line">        <span class="type">ComposeObjectArgs</span> <span class="variable">composeObjectArgs</span> <span class="operator">=</span> ComposeObjectArgs.builder()</span><br><span class="line">                .bucket(bucket_video)</span><br><span class="line">                .object(objectName)<span class="comment">//合并后的文件的objectname</span></span><br><span class="line">                .sources(sources)<span class="comment">//指定源文件</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//===========合并文件============</span></span><br><span class="line">        <span class="comment">//报错size 1048576 must be greater than 5242880，minio默认的分块文件大小为5M</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            minioClient.composeObject(composeObjectArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">&quot;合并文件出错,bucket:&#123;&#125;,objectName:&#123;&#125;,错误信息:&#123;&#125;&quot;</span>,bucket_video,objectName,e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> RestResponse.validfail(<span class="literal">false</span>,<span class="string">&quot;合并文件异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//===========校验合并后的和源文件是否一致，视频上传才成功===========</span></span><br><span class="line">        <span class="comment">//先下载合并后的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> downloadFileFromMinIO(bucket_video, objectName);</span><br><span class="line">        <span class="comment">//文件大小</span></span><br><span class="line">        uploadFileParamsDto.setFileSize(file.length());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        try(FileInputStream fileInputStream = new FileInputStream(file))&#123;</span></span><br><span class="line"><span class="comment">//            //计算合并后文件的md5</span></span><br><span class="line"><span class="comment">//            String mergeFile_md5 = DigestUtils.md5Hex(fileInputStream);</span></span><br><span class="line"><span class="comment">//            //比较原始md5和合并后文件的md5</span></span><br><span class="line"><span class="comment">////            if(!fileMd5.equals(mergeFile_md5))&#123;</span></span><br><span class="line"><span class="comment">////                log.error(&quot;校验合并文件md5值不一致,原始文件:&#123;&#125;,合并文件:&#123;&#125;&quot;,fileMd5,mergeFile_md5);</span></span><br><span class="line"><span class="comment">////                return RestResponse.validfail(false,&quot;文件校验失败&quot;);</span></span><br><span class="line"><span class="comment">////            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">//            return RestResponse.validfail(false,&quot;文件校验失败&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//==============将文件信息入库============</span></span><br><span class="line">        <span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> currentProxy.addMediaFilesToDb(companyId, fileMd5, uploadFileParamsDto, bucket_video, objectName);</span><br><span class="line">        <span class="keyword">if</span>(mediaFiles == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> RestResponse.validfail(<span class="literal">false</span>,<span class="string">&quot;文件入库失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//==========清理分块文件=========</span></span><br><span class="line">        clearChunkFiles(chunkFileFolderPath,chunkTotal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>4）前端给服务端传了一个md5的值，服务端合并后计算MD5值是否与前端提供的相符，一样则说明文件完整，否则可能出现丢包等导致文件不完整。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取文件的md5</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getFileMd5</span><span class="params">(File file)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileMd5</span> <span class="operator">=</span> DigestUtils.md5Hex(fileInputStream);</span><br><span class="line">        <span class="keyword">return</span> fileMd5;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）分块文件清理问题</p>
<p>假如上传文件上传到一半，之前存储的minio文件需要清理吗？</p>
<p>1.在数据库中有一张文件记录表记录minio存储的文件信息</p>
<p>2.文件开始上传时会写入文件表，状态为上传中，当上传完毕在更新状态为上传完成</p>
<p>3.当文件没有完全上传成功，会有定时任务查询文件表中的记录，如果没有上传完成则删除minio没有上传成功的文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除分块文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkFileFolderPath 分块文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkTotal 分块文件总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clearChunkFiles</span><span class="params">(String chunkFileFolderPath,<span class="type">int</span> chunkTotal)</span>&#123;</span><br><span class="line">    Iterable&lt;DeleteObject&gt; objects =  Stream.iterate(<span class="number">0</span>, i -&gt; ++i).limit(chunkTotal).map(i -&gt; <span class="keyword">new</span> <span class="title class_">DeleteObject</span>(chunkFileFolderPath+ i)).collect(Collectors.toList());;</span><br><span class="line">    <span class="type">RemoveObjectsArgs</span> <span class="variable">removeObjectsArgs</span> <span class="operator">=</span> RemoveObjectsArgs.builder().bucket(bucket_video).objects(objects).build();</span><br><span class="line">    Iterable&lt;Result&lt;DeleteError&gt;&gt; results = minioClient.removeObjects(removeObjectsArgs);</span><br><span class="line">    <span class="comment">//要想真正删除</span></span><br><span class="line">    results.forEach(f-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DeleteError</span> <span class="variable">deleteError</span> <span class="operator">=</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-xxl-job"><a href="#8-xxl-job" class="headerlink" title="8.xxl -job"></a>8.xxl -job</h2><h3 id="8-1原理："><a href="#8-1原理：" class="headerlink" title="8.1原理："></a>8.1原理：</h3><p>xxl-job分布式任务调度服务由调用中心和执行器组成，调用中心负责按任务调度策略向执行器下发任务，执行器负责接收任务并执行。</p>
<p>1）部署并启动xxl-job调度中心（java工程）</p>
<p>2）在微服务添加xxl-job的依赖，在微服务中心配置服务器</p>
<p>3）启动微服务，执行器向调度中心上报自己</p>
<p>4）在微服务中写一个方法并用xxl-job的注解去标记执行任务的方法名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;videoJobHandler&quot;)</span></span><br></pre></td></tr></table></figure>

<p>5）调度中心配置任务调度策略</p>
<p>6）在xxl-job调度中心启动任务</p>
<p>7)调度中心根据任务调度策略，到达时间就开始下发任务给执行器</p>
<p>8）执行器收到任务就开始执行</p>
<h3 id="8-2如何保证任务不会重复执行"><a href="#8-2如何保证任务不会重复执行" class="headerlink" title="8.2如何保证任务不会重复执行"></a>8.2如何保证任务不会重复执行</h3><p>1）调度中心按分片广播的方式去下发任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、分片广播任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@XxlJob(&quot;shardingJobHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shardingJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分片参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();<span class="comment">//执行器的序号，从0开始</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();<span class="comment">//执行器总数</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;shardIndex=&quot;</span>+shardIndex+<span class="string">&quot;,shardTotal=&quot;</span>+shardTotal);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/xxl-job.png"></p>
<p>2）执行器收到作业分片广播的参数：分片总数和分片序号，计算 任务id &#x2F; 分片总数 得到一个余数，如果余数等于分片序号，当前执行器就去执行这个任务，这里保证了不同的执行器执行不同的任务。</p>
<p>例如：分片总数为2，分片序号0,1，2，3，两个任务，从任务1开始：假设当前执行器是2</p>
<p>1 % 2 &#x3D; 1 执行器2执行</p>
<p>2 % 2 &#x3D; 0 执行器1执行</p>
<p>3 % 2 &#x3D; 1 执行器2执行</p>
<p>3）配置调度过期策略为“忽略”，避免同一个执行器多次重复执行同一个任务。</p>
<p>4）配置任务阻塞处理策略为“丢弃后续调度”，注意：丢弃也没事，下次调度即可。</p>
<p>5）另外还要保证任务处理的幂等性，执行过的任务可以打上“已完成”的标记状态，下次再调度执行该任务判断任务状态确认是否已经完成。</p>
<p>我们在数据库视频处理表中添加处理状态的字段，视频处理完成更新状态为完成。下次执行该任务前先判断状态在决定是否执行该任务。</p>
<h3 id="8-3如何保证任务的幂等性"><a href="#8-3如何保证任务的幂等性" class="headerlink" title="8.3如何保证任务的幂等性"></a>8.3如何保证任务的幂等性</h3><p>幂等性：它描述了一次和多次请求某一个资源对于资源本身一个具有同样的结果。</p>
<p>幂等性是为了解决重复提交的问题，比如:恶意刷单，重复支付。</p>
<p>解决幂等性常用的方案：</p>
<p>1）数据库约束，比如：唯一索引，主键。同一个主键不可能两次插入成功。</p>
<p>2）唯一序列号,请求前生成唯一序列号，携带序列号去请求，执行时在redis记录该序列号，表示该序列号已经请求过了，如果请求携带的是redis中已经存有的序列号，说明该次请求是重复的。</p>
<p>3）乐观锁，常用于数据库，更新数据时根据乐观锁的状态去更新。</p>
<p>什么是乐观锁、悲观锁？synchronized是一种悲观锁，在执行被synchronized包裹的代码时需要首先获取锁，没有拿到锁则无法执行，是总悲观的认为别的线程会去抢，所以要悲观锁。乐观锁的思想是它不认为会有线程去争抢，尽管去执行，如果没有执行成功就再去重试。    </p>
<p>通常，它使用版本号或时间戳字段来检测并发修改，并确保在多个并发更新尝试中只有一个成功</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="keyword">UPDATE</span> media_process m</span><br><span class="line"><span class="keyword">SET</span> m.status<span class="operator">=</span><span class="string">&#x27;4&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> (m.status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">OR</span> m.status<span class="operator">=</span><span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> m.fail_count <span class="operator">&lt;</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">AND</span> m.id<span class="operator">=</span>?</span><br><span class="line"></span><br><span class="line"><span class="number">2</span><span class="keyword">UPDATE</span> media_process t</span><br><span class="line"><span class="keyword">SET</span> t.count <span class="operator">=</span> t.count <span class="operator">+</span> <span class="number">1</span>, t.version<span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="keyword">WHERE</span> t.version <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>1这个UPDATE语句将名为<code>media_process</code>的表中的记录的<code>status</code>字段设置为’4’，条件是当前<code>status</code>字段的值为’1’或’3’，<code>fail_count</code>字段的值小于3，且满足指定的<code>id</code>条件。这个操作将满足条件的记录的<code>status</code>字段更新为’4’，表示这些记录已经被处理。</p>
<p>2这个UPDATE语句将名为<code>media_process</code>的表中的记录的<code>count</code>字段递增1，同时将<code>version</code>字段更新为2，条件是当前<code>version</code>字段的值为1。这个操作通常用于对某些记录进行计数或标记，确保在并发情况下不会出现竞态条件</p>
<h2 id="9-分布式事务："><a href="#9-分布式事务：" class="headerlink" title="9.分布式事务："></a>9.分布式事务：</h2><h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>是在单一数据库或数据源上执行的事务操作，它具有ACID特性，适用于单一数据源的业务逻辑。</p>
<ol>
<li><strong>单一数据源</strong>：本地事务发生在单一的数据库或数据源上，所有的数据库操作都在同一个事务中进行。</li>
<li><strong>ACID特性</strong>：本地事务通常遵循ACID（原子性、一致性、隔离性和持久性）特性。这意味着事务要么完全成功，要么完全失败，并且在事务期间数据库保持一致性状态。</li>
<li><strong>事务管理</strong>：在本地事务中，通常需要事务管理器或编程框架（例如JDBC、Hibernate等）来管理事务的开始、提交、回滚和异常处理。</li>
<li><strong>锁定和隔离级别</strong>：本地事务中，可以使用锁定和隔离级别来控制并发访问数据库的方式，以确保事务的隔离性。</li>
<li><strong>性能和吞吐量</strong>：本地事务通常具有较高的性能和吞吐量，因为它们涉及的是单一数据源，没有涉及网络通信或多个系统之间的协调。</li>
<li><strong>适用性</strong>：本地事务适用于那些不需要跨多个数据源或数据库的业务逻辑，例如传统的单体应用程序。</li>
</ol>
<h3 id="分布式事务："><a href="#分布式事务：" class="headerlink" title="分布式事务："></a>分布式事务：</h3><p><img src="/img/fbs.png"></p>
<p>分布式事务是指涉及多个独立的数据源、系统或服务的事务操作。这些数据源、系统或服务可以位于不同的地理位置、运行在不同的计算机或容器中，可能使用不同的技术栈和编程语言。分布式事务的目标是确保在分布式环境下的多个操作能够以事务的方式一起成功或失败，以维护数据的一致性和可靠性。</p>
<ol>
<li><strong>多个参与者</strong>：分布式事务通常涉及多个事务参与者，每个参与者负责管理自己的数据源或系统。</li>
<li><strong>全局事务协调器</strong>：在分布式事务中，需要有一个全局事务协调器（也称为事务管理器或协调者），它负责协调各个参与者的事务操作，确保它们的状态一致。</li>
<li><strong>事务的隔离性</strong>：与本地事务一样，分布式事务也需要遵循ACID特性，包括事务的隔离性，以确保数据一致性。</li>
<li><strong>事务的提交和回滚</strong>：全局事务协调器负责决定是否提交或回滚整个分布式事务，这意味着所有参与者要么都提交成功，要么都回滚失败。</li>
<li><strong>两阶段提交（2PC）</strong>：2PC是一种常见的分布式事务协议，它包括两个阶段：准备阶段（协调者询问参与者是否可以提交事务）和提交阶段（如果准备阶段成功，则协调者通知所有参与者提交事务）。</li>
<li><strong>补偿事务</strong>：在分布式环境中，由于网络故障或参与者故障，可能会发生部分参与者已经提交而另一部分参与者未提交的情况。为了处理这种情况，可以使用补偿事务来回滚已经提交的部分。</li>
<li><strong>幂等性</strong>：为了确保分布式事务的幂等性，操作必须能够多次执行而不会产生不一致的结果。这对于处理重试和失败恢复非常重要。</li>
<li><strong>分布式事务模型</strong>：不同的分布式事务模型（例如XA事务、TCC事务、SAGA事务等）提供不同的机制和适用性，可以根据业务需求选择合适的模型。</li>
<li><strong>性能和复杂性权衡</strong>：分布式事务通常比本地事务更复杂，因为需要处理网络通信、故障恢复和协调多个参与者。因此，需要权衡性能和复杂性</li>
</ol>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p> CAP 定理，CAP 是 Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容忍性）的缩写，</p>
<ol>
<li><strong>一致性（Consistency）</strong>：所有节点在同一时间点看到相同的数据视图。这意味着无论在哪个节点上进行读取操作，都应该获得最新的数据，并且写入操作应该立即反映在所有节点上。</li>
<li><strong>可用性（Availability）</strong>：每个请求都必须得到响应，无论它是否成功。即使系统的一部分节点故障，仍然需要继续提供服务。</li>
<li><strong>分区容忍性（Partition tolerance）</strong>：系统可以在网络分区或节点故障的情况下继续工作。分区容忍性意味着系统的某些部分无法与其他部分通信，但仍然可以继续运行。</li>
</ol>
<p>只能满足AP或CP</p>
<ol>
<li><p><strong>CP（一致性和分区容忍性）</strong>：如果系统选择了 CP，这意味着在面临网络分区时，系统会牺牲可用性以保持数据的一致性。这意味着系统可能在分区发生时停止接受新的请求，以确保数据的一致性。</p>
<p><em><strong>例如 ： 银行转账，开户操作</strong></em></p>
</li>
<li><p><strong>AP（可用性和分区容忍性）</strong>：如果系统选择了 AP，这意味着在面临网络分区时，系统会牺牲一致性以保持可用性。这意味着系统可能在分区发生时继续提供服务，但数据可能会处于不一致状态，直到分区恢复。</p>
</li>
</ol>
<p>​		<em><strong>例如：订单退款，注册送积分，支付短信通知</strong></em></p>
<h3 id="BASE理论："><a href="#BASE理论：" class="headerlink" title="BASE理论："></a>BASE理论：</h3><p>BASE 是一个分布式系统的理论模型，与 ACID（原子性、一致性、隔离性和持久性）相对立。</p>
<ol>
<li><strong>基本可用性（Basic Availability）</strong>：BASE 要求系统在面临故障或分区的情况下仍然能够保持基本的可用性。这意味着系统在一些部分或节点出现故障时，仍然可以继续提供有限的服务。</li>
<li><strong>软状态（Soft State）</strong>：BASE 接受系统在某一时刻的状态可能是不一致的，也就是说，在分布式系统中，一些数据的状态可能因为数据同步延迟或其他原因而有所不同。</li>
<li><strong>最终一致性（Eventually Consistency）</strong>：BASE 强调系统的一致性是最终达到的，而不需要实时保持一致。分布式系统可以在一段时间内处于不一致状态，但最终会收敛到一致状态。</li>
</ol>
<h3 id="分布式事务控制有哪些常用的方式："><a href="#分布式事务控制有哪些常用的方式：" class="headerlink" title="分布式事务控制有哪些常用的方式："></a>分布式事务控制有哪些常用的方式：</h3><ol>
<li><p><strong>实现CP - 一致性和分区容忍性</strong>：</p>
<p>a. <strong>Seata框架基于AT模式实现</strong>：</p>
<ul>
<li>Seata 是一个开源的分布式事务框架，支持多种事务模式，包括AT（原子性事务）。使用AT模式，Seata能够协调多个参与者，以实现分布式事务的一致性和分区容忍性。</li>
<li>AT模式基于两阶段提交（2PC）协议，确保在所有参与者上的操作要么全部提交成功，要么全部回滚失败。这可以实现强一致性。</li>
</ul>
<p>b. <strong>Seata框架基于TCC模式实现</strong>：</p>
<ul>
<li>除了AT模式，Seata还支持TCC（Try-Confirm-Cancel）模式，它通过预备、确认和取消三个阶段来实现分布式事务。TCC模式可以提供更大的灵活性和定制化，以满足特定的业务需求。</li>
</ul>
</li>
<li><p><strong>实现AP - 最终数据一致性</strong>：</p>
<p>a. <strong>使用消息队列通知的方式</strong>：</p>
<ul>
<li>在分布式系统中，可以使用消息队列来实现最终一致性。当需要跨多个数据存储或服务时，将数据更改的通知发布到消息队列，其他系统可以订阅这些通知并在本地进行处理。</li>
<li>为了实现可用性，可以配置消息队列以自动重试通知，直到达到最大失败次数。如果通知在一段时间内无法成功传递，可以进行人工处理。</li>
</ul>
<p>b. <strong>使用任务调度的方案</strong>：</p>
<ul>
<li>另一种实现最终一致性的方法是使用任务调度。例如，定期启动任务调度来将数据从一个数据库同步到其他数据存储或服务，以确保数据一致性。</li>
<li>这种方式通常需要开发者编写和管理同步任务，确保数据按计划同步。</li>
</ul>
</li>
</ol>
<p><img src="/img/fbs1.png"></p>
<p>本地消息表（mq_message表）+任务调度的机制</p>
<p><img src="/img/fbs2.png"></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>rk</title>
    <url>/2023/09/08/rk/</url>
    <content><![CDATA[<p>按照题型分类补充一些知识点：</p>
]]></content>
      <categories>
        <category>rk</category>
      </categories>
      <tags>
        <tag>rk</tag>
      </tags>
  </entry>
  <entry>
    <title>xc-plus-project</title>
    <url>/2023/09/07/xc-plus-project/</url>
    <content><![CDATA[<h1 id="技术架构："><a href="#技术架构：" class="headerlink" title="技术架构："></a>技术架构：</h1><p>1.VMwarepro 虚拟机</p>
<p>充当云服务器，docker 中开启 nacos，xxl-job，minio，redis，elsticsearch，kibana，gogs,rabbitmq,mysql服务，xshell远程连接，Navicat开启数据库。<br>2.前端静态页面存在D:&#x2F;&#x2F;JAVA&#x2F;xc-res&#x2F;中，修改相关内容即可。还有一个前端工程，Vue编写的。<br>3.后端代码存在ideacode中，分每个微服务来写。<br>4.nacos是每个微服务的配置，xx-dev.yml文件，服务启动后会显示<br>5.xxl-job是分布式任务的处理，视频的处理，和课程的发布。分布式任务显示<br>6.minio存储需要的media和video，相当于一个数据库，存储文件，<br>7.e&amp;k,索引，搜索，把数据库表中的字段和值，通过映射到e&amp;k中，用于网页的索引和搜索。<br>8.gogs实现git代码的管理，每天一次commit到本地和push到远程。<br>9.redis存储本地的验证码，登录账户密码，图片验证码</p>
<p>11.rabbitmq消息队列，处理每个任务之间的逻辑，当前一个任务完成的时候，在队列中通知下一个任务的可以进行</p>
<p>10.在前端修改上传文件的大小和浏览器设置上传文件的服务器设置</p>
<p>11代理对象，事务控制(事务优化，代理对象处理事务需要在方法上添加@Transaction注解)</p>
<h1 id="详细技术介绍："><a href="#详细技术介绍：" class="headerlink" title="详细技术介绍："></a>详细技术介绍：</h1><h2 id="0-gogs"><a href="#0-gogs" class="headerlink" title="0 gogs"></a>0 gogs</h2><p>相当于git,Gogs是一个简单而功能齐全的自托管Git服务，适用于小型团队和个人开发者，帮助他们管理和协作开发代码项目。</p>
<ol>
<li><strong>轻量级和易于安装</strong>：Gogs以轻量级和快速部署为设计目标，可以在各种操作系统上安装和运行，包括Linux、Windows、macOS等。</li>
<li><strong>自托管</strong>：您可以在自己的服务器上搭建Gogs，完全掌握代码托管的控制权，而无需依赖第三方服务。</li>
<li><strong>Web界面</strong>：Gogs提供了一个直观的Web界面，允许用户创建和管理Git仓库、查看提交历史、管理问题和PR、设置Web钩子等。</li>
<li><strong>多用户支持</strong>：Gogs支持多用户和组织，可以创建和管理不同用户的账户，进行协作开发。</li>
<li><strong>Web钩子和集成</strong>：Gogs支持Web钩子，可以与CI&#x2F;CD工具、问题跟踪系统和通知服务集成，实现自动化和通知。</li>
<li><strong>访问控制</strong>：Gogs提供了丰富的访问控制选项，包括仓库级别和组织级别的权限管理，以确保代码的安全性和隐私性。</li>
<li><strong>问题跟踪和PR</strong>：Gogs具有内置的问题跟踪系统和Pull Request（PR）功能，方便团队协作和代码审查。</li>
<li><strong>自动备份和迁移</strong>：Gogs支持自动备份和迁移，确保代码不会丢失。</li>
<li><strong>多语言支持</strong>：Gogs支持多种语言，包括英语、中文、日语等，以满足全球用户的需求。</li>
</ol>
<h2 id="1swagger-ui"><a href="#1swagger-ui" class="headerlink" title="1swagger-ui"></a>1swagger-ui</h2><p>Swagger UI 使 API 开发变得更加高效和可视化，同时提供了强大的工具来创建、测试和文档化 RESTful API。它已经成为了许多开发者和团队在构建和维护 API 时的首选工具之一。通过提供可视化的 API 文档和测试界面，Swagger UI 提高了 API 的可用性和可维护性。</p>
<ol>
<li><strong>自动生成文档</strong>：Swagger UI 可以自动从 API 的注释、注解和代码中生成 API 文档。开发者无需手动编写文档，只需在代码中添加适当的注释和注解。</li>
<li><strong>交互式界面</strong>：Swagger UI 提供了一个交互式的 Web 界面，允许开发者浏览 API 的端点、请求参数、响应数据等信息。这有助于更好地理解和测试 API。</li>
<li><strong>支持多种编程语言</strong>：Swagger UI 支持多种编程语言和框架，包括 Java、Python、Node.js、Ruby 等。这意味着您可以在不同的编程环境中使用 Swagger UI。</li>
<li><strong>在线 API 测试</strong>：Swagger UI 允许开发者在界面中直接测试 API 端点，输入参数并查看响应，以确保 API 正确工作。</li>
<li><strong>生成客户端代码</strong>：Swagger UI 可以生成用于调用 API 的客户端代码，这些客户端代码可以用于不同编程语言，帮助开发者更轻松地与 API 进行交互。</li>
<li><strong>可自定义</strong>：Swagger UI 具有可自定义的界面，您可以根据自己的需求进行样式和布局的调整，以适应项目的设计风格。</li>
<li><strong>整合现有项目</strong>：您可以将 Swagger UI 集成到现有的 Web 项目中，以提供 API 文档和测试的功能。</li>
<li><strong>安全性</strong>：Swagger UI 支持 API 安全性的设置和测试，可以模拟授权和认证过程。</li>
</ol>
<h2 id="2nacos-Ali"><a href="#2nacos-Ali" class="headerlink" title="2nacos(Ali)"></a>2nacos(Ali)</h2><p>​	Nacos 是一个功能强大的分布式配置和服务发现系统，适用于构建和管理微服务架构的应用程序</p>
<ol>
<li><strong>配置管理</strong>：Nacos 允许开发者集中管理配置，包括应用程序的配置文件、环境变量、数据库连接等。配置可以动态刷新，无需重启应用程序。</li>
<li><strong>服务发现</strong>：Nacos 提供了服务注册和发现功能，使微服务之间可以轻松地发现和通信。它支持多种负载均衡算法。</li>
<li><strong>动态DNS</strong>：Nacos 支持动态DNS，允许为服务分配动态的域名和IP地址。</li>
<li><strong>多环境支持</strong>：Nacos 支持多个环境（如开发、测试、生产）的配置管理，可以在不同环境中使用不同的配置。</li>
<li><strong>分布式存储</strong>：Nacos 使用分布式存储来保证高可用性和数据的一致性，支持多种存储后端，包括MySQL、Redis等。</li>
<li><strong>健康检查</strong>：Nacos 提供了健康检查机制，允许检测服务的健康状态并自动剔除不健康的实例。</li>
<li><strong>灰度发布</strong>：Nacos 支持灰度发布，允许逐步将新版本的服务引入生产环境，减小风险。</li>
<li><strong>多语言支持</strong>：Nacos 提供多种编程语言的客户端 SDK，可以与多种编程语言的应用程序集成。</li>
<li><strong>集成Spring Cloud</strong>：Nacos 可以与Spring Cloud框架集成，使得在微服务架构中更容易实现配置管理和服务发现。</li>
</ol>
<h2 id="3minio"><a href="#3minio" class="headerlink" title="3minio"></a>3minio</h2><p>MinIO 是一个开源的对象存储服务器，用于存储和管理大规模的数据，通常被用于构建分布式存储、备份和数据湖等应用。</p>
<ol>
<li><strong>开源和免费</strong>：MinIO 是一个完全开源的项目，使用Apache License 2.0许可，允许您免费使用、修改和分发它。</li>
<li><strong>对象存储</strong>：MinIO 提供了对象存储的功能，您可以将数据以对象的形式存储在 MinIO 中，并使用唯一的键来检索它们。</li>
<li><strong>高性能</strong>：MinIO 被设计成高性能的存储系统，可以处理大规模的数据并提供低延迟的读写操作。</li>
<li><strong>可扩展性</strong>：MinIO 可以轻松地水平扩展，以应对不断增长的存储需求。您可以添加新的MinIO实例，构建集群来实现高可用性和负载均衡。</li>
<li><strong>S3兼容</strong>：MinIO 提供了与Amazon S3兼容的API，这意味着您可以使用现有的S3客户端和工具与MinIO进行交互，而无需修改代码。</li>
<li><strong>安全性</strong>：MinIO 提供了数据加密、访问控制、身份验证和安全传输等安全特性，以确保您的数据安全。</li>
<li><strong>版本控制</strong>：MinIO 具备版本控制的功能，允许您保留和管理多个对象版本，以便回溯或还原数据。</li>
<li><strong>分布式存储</strong>：MinIO 支持分布式存储，可以将数据分散存储在多个地点，以提高可用性和数据冗余。</li>
<li><strong>容器化部署</strong>：MinIO 可以轻松部署到容器化环境中，例如Kubernetes，以便在容器编排平台上管理和扩展。</li>
<li><strong>监控和日志</strong>：MinIO 提供了监控和日志记录功能，可以用于监视存储使用情况和性能，并进行故障排除。</li>
</ol>
<h2 id="5xxl-job-ALi"><a href="#5xxl-job-ALi" class="headerlink" title="5xxl-job(ALi)"></a>5xxl-job(ALi)</h2><p>XXL-Job 是一个非常有用的任务调度平台，特别适用于需要管理和调度大量定时任务的场景，如数据处理、数据导入、定时报表生成等。</p>
<ol>
<li><strong>分布式任务调度</strong>：XXL-Job 可以在多台服务器上分布式执行定时任务，确保任务的高可用性和负载均衡。</li>
<li><strong>多语言支持</strong>：支持多种编程语言（如Java、Python、Shell等）编写任务执行器，使用户能够使用不同的编程语言编写任务逻辑。</li>
<li><strong>任务调度管理</strong>：XXL-Job 提供了任务调度管理的功能，包括任务新增、编辑、删除、暂停、恢复等。</li>
<li><strong>任务依赖</strong>：支持任务之间的依赖关系，可以配置任务的执行顺序和触发条件。</li>
<li><strong>分片执行</strong>：任务可以分片执行，每个分片可以在不同的执行器上并行执行，提高任务执行效率。</li>
<li><strong>任务日志和监控</strong>：XXL-Job 提供了任务执行日志记录和监控功能，可以查看任务的执行日志和状态。</li>
<li><strong>动态参数</strong>：支持动态参数传递，任务执行时可以动态传递参数，提高任务的通用性。</li>
<li><strong>报警机制</strong>：XXL-Job 支持任务执行失败时的报警通知，可以配置邮件报警、钉钉报警等。</li>
<li><strong>定时任务</strong>：支持定时任务的配置，可以按照固定的时间点触发任务执行。</li>
<li><strong>API接口</strong>：提供了API接口，可以与其他系统集成，实现任务的自动化管理和调度。</li>
<li><strong>任务执行日志</strong>：任务执行后，可以查看任务的详细执行日志，有助于故障排查和任务监控。</li>
<li><strong>分布式调度中心</strong>：支持将任务调度中心部署在多个节点，以实现高可用性和负载均衡。</li>
</ol>
<h2 id="6nginx"><a href="#6nginx" class="headerlink" title="6nginx:"></a>6nginx:</h2><p>Nginx（发音为 “engine x”）是一个高性能的开源Web服务器，也可以用作反向代理服务器、负载均衡器和HTTP缓存服务器。</p>
<p>网页前端页面，部署网页的位置，config文件，配置网页，拿图片，视频</p>
<ol>
<li><strong>高性能</strong>：Nginx 是为高并发和高负载设计的，能够处理数千个并发连接而不会过度消耗系统资源。</li>
<li><strong>反向代理</strong>：Nginx 可以用作反向代理服务器，将客户端的请求代理到后端服务器，以实现负载均衡、安全性和性能优化。</li>
<li><strong>负载均衡</strong>：Nginx 支持负载均衡，可以将请求分发到多个后端服务器，提高系统的可用性和性能。</li>
<li><strong>静态文件服务</strong>：Nginx 可以高效地提供静态文件服务，例如HTML、CSS、JavaScript、图像等，从而减轻后端服务器的负担。</li>
<li><strong>HTTP缓存</strong>：Nginx 具有内置的HTTP缓存支持，可以缓存静态和动态内容，提高响应速度。</li>
<li><strong>SSL&#x2F;TLS支持</strong>：Nginx 支持SSL&#x2F;TLS加密，可以保护数据传输的安全性，用于HTTPS协议。</li>
<li><strong>虚拟主机</strong>：Nginx 支持虚拟主机配置，允许在同一服务器上托管多个域名或应用程序。</li>
<li><strong>模块化架构</strong>：Nginx 的模块化架构使得可以根据需求添加各种功能和扩展，以满足不同场景的需求。</li>
<li><strong>动态模块加载</strong>：Nginx 支持动态模块加载，可以在运行时加载或卸载模块，无需重新编译和部署。</li>
<li><strong>日志记录</strong>：Nginx 提供强大的日志记录功能，可以记录访问日志、错误日志等，有助于监控和故障排查。</li>
<li><strong>反爬虫和安全性</strong>：Nginx 可以配置反爬虫规则、访问控制、DDoS防护等安全性功能。</li>
<li><strong>可扩展性</strong>：Nginx 可以与其他服务和技术集成，如FastCGI、uWSGI、PHP-FPM等，以构建复杂的Web应用和微服务架构。</li>
</ol>
<h2 id="7freemarker"><a href="#7freemarker" class="headerlink" title="7freemarker:"></a>7freemarker:</h2><p>FreeMarker（全名 “FreeMarker Template Engine”）是一个开源的模板引擎，用于生成动态文本输出，通常用于在Web应用程序中生成HTML、XML、JSON等格式的内容。</p>
<ol>
<li><p><strong>模板引擎</strong>：FreeMarker 是一个模板引擎，允许开发者将静态模板和动态数据结合起来生成动态内容。</p>
</li>
<li><p><strong>模板语言</strong>：FreeMarker 提供了一种简单而强大的模板语言，支持条件语句、循环、变量定义、宏等功能，以便更好地控制模板生成的内容。</p>
</li>
<li><p><strong>分离视图和数据</strong>：FreeMarker 鼓励将视图（模板）和数据（模型）分离，以提高代码的可维护性和可重用性。</p>
</li>
<li><p><strong>强大的表达式</strong>：FreeMarker 支持表达式，可以进行各种操作，如字符串拼接、数学运算、日期格式化等。</p>
</li>
<li><p><strong>多用途</strong>：FreeMarker 不仅可以用于生成HTML页面，还可以用于生成XML文档、JSON数据、配置文件等各种类型的文本输出。</p>
</li>
<li><p><strong>可扩展性</strong>：FreeMarker 是可扩展的，允许开发者编写自定义指令和函数，以适应不同的需求。</p>
</li>
<li><p><strong>跨平台</strong>：由于FreeMarker是Java编写的，因此可以在各种操作系统上运行，并且易于与Java应用程序集成。</p>
</li>
<li><p><strong>开源</strong>：FreeMarker 是一个开源项目，使用Apache License 2.0许可，可以免费使用和修改。</p>
</li>
<li><p><strong>模板缓存</strong>：FreeMarker 支持模板缓存，可以提高模板渲染的性能，避免每次请求都重新解析模板。</p>
</li>
<li><p><strong>国际化支持</strong>：FreeMarker 支持国际化和本地化，可以轻松处理多语言和不同地区的内容生成。</p>
<p><img src="/img/free.png"></p>
<p>我有一个静态化页面的模版，course_template.ftl  每次生成页面都会根据这模版来生成，动态模板拿数据，从数据库拿数据展示到网页<a href="http://freemarker.foofun.cn/ref_directives.html">http://freemarker.foofun.cn/ref_directives.html</a></p>
<p>课程预览的时候会提前在缓存中加载好静态化的页面模版，每次新的课程生成新的页面时，会动态拿一些数据再结合静态化模版生成新的页面</p>
<p>course_template.ftl.：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;banner-left&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>$&#123;model.courseBase.mtName&#125;<span class="tag">&lt;<span class="name">span</span>&gt;</span>\ $&#123;model.courseBase.stName&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;tit&quot;</span>&gt;</span>$&#123;model.courseBase.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span>&gt;</span></span><br><span class="line">        &lt;#if model.courseBase.charge==&#x27;201000&#x27;&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;new-pic&quot;</span>&gt;</span>免费<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        &lt;#else&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;new-pic&quot;</span>&gt;</span>特惠价格￥$&#123;model.courseBase.price!&#x27;&#x27;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;old-pic&quot;</span>&gt;</span>原价￥$&#123;model.courseBase.originalPrice!&#x27;&#x27;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//课程预览</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/coursepreview/&#123;courseId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">preview</span><span class="params">(<span class="meta">@PathVariable(&quot;courseId&quot;)</span> Long courseId)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">//查询课程的信息作为模型数据</span></span><br><span class="line">    <span class="type">CoursePreviewDto</span> <span class="variable">coursePreviewInfo</span> <span class="operator">=</span> coursePublishService.getCoursePreviewInfo(courseId);</span><br><span class="line">    <span class="comment">//指定模型</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;model&quot;</span>, coursePreviewInfo);</span><br><span class="line">    <span class="comment">//指定模板</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;course_template&quot;</span>);<span class="comment">//根据视图名称加.ftl找到模板</span></span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="8feign"><a href="#8feign" class="headerlink" title="8feign"></a>8feign</h2><p>在一个微服务中调用另一个微服务，并使用 Feign 进行远程连接，同时使用 FreeMarker 进行动态化结合静态化模板生成页面是一种常见的微服务架构和页面生成方式。<br>Feign 是一个在 Spring Cloud 生态系统中广泛使用的声明式 HTTP 客户端库。</p>
<p>Feign 是一个非常方便的工具，特别适用于构建微服务架构中的服务间通信。如果您需要在 Spring Cloud 中实现服务之间的通信</p>
<p>远程调用@JsonFormat(shape &#x3D; JsonFormat.Shape.STRING,pattern &#x3D; “yyyy-MM-dd HH:mm:ss”)</p>
<p>以下是 Feign 的一些关键特点和用途：</p>
<ol>
<li><strong>声明式 API 定义</strong>：Feign 允许开发者使用注解方式定义和描述 HTTP 请求。这使得创建和维护 API 定义变得非常直观和易于理解。</li>
<li><strong>集成 Spring Cloud</strong>：Feign 是 Spring Cloud 中的一部分，与其他 Spring Cloud 组件（如Eureka、Ribbon等）集成得非常好，可以轻松实现负载均衡、服务注册和发现等功能。</li>
<li><strong>自动编码和解码</strong>：Feign 自动处理请求和响应的编码和解码，开发者无需手动进行序列化和反序列化操作。</li>
<li><strong>拦截器支持</strong>：Feign 提供了拦截器机制，允许开发者在请求发送和响应接收的过程中执行自定义逻辑，例如添加认证信息、记录请求日志等。</li>
<li><strong>动态代理</strong>：Feign 使用动态代理生成客户端代码，从而使得远程服务调用看起来像本地方法调用。这种透明性极大地简化了代码的编写和维护。</li>
<li><strong>多种 HTTP 方法支持</strong>：Feign 支持常见的 HTTP 请求方法，包括 GET、POST、PUT、DELETE 等，开发者可以根据需要选择合适的方法来调用远程服务。</li>
<li><strong>错误处理</strong>：Feign 提供了丰富的错误处理机制，可以捕获和处理远程服务调用中的异常情况。</li>
<li><strong>可扩展性</strong>：Feign 可以通过编写自定义组件和配置来满足更复杂的需求，例如自定义负载均衡策略、连接池配置等。</li>
</ol>
<h2 id="9elasticsearch"><a href="#9elasticsearch" class="headerlink" title="9elasticsearch"></a>9elasticsearch</h2><p>作为索引及搜索服务。kibana 是 ELK（Elasticsearch , Logstash, Kibana ）之一，kibana 一款开源的数据分析和可视化平台，通过可视化界面访问elasticsearch的索引库，并可以生成一个数据报表。开发中主要使用kibana通过api对elasticsearch进行索引和搜索操作，<em>docker-compose up：安装docker-compose.yml中的配置启动kibana和ela</em></p>
<ol>
<li><strong>全文搜索</strong>：Elasticsearch 是一个强大的全文搜索引擎，可以轻松地索引和搜索文本数据，支持复杂的查询、过滤和排序。</li>
<li><strong>分布式性能</strong>：Elasticsearch 可以轻松水平扩展，将数据和负载分布到多个节点上，从而实现高性能和高可用性。它使用分片和复制机制来处理数据的分布和冗余。</li>
<li><strong>实时数据</strong>：Elasticsearch 是实时的，可以在数据被索引后几乎立即进行搜索和分析。这使得它非常适合处理实时日志、监控数据和事件流等数据源。</li>
<li><strong>多样化的数据支持</strong>：除了文本数据，Elasticsearch 还支持结构化数据、地理空间数据、数值数据等多种数据类型。它可以作为一个通用的数据存储和检索引擎。</li>
<li><strong>复杂查询和聚合</strong>：Elasticsearch 支持复杂的查询和聚合操作，包括范围查询、模糊查询、多字段搜索、聚合统计等。这使得它非常适合用于数据分析和报告生成。</li>
<li><strong>开源生态系统</strong>：Elasticsearch 是开源的，并且有一个庞大的生态系统，包括插件、工具和库，可以用于扩展其功能和集成到各种应用程序中。</li>
<li><strong>可视化工具</strong>：Elasticsearch 配合 Kibana 可以提供可视化的数据仪表板，用于监控、分析和可视化数据。</li>
<li><strong>安全性</strong>：Elasticsearch 提供了安全性功能，可以控制访问、认证和授权，以确保数据的安全性。</li>
</ol>
<h2 id="10redis"><a href="#10redis" class="headerlink" title="10redis"></a>10redis</h2><p>存储验证码调用redis需要再bootstrap.yml文件中调用nacos中的配置，还有pom.xml文件中引入相关的依赖。</p>
<h2 id="11rabbitmq"><a href="#11rabbitmq" class="headerlink" title="11rabbitmq"></a>11rabbitmq</h2><p>RabbitMQ 是一个开源的消息队列中间件，用于在分布式系统中传递和存储消息。它是一种高度可靠的消息代理，广泛用于构建分布式、可扩展和高可用性的应用程序。</p>
<ol>
<li><p><strong>消息队列</strong>：RabbitMQ 是一个消息队列中间件，用于将消息从一个发送者传递到一个或多个接收者。这种异步消息传递模型有助于解耦应用程序的不同部分，提高了应用程序的可维护性和可扩展性。</p>
</li>
<li><p><strong>支持多种消息协议</strong>：RabbitMQ 支持多种消息协议，包括AMQP（高级消息队列协议）、STOMP、MQTT 等，使得它能够与多种编程语言和应用程序集成。</p>
</li>
<li><p><strong>可靠性</strong>：RabbitMQ 提供了持久性消息、确认机制、事务等功能，确保消息的可靠传递和处理。即使在系统故障后，也可以确保不会丢失消息。</p>
</li>
<li><p><strong>多种消息交换模式</strong>：RabbitMQ 支持多种消息交换模式，包括直连交换、主题交换、扇出交换等，这些模式允许不同类型的消息路由和分发。</p>
</li>
<li><p><strong>灵活的消息路由</strong>：RabbitMQ 具有强大的路由功能，可以根据消息的内容、标签或其他属性将消息路由到指定的队列，从而实现消息的精确控制和分发。</p>
</li>
<li><p><strong>可扩展性</strong>：RabbitMQ 可以轻松水平扩展，通过添加更多的节点和队列来增加处理能力和容量。它还支持集群和镜像队列，以提高可用性。</p>
</li>
<li><p><strong>管理界面</strong>：RabbitMQ 提供了一个易于使用的管理界面，允许管理员监控和管理消息队列、队列和交换机的状态和配置。</p>
</li>
<li><p><strong>广泛的应用场景</strong>：RabbitMQ 适用于多种应用场景，包括异步任务处理、事件驱动架构、日志和监控数据传输、微服务通信、电子商务订单处理等。</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>+————–+        +————–+        +————–+<br>|  Producer   |  –&gt;   |  Exchange    |  –&gt;   |  Queue       |  –&gt;   |  Consumer   |<br>+————–+        +————–+        +————–+<br>|  发送消息   |        |  消息路由   |        |  存储消息   |        |  处理消息   |<br>+————–+        +————–+        +————–+</p>
</li>
<li><p>生产者发送消息到 Exchange</p>
</li>
<li><p>Exchange 根据路由规则将消息路由到一个或多个队列</p>
</li>
<li><p>队列存储消息等待消费</p>
</li>
<li><p>消费者获取队列中的消息并处理</p>
<p><strong>18：消息队列</strong></p>
<p>处理支付完成之后的插入课程表。<a href="http://192.168.101.65:15672/#/exchanges%E7%94%9F%E4%BA%A7%E6%96%B9%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5%E5%88%B0%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%80%9A%E8%BF%87%E5%B9%BF%E6%92%AD%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%91%E9%80%81%E7%BB%99%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E6%B6%88%E8%B4%B9%E6%96%B9%E9%80%9A%E8%BF%87%E7%9B%91%E5%90%AC%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BF%A1%E6%81%AF%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82">http://192.168.101.65:15672/#/exchanges生产方发送通知到交换机，交换机通过广播的方式发送给消息队列，消费方通过监听消息队列的信息进行相应的操作。</a></p>
<p>rabbitMq，消息持久化，交换机持久化。</p>
<p>PayNotifyconfig配置 生产端：orders服务，消费端：learning（创建交换机和队列，队列绑定交换机）发送：消息发送到交换机，删除数据库中的消息。发送失败则向数据库中callback插入消息。接受：监听消息队列发送的消息。进行数据的处理，插表改状态等操作。</p>
</li>
</ol>
<h2 id="12-canal"><a href="#12-canal" class="headerlink" title="12 canal"></a>12 canal</h2><p> 数据实时同步：即改动数据库需要像mysql,elasticsearch等实时更新，采用binary log 的方法，[ mysql() – binary log ]  –&gt; canal -&gt; ela </p>
<h2 id="14spring-cloud："><a href="#14spring-cloud：" class="headerlink" title="14spring cloud："></a>14spring cloud：</h2><p>Spring Cloud是一个用于构建分布式系统和微服务架构的开源框架，它基于Spring Boot构建，提供了一系列工具和库，用于快速开发和部署分布式应用程序。Spring Cloud使开发人员能够轻松处理分布式系统中的常见问题，如配置管理、服务发现、负载均衡、断路器、分布式数据、消息传递等。</p>
<ol>
<li><p><strong>服务注册与发现</strong>：Spring Cloud提供了服务注册与发现机制，使微服务能够自动注册和发现其他微服务。Eureka和Consul是常见的服务注册与发现组件。</p>
</li>
<li><p><strong>负载均衡</strong>：Spring Cloud支持负载均衡，可以在多个实例之间分发请求，提高系统的性能和可用性。Ribbon是用于负载均衡的组件。</p>
</li>
<li><p><strong>断路器</strong>：Spring Cloud提供了断路器模式，可以防止故障的微服务影响整个系统。Hystrix是一个常用的断路器库。</p>
</li>
<li><p><strong>配置管理</strong>：Spring Cloud Config允许将配置中心化管理，实现配置的集中存储和动态刷新。</p>
</li>
<li><p><strong>API网关</strong>：Spring Cloud Gateway和Zuul是用于构建API网关的组件，用于处理请求路由、认证、授权、日志记录等功能。</p>
</li>
<li><p><strong>分布式消息传递</strong>：Spring Cloud Stream和Apache Kafka等允许微服务之间进行异步通信，以支持事件驱动架构。</p>
</li>
<li><p><strong>分布式追踪和监控</strong>：Spring Cloud Sleuth和Zipkin等工具用于分布式系统的追踪和监控，帮助诊断性能问题。</p>
</li>
<li><p><strong>批处理和任务调度</strong>：Spring Cloud Data Flow和Spring Cloud Task支持批处理和任务调度。</p>
</li>
<li><p><strong>安全性</strong>：Spring Cloud Security提供了安全性和认证授权的功能，可以用于保护微服务和API。</p>
</li>
<li><p><strong>分布式数据存储</strong>：Spring Cloud提供了对分布式数据存储的支持，如Spring Cloud Data Redis和Spring Cloud Data MongoDB。</p>
<h3 id="FeignClient"><a href="#FeignClient" class="headerlink" title="@FeignClient"></a>@FeignClient</h3><p><code>@FeignClient</code> 是 Spring Cloud 中的一个注解，用于创建基于声明式 REST 客户端。通过 <code>@FeignClient</code> 注解，您可以声明一个接口，该接口将自动映射到远程的 HTTP 服务端点，从而使您能够以面向接口的方式调用远程服务，而不需要编写具体的 HTTP 请求代码。</p>
<ul>
<li><p><strong>用途</strong>：<code>@FeignClient</code> 主要用于微服务架构中，用于简化服务间通信。它允许您定义接口，这些接口映射到远程服务的 API 端点，然后通过调用接口的方法来发起 HTTP 请求。</p>
</li>
<li><p><strong>属性</strong>：<code>@FeignClient</code> 注解有一些重要的属性，其中两个主要的属性是：</p>
<ol>
<li><code>value</code>（或 <code>name</code>）：用于指定要访问的远程服务的名称，通常是注册中心中服务的名称。通过这个属性，Feign 将找到并与远程服务建立连接。</li>
<li><code>url</code>：用于指定远程服务的基本 URL。如果您知道远程服务的确切位置，可以直接指定 <code>url</code>。</li>
</ol>
</li>
<li><p><strong>其他配置属性</strong>：除了上述两个属性外，<code>@FeignClient</code> 还支持其他配置属性，用于配置 Feign 客户端的行为，例如请求和响应的编解码器、超时设置、拦截器等。</p>
</li>
<li><p><strong>接口定义</strong>：在使用 <code>@FeignClient</code> 注解时，您需要定义一个 Java 接口，接口中的方法与远程服务的 API 端点相匹配。这些方法通常使用 Spring MVC 注解来定义请求映射和参数绑定。</p>
</li>
<li><p><strong>自动代理</strong>：Spring Cloud 会自动为使用 <code>@FeignClient</code> 注解的接口创建代理实现，该代理实现会自动将方法调用转发到远程服务。</p>
</li>
<li><p><strong>熔断降级</strong>：<code>@FeignClient</code> 还支持集成熔断降级机制，以处理远程服务的故障情况。您可以通过配置降级类或工厂来定义降级逻辑，以确保系统在远程服务不可用时仍然能够提供一定程度的可用性。</p>
</li>
<li><p><strong>fallbackfactory</strong></p>
<p>页面静态化，雪崩需要，熔断处理，，上游降级处理</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.content.feignclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xuecheng.content.config.MultipartSupportConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestPart;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 远程调用媒资服务的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/22 10:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用fallback定义降级类是无法拿到熔断异常,使用FallbackFactory可以拿到熔断的异常信息</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;media-api&quot;,configuration = &#123;MultipartSupportConfig.class&#125;,fallbackFactory = MediaServiceClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MediaServiceClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/media/upload/coursefile&quot;,consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestPart(&quot;filedata&quot;)</span> MultipartFile filedata,</span></span><br><span class="line"><span class="params">                                      <span class="meta">@RequestParam(value= &quot;objectName&quot;,required=false)</span> String objectName)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.content.feignclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.hystrix.FallbackFactory;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/22 14:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearchServiceClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;SearchServiceClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SearchServiceClient <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SearchServiceClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Boolean <span class="title function_">add</span><span class="params">(CourseIndex courseIndex)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;添加课程索引发生熔断,索引信息:&#123;&#125;,熔断异常:&#123;&#125;&quot;</span>,courseIndex,throwable.toString(),throwable);</span><br><span class="line">                <span class="comment">//走降级了返回 false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="15spring-security："><a href="#15spring-security：" class="headerlink" title="15spring security："></a>15spring security：</h2><p>进行认证授权认证框架，就是需要登录。授权模式：就是给谁访问什么资源的权限。过滤器拦截请求，</p>
<p>OAuth2：</p>
<p>授权码模式，携带授权码申请令牌，code&#x3D;TBiipf; acess_code &#x3D; ;        </p>
<p>密码模式，loadusername：连接数据库认证 userdetailservice: </p>
<p>单点登录 统一认证入口:账号密码，微信，手机验证码 </p>
<p>1.认证请求参数，</p>
<p>2.屏蔽密码校验 自定义 DaoAuthenticationProvider</p>
<p>3.自定义实现方法exeute();</p>
<p>登录成功有cookie</p>
<ol>
<li><p><strong>身份验证（Authentication）</strong>：Spring Security 提供了多种身份验证机制，包括基于用户名和密码的认证、基于令牌的认证（如OAuth2和JWT）、LDAP、OpenID Connect 等。它支持自定义身份验证提供者，使您能够集成不同的身份验证方法。</p>
<p><strong>JWT</strong></p>
<p>(JSON web Token)令牌：自验证令牌合法性，客户端(申请令牌) – 认证服务（签名生成JWT令牌） – 资源服务（当客户端携带jwt令牌访问资源时，检验令牌合法性）对称加密。对资源进管控。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.auth.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenConfig</span> &#123;</span><br><span class="line">    <span class="comment">//JWT令牌</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">SIGNING_KEY</span> <span class="operator">=</span> <span class="string">&quot;mq123&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public TokenStore tokenStore() &#123;</span></span><br><span class="line"><span class="comment">//        //使用内存存储令牌（普通令牌）</span></span><br><span class="line"><span class="comment">//        return new InMemoryTokenStore();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter accessTokenConverter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TokenStore <span class="title function_">tokenStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JwtTokenStore</span>(accessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JwtAccessTokenConverter <span class="title function_">accessTokenConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JwtAccessTokenConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JwtAccessTokenConverter</span>();</span><br><span class="line">        converter.setSigningKey(SIGNING_KEY);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//令牌管理服务</span></span><br><span class="line">    <span class="meta">@Bean(name=&quot;authorizationServerTokenServicesCustom&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationServerTokenServices <span class="title function_">tokenService</span><span class="params">()</span> &#123;</span><br><span class="line">        DefaultTokenServices service=<span class="keyword">new</span> <span class="title class_">DefaultTokenServices</span>();</span><br><span class="line">        service.setSupportRefreshToken(<span class="literal">true</span>);<span class="comment">//支持刷新令牌</span></span><br><span class="line">        service.setTokenStore(tokenStore);<span class="comment">//令牌存储策略</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TokenEnhancerChain</span> <span class="variable">tokenEnhancerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TokenEnhancerChain</span>();</span><br><span class="line">        tokenEnhancerChain.setTokenEnhancers(Arrays.asList(accessTokenConverter));</span><br><span class="line">        service.setTokenEnhancer(tokenEnhancerChain);</span><br><span class="line"></span><br><span class="line">        service.setAccessTokenValiditySeconds(<span class="number">7200</span>); <span class="comment">// 令牌默认有效期2小时</span></span><br><span class="line">        service.setRefreshTokenValiditySeconds(<span class="number">259200</span>); <span class="comment">// 刷新令牌默认有效期3天</span></span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>OAuth2</strong>配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span></span><br><span class="line">         <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  clients.inMemory()<span class="comment">// 使用in-memory存储</span></span><br><span class="line">          .withClient(<span class="string">&quot;XcWebApp&quot;</span>)<span class="comment">// client_id</span></span><br><span class="line"><span class="comment">//                .secret(&quot;secret&quot;)//客户端密钥</span></span><br><span class="line">          .secret(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">&quot;XcWebApp&quot;</span>))<span class="comment">//客户端密钥</span></span><br><span class="line">          .resourceIds(<span class="string">&quot;xuecheng-plus&quot;</span>)<span class="comment">//资源列表</span></span><br><span class="line">          .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>, <span class="string">&quot;password&quot;</span>,<span class="string">&quot;client_credentials&quot;</span>,<span class="string">&quot;implicit&quot;</span>,<span class="string">&quot;refresh_token&quot;</span>)<span class="comment">// 该client允许的授权类型authorization_code,password,refresh_token,implicit,client_credentials</span></span><br><span class="line">          .scopes(<span class="string">&quot;all&quot;</span>)<span class="comment">// 允许的授权范围</span></span><br><span class="line">          .autoApprove(<span class="literal">false</span>)<span class="comment">//false跳转到授权页面</span></span><br><span class="line">          <span class="comment">//客户端接收授权码的重定向地址</span></span><br><span class="line">          .redirectUris(<span class="string">&quot;http://www.51xuecheng.cn&quot;</span>)</span><br><span class="line">  ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.content.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 资源服务配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/18 16:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"> <span class="meta">@EnableResourceServer</span></span><br><span class="line"> <span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResouceServerConfig</span> <span class="keyword">extends</span> <span class="title class_">ResourceServerConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//资源服务标识</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RESOURCE_ID</span> <span class="operator">=</span> <span class="string">&quot;xuecheng-plus&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> &#123;</span><br><span class="line">   resources.resourceId(RESOURCE_ID)<span class="comment">//资源 id</span></span><br><span class="line">           .tokenStore(tokenStore)</span><br><span class="line">           .stateless(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  http.csrf().disable()</span><br><span class="line">          .authorizeRequests()</span><br><span class="line"><span class="comment">//          .antMatchers(&quot;/r/**&quot;,&quot;/course/**&quot;).authenticated()//所有/r/**的请求必须认证通过</span></span><br><span class="line">          .anyRequest().permitAll()</span><br><span class="line">  ;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>授权（Authorization）</strong>：Spring Security 允许您定义细粒度的访问控制策略，以决定用户是否有权访问应用程序的特定资源和功能。它支持基于角色、权限和表达式的授权。</p>
<p><strong>18RABC</strong></p>
<p>基于角色的访问控制（Role-Based Access Control）基于资源的访问控制（Resource-Based Access Control)@PreAuthorize(“hasAuthority(‘xc_teachmanager_course_list’)”)&#x2F;&#x2F;拥有课程列表查询的权限方可访问授权，解开access_token，其中就有用户的信息和该用户所拥有的权限。数据库中的表对应不同角色的权限。在mapper中写sql语句查询权限，通过UserDeatailService()获取数据返回到前端，当用户访问资源时，即可判断是否拥有权限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;课程查询接口&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;xc_teachmanager_course_list&#x27;)&quot;)</span><span class="comment">//拥有课程列表查询的权限方可访问</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/course/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> PageResult&lt;CourseBase&gt; <span class="title function_">list</span><span class="params">(PageParams pageParams, <span class="meta">@RequestBody</span> QueryCourseParamsDto queryCourseParams)</span>&#123;</span><br><span class="line">    SecurityUtil.<span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> SecurityUtil.getUser();</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="comment">//获取到用户所属机构的id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">companyId</span> <span class="operator">=</span> user.getCompanyId();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> courseBaseInfoService.queryCourseBaseList(Long.parseLong(companyId),pageParams,queryCourseParams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>授权拿到的jwt令牌中包含从数据库查到的信息，解开后这其中就含有对应角色应有的权限，这时候在对比方法上所限制的权限看是否相同，相同则可执行该方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#&#123;</span><br><span class="line">#  &quot;aud&quot;: [</span><br><span class="line">#    &quot;xuecheng-plus&quot;</span><br><span class="line">#  ],</span><br><span class="line">#  &quot;user_name&quot;: &quot;&#123;\&quot;birthday\&quot;:\&quot;2022-09-28T19:28:46\&quot;,\&quot;createTime\&quot;:\&quot;2022-09-28T08:32:03\&quot;,\&quot;id\&quot;:\&quot;50\&quot;,\&quot;name\&quot;:\&quot;学生1\&quot;,\&quot;nickname\&quot;:\&quot;大水牛\&quot;,\&quot;sex\&quot;:\&quot;1\&quot;,\&quot;status\&quot;:\&quot;1\&quot;,\&quot;username\&quot;:\&quot;stu1\&quot;,\&quot;userpic\&quot;:\&quot;http://file.51xuecheng.cn/dddf\&quot;,\&quot;utype\&quot;:\&quot;101001\&quot;&#125;&quot;,</span><br><span class="line">#  &quot;scope&quot;: [</span><br><span class="line">#    &quot;all&quot;</span><br><span class="line">#  ],</span><br><span class="line">#  &quot;active&quot;: true,</span><br><span class="line">#  &quot;exp&quot;: 1691154163,</span><br><span class="line">#  &quot;authorities&quot;: [</span><br><span class="line">#    &quot;p1&quot;</span><br><span class="line">#  ],</span><br><span class="line">#  &quot;jti&quot;: &quot;658a7d2a-83fb-42a4-860e-88233f637756&quot;,</span><br><span class="line">#  &quot;client_id&quot;: &quot;XcWebApp&quot;</span><br><span class="line">#&#125;</span><br><span class="line">#Response file saved.</span><br><span class="line">#&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>攻击防护（Attack Protection）</strong>：Spring Security 提供了内置的攻击防护机制，包括跨站请求伪造（CSRF）防护、跨站脚本攻击（XSS）防护、点击劫持防护等。它还支持 HTTP 头部控制和内容安全策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置安全拦截机制</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">            .csrf().disable() </span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/r/**&quot;</span>).authenticated()<span class="comment">//访问/r开始的请求需要认证通过</span></span><br><span class="line">            .anyRequest().permitAll()<span class="comment">//其它请求全部放行</span></span><br><span class="line">            .and()</span><br><span class="line">            .formLogin().successForwardUrl(<span class="string">&quot;/login-success&quot;</span>);<span class="comment">//登录成功跳转到/login-success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>会话管理（Session Management）</strong>：Spring Security 允许您管理用户会话，包括限制同一用户的并发会话数量、会话超时设置、会话注销等。</p>
</li>
<li><p><strong>单点登录（Single Sign-On，SSO）</strong>：Spring Security 可以与其他单点登录解决方案（如Spring Security OAuth2、Keycloak等）集成，以支持单点登录和单点注销。</p>
<p><strong>先建立统一的数据模型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.model.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 认证用户请求参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 10:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthParamsDto</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">//域  用于扩展</span></span><br><span class="line">    <span class="keyword">private</span> String cellphone;<span class="comment">//手机号</span></span><br><span class="line">    <span class="keyword">private</span> String checkcode;<span class="comment">//验证码</span></span><br><span class="line">    <span class="keyword">private</span> String checkcodekey;<span class="comment">//验证码key</span></span><br><span class="line">    <span class="keyword">private</span> String authType; <span class="comment">// 认证的类型   password:用户名密码模式类型    sms:短信模式类型</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; payload = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//附加数据，作为扩展，不同认证类型可拥有不同的附加数据。如认证类型为短信时包含smsKey : sms:3d21042d054548b08477142bbca95cfa; 所有情况下都包含clientId</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>建立统一的登录入口当登录时都会走userdeatailservice方法，根据解析出来的登录的不同方式去执行不同的excute()方法，账号密码，微信登录，自定义UserDetailsService用来对接Spring Security 统一认证入口，具体的实现取对应功能的service</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 自定义UserDetailsService用来对接Spring Security 统一认证入口，具体的实现取对应功能的service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/28 18:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    AuthService authService;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 查询用户信息组成用户身份信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s  AuthParamsDto类型的json数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.security.core.userdetails.UserDetails</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/28 18:30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AuthParamsDto</span> <span class="variable">authParamsDto</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将认证参数转为AuthParamsDto类型</span></span><br><span class="line">            authParamsDto = JSON.parseObject(s, AuthParamsDto.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;认证请求不符合项目要求:&#123;&#125;&quot;</span>,s);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;认证请求数据格式不对&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//认证方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authType</span> <span class="operator">=</span> authParamsDto.getAuthType();</span><br><span class="line">        <span class="type">AuthService</span> <span class="variable">authService</span> <span class="operator">=</span>  applicationContext.getBean(authType + <span class="string">&quot;_authservice&quot;</span>,AuthService.class);</span><br><span class="line">        <span class="type">XcUserExt</span> <span class="variable">user</span> <span class="operator">=</span> authService.execute(authParamsDto);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getUserPrincipal(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要实现的登录方法都要实现这个接口，实现不同的excute方法即可</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.dto.AuthParamsDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.dto.XcUserExt;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 认证service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 12:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authParamsDto 认证参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> com.xuecheng.ucenter.model.po.XcUser 用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/29 12:11</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    XcUserExt <span class="title function_">execute</span><span class="params">(AuthParamsDto authParamsDto)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>微信第三方登录</strong></p>
<p>code + appid +appsecret 换取access_token 用户授权同意，申请令牌，发放令牌，保存用户，自动登录，认证通过。RestTemplate第三方远程调用 , 收到code调用微信接口申请access_token，哪access_token查询用户信息，将用户信息保存到数据库代理对象控制事务，</p>
<p>1改nacos(填写appid和secret)weixin:appid: wxed9954c01bb89b47secret: a7482517235173ddb4083788de60b90e</p>
<p>2改wxlogin.html(填写appid和重定向地址)appid: “wxed9954c01bb89b47”,scope: “snsapi_login”,redirect_uri: “<a href="http://localhost:8160/api/auth/wxLogin">http://localhost:8160/api/auth/wxLogin</a>“,</p>
<p>3改nginx，开8610端口server {listen 8160;server_name localhost;<br>location &#x2F;api {proxy_pass <a href="http://gatewayserver;/">http://gatewayserver;</a>#proxy_pass <a href="http://localhost:63010;/">http://localhost:63010;</a>proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br># 这里需要添加一个rewrite规则，把请求中的&#x2F;api去掉rewrite ^&#x2F;api(.*)$ $1 break;}}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 微信扫码认证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 12:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service(&quot;wx_authservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthService</span>, WxAuthService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WxAuthServiceImpl currentProxy;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;weixin.appid&#125;&quot;)</span></span><br><span class="line">    String appid;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;weixin.secret&#125;&quot;)</span></span><br><span class="line">    String secret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//和微信对接完成后，重定向地址后，自动登录</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> XcUserExt <span class="title function_">execute</span><span class="params">(AuthParamsDto authParamsDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//账号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authParamsDto.getUsername();</span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getUsername, username));</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//返回空表示用户不存在</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;账号不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">XcUserExt</span> <span class="variable">xcUserExt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XcUserExt</span>();</span><br><span class="line">        BeanUtils.copyProperties(user,xcUserExt);</span><br><span class="line">        <span class="keyword">return</span> xcUserExt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//和微信对接的方法</span></span><br><span class="line">    <span class="keyword">public</span> XcUser <span class="title function_">wxAuth</span><span class="params">(String code)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收到code调用微信接口申请access_token</span></span><br><span class="line">        Map&lt;String, String&gt; access_token_map = getAccess_token(code);</span><br><span class="line">        <span class="keyword">if</span>(access_token_map==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(access_token_map);</span><br><span class="line">        <span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> access_token_map.get(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">access_token</span> <span class="operator">=</span> access_token_map.get(<span class="string">&quot;access_token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿access_token查询用户信息</span></span><br><span class="line">        Map&lt;String, String&gt; userinfo = getUserinfo(access_token, openid);</span><br><span class="line">        <span class="keyword">if</span>(userinfo==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将用户信息保存到数据库</span></span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> currentProxy.addWxUser(userinfo);</span><br><span class="line">        <span class="keyword">return</span> xcUser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 申请访问令牌,响应示例</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">         &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,</span></span><br><span class="line"><span class="comment">         &quot;expires_in&quot;:7200,</span></span><br><span class="line"><span class="comment">         &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span></span><br><span class="line"><span class="comment">         &quot;openid&quot;:&quot;OPENID&quot;,</span></span><br><span class="line"><span class="comment">         &quot;scope&quot;:&quot;SCOPE&quot;,</span></span><br><span class="line"><span class="comment">         &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Map&lt;String,String&gt; <span class="title function_">getAccess_token</span><span class="params">(String code)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">wxUrl_template</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=%s&amp;secret=%s&amp;code=%s&amp;grant_type=authorization_code&quot;</span>;</span><br><span class="line">            <span class="comment">//请求微信地址</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">wxUrl</span> <span class="operator">=</span> String.format(wxUrl_template, appid, secret, code);</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;调用微信接口申请access_token, url:&#123;&#125;&quot;</span>, wxUrl);</span><br><span class="line">            <span class="comment">//远程调用URL</span></span><br><span class="line">            ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(wxUrl, HttpMethod.POST, <span class="literal">null</span>, String.class);</span><br><span class="line">            <span class="comment">//响应结果</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> exchange.getBody();</span><br><span class="line">            log.info(<span class="string">&quot;调用微信接口申请access_token: 返回值:&#123;&#125;&quot;</span>, result);</span><br><span class="line">            <span class="comment">//result转为map</span></span><br><span class="line">            Map&lt;String,String&gt; resultMap = JSON.parseObject(result, Map.class);</span><br><span class="line">            <span class="keyword">return</span> resultMap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**获取用户信息，示例如下：</span></span><br><span class="line"><span class="comment">     &#123;</span></span><br><span class="line"><span class="comment">     &quot;openid&quot;:&quot;OPENID&quot;,</span></span><br><span class="line"><span class="comment">     &quot;nickname&quot;:&quot;NICKNAME&quot;,</span></span><br><span class="line"><span class="comment">     &quot;sex&quot;:1,</span></span><br><span class="line"><span class="comment">     &quot;province&quot;:&quot;PROVINCE&quot;,</span></span><br><span class="line"><span class="comment">     &quot;city&quot;:&quot;CITY&quot;,</span></span><br><span class="line"><span class="comment">     &quot;country&quot;:&quot;COUNTRY&quot;,</span></span><br><span class="line"><span class="comment">     &quot;headimgurl&quot;: &quot;https://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0&quot;,</span></span><br><span class="line"><span class="comment">     &quot;privilege&quot;:[</span></span><br><span class="line"><span class="comment">     &quot;PRIVILEGE1&quot;,</span></span><br><span class="line"><span class="comment">     &quot;PRIVILEGE2&quot;</span></span><br><span class="line"><span class="comment">     ],</span></span><br><span class="line"><span class="comment">     &quot;unionid&quot;: &quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; <span class="title function_">getUserinfo</span><span class="params">(String access_token,String openid)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">wxUrl_template</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/sns/userinfo?access_token=%s&amp;openid=%s&quot;</span>;</span><br><span class="line">        <span class="comment">//请求微信地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">wxUrl</span> <span class="operator">=</span> String.format(wxUrl_template, access_token,openid);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;调用微信接口申请access_token, url:&#123;&#125;&quot;</span>, wxUrl);</span><br><span class="line"></span><br><span class="line">        ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(wxUrl, HttpMethod.POST, <span class="literal">null</span>, String.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//防止乱码进行转码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span>     <span class="title class_">String</span>(exchange.getBody().getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);</span><br><span class="line">        log.info(<span class="string">&quot;调用微信接口申请access_token: 返回值:&#123;&#125;&quot;</span>, result);</span><br><span class="line">        <span class="comment">//map转json</span></span><br><span class="line">        Map&lt;String,String&gt; resultMap = JSON.parseObject(result, Map.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserRoleMapper xcUserRoleMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> XcUser <span class="title function_">addWxUser</span><span class="params">(Map&lt;String,String&gt; userInfo_map)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">unionid</span> <span class="operator">=</span> userInfo_map.get(<span class="string">&quot;unionid&quot;</span>).toString();</span><br><span class="line">        <span class="comment">//根据unionid查询数据库</span></span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getWxUnionid, unionid));</span><br><span class="line">        <span class="keyword">if</span>(xcUser!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> xcUser;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        xcUser = <span class="keyword">new</span> <span class="title class_">XcUser</span>();</span><br><span class="line">        xcUser.setId(userId);</span><br><span class="line">        xcUser.setWxUnionid(unionid);</span><br><span class="line">        <span class="comment">//记录从微信得到的昵称</span></span><br><span class="line">        xcUser.setNickname(userInfo_map.get(<span class="string">&quot;nickname&quot;</span>).toString());</span><br><span class="line">        xcUser.setUserpic(userInfo_map.get(<span class="string">&quot;headimgurl&quot;</span>).toString());</span><br><span class="line">        xcUser.setName(userInfo_map.get(<span class="string">&quot;nickname&quot;</span>).toString());</span><br><span class="line">        xcUser.setUsername(unionid);</span><br><span class="line">        xcUser.setPassword(unionid);</span><br><span class="line">        xcUser.setUtype(<span class="string">&quot;101001&quot;</span>);<span class="comment">//学生类型</span></span><br><span class="line">        xcUser.setStatus(<span class="string">&quot;1&quot;</span>);<span class="comment">//用户状态</span></span><br><span class="line">        xcUser.setCreateTime(LocalDateTime.now());</span><br><span class="line">        xcUserMapper.insert(xcUser);</span><br><span class="line">        <span class="type">XcUserRole</span> <span class="variable">xcUserRole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XcUserRole</span>();</span><br><span class="line">        xcUserRole.setId(UUID.randomUUID().toString());</span><br><span class="line">        xcUserRole.setUserId(userId);</span><br><span class="line">        xcUserRole.setRoleId(<span class="string">&quot;17&quot;</span>);<span class="comment">//学生角色</span></span><br><span class="line">        xcUserRoleMapper.insert(xcUserRole);</span><br><span class="line">        <span class="keyword">return</span> xcUser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自定义过滤器链（Custom Filter Chain）</strong>：Spring Security 允许您配置自定义的过滤器链，以便处理特定的安全性需求，如自定义身份验证、审计等。</p>
<p>不是所有的登录方式都需要密码验证，屏蔽掉密码验证，重写该方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.auth.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.BadCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.dao.DaoAuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 自定义DaoAuthenticationProvider</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 10:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoAuthenticationProviderCustom</span> <span class="keyword">extends</span> <span class="title class_">DaoAuthenticationProvider</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDetailsService</span><span class="params">(UserDetailsService userDetailsService)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setUserDetailsService(userDetailsService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//屏蔽密码对比</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>集成性</strong>：Spring Security 可以与 Spring 框架以及其他常见的 Java Web 框架（如Spring Boot、Spring MVC、Spring Cloud等）无缝集成。</p>
</li>
<li><p><strong>可扩展性</strong>：Spring Security 是高度可扩展的，允许您编写自定义的安全性组件和扩展点，以满足应用程序的特定需求。</p>
</li>
<li><p><strong>社区支持</strong>：Spring Security 拥有强大的社区支持和活跃的开发团队，定期发布更新和修复漏洞。</p>
</li>
</ol>
<h2 id="16支付宝支付"><a href="#16支付宝支付" class="headerlink" title="16支付宝支付"></a>16支付宝支付</h2><p><strong>流程：登录–选课–支付 （用户登录，教师发布课程，选择付费课程（付费的状态），选课表的id在订单表中为out_bussinisse_id, 订单明细表记录订单id）</strong></p>
<p>（用户下单，查询支付结果，结果通知）<strong>心态崩了，一个端口搞得我好几天，真服了，还是太马虎了</strong> <a href="hhtp://192.168.1.103:63030/orders/requestpay?payNo=%S;">hhtp:&#x2F;&#x2F;192.168.1.103:63030&#x2F;orders&#x2F;requestpay?payNo&#x3D;%S;</a></p>
<p><strong>非事务方法调用事务方法需要通过代理对象，该proxy即是本实现类的复制。 @Autowired OrederServiceImpl currentproxy;</strong><br>nacos配置appid，秘钥，注入到程序中。下载沙箱进行测试；用户–商户–支付宝。下单，支付请求，返回url，通知结果url，请求关闭订单，返回结果。 退款，对账。</p>
<p>生成支付的二维码: ZXing是用Java编写的多格式的1D &#x2F; 2D条码图像处理库，使用ZXing可以生成、识别QR Code（二维码）。</p>
<p>base工程utils下配置二维码类内网穿透的域名暂时没有买：9块钱一个月，就是需要每次启动内网穿透让后修改notify的地址。</p>
<p>alipayRequest.setNotifyUrl(<a href="http://xxx/orders/receivenotify);%E8%AE%A2%E5%8D%95%E7%BB%93%E6%9E%9C%E9%80%9A%E7%9F%A5%EF%BC%9A">http://xxx/orders/receivenotify);订单结果通知：</a></p>
<p>雪花算法生成订单号，保证唯一不重复</p>
<h2 id="17-注册和找回密码；"><a href="#17-注册和找回密码；" class="headerlink" title="17:注册和找回密码；"></a>17:注册和找回密码；</h2><p>QQ邮箱找回密码：看配置，有模版。在找回密码方法的最后，实现了一些前端代码，清空和重定向。</p>
<p>注册：手机号码和邮箱一样即可。按回车登录：钩子监听事件，在created 钩子中添加键盘监听事件。在destroy中移除键盘监听事件。</p>
<h2 id="18项目部署："><a href="#18项目部署：" class="headerlink" title="18项目部署："></a>18项目部署：</h2><p>一次部署一劳永逸，DevOps：CI&#x2F;CD:类生产环境：Kubernetes:</p>
<h1 id="19项目优化："><a href="#19项目优化：" class="headerlink" title="19项目优化："></a>19项目优化：</h1><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试:"></a>压力测试:</h2><p>吞吐量TPS:(Transaction per second)每秒可以处理的事务，一次完整的业务流程。        </p>
<p>响应时间:从发送请求到响应结果所需的时间       </p>
<p> 每秒查询次数，(Queries per second) 每秒可以查询接口的次数，可以多次TPS        </p>
<p> 错误率 :错误次数占总次数的比率。        </p>
<p> 网盘io：压测软件：Apache jmeter 新建接口测试，看汇总报告和结果。       </p>
<p>  log4j2-dev.xml : &lt;Root level : “info” &gt;debug输出日志太耗费内存 </p>
<p><img src="/img/yace.png"></p>
<h2 id="缓存优化："><a href="#缓存优化：" class="headerlink" title="缓存优化："></a>缓存优化：</h2><p>以下东西放缓存：白名单:不用登录就可试学视频。客户端需要的东西：redis键值对key-value, key:自定义的”course” + courseId (course18); value 即为16进制下的缓存在redis中的数据。查询课程发布信息，先查缓存再查数据库，缓存中没有就查询数据库，然后保存到缓存中。吞吐量：1000</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   RedisTemplate redisTemplate;</span><br><span class="line">   <span class="keyword">public</span> CoursePublish <span class="title function_">getCoursePublishCache</span><span class="params">(Long courseId)</span>&#123;</span><br><span class="line">       <span class="comment">//查询缓存</span></span><br><span class="line">       <span class="type">Object</span>  <span class="variable">jsonObj</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);</span><br><span class="line">       <span class="keyword">if</span>(jsonObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> jsonObj.toString();</span><br><span class="line">           System.out.println(<span class="string">&quot;=================从缓存查=================&quot;</span>);</span><br><span class="line">           <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);</span><br><span class="line">           <span class="keyword">return</span> coursePublish;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;从数据库查询...&quot;</span>);</span><br><span class="line">           <span class="comment">//从数据库查询</span></span><br><span class="line">           <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> getCoursePublish(courseId);</span><br><span class="line">           <span class="keyword">if</span>(coursePublish!=<span class="literal">null</span>)&#123;</span><br><span class="line">               redisTemplate.opsForValue().set(<span class="string">&quot;course:&quot;</span> + courseId, JSON.toJSONString(coursePublish));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> coursePublish;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h2><p>查询不数据库中不存在的数据导致缓存失效，即缓存被穿透了。 </p>
<p> <img src="/img/hcct.png">       </p>
<p>一般发生在高并发请求。假设查询存在的课程，多个线程第一次过来，都没有缓存，都从数据库查了。 假设查询不存在的课程，缓存中肯定没有，那么都会从数据库中查询了。</p>
<p>解决缓存穿透：</p>
<p>1.请求校验机制：合适的数据格式，            </p>
<p>2.布隆过滤器：缓存预热：先把所有的课程id保存在HashMap中，先校验是否存在HashMap，再决定是否查询数据库。相当于一层过滤。返回0，表示一定不存在。返回1，表示Map中存在courseId的Hash值。     </p>
<p>3.缓存null值或特殊值  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line">    <span class="keyword">public</span> CoursePublish <span class="title function_">getCoursePublishCache</span><span class="params">(Long courseId)</span>&#123;</span><br><span class="line">        <span class="comment">//查询缓存</span></span><br><span class="line">        <span class="type">Object</span>  <span class="variable">jsonObj</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);</span><br><span class="line">        <span class="keyword">if</span>(jsonObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> jsonObj.toString();</span><br><span class="line">            <span class="keyword">if</span>(jsonString.equals(<span class="string">&quot;null&quot;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//缓存中value是null，直接返回null即可。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;=================从缓存查=================&quot;</span>);</span><br><span class="line">            <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);</span><br><span class="line">            <span class="keyword">return</span> coursePublish;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;从数据库查询...&quot;</span>);</span><br><span class="line">            <span class="comment">//从数据库查询</span></span><br><span class="line">            <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> getCoursePublish(courseId);</span><br><span class="line"><span class="comment">//            if(coursePublish!=null)&#123;</span></span><br><span class="line"><span class="comment">//            redisTemplate.opsForValue().set(&quot;course:&quot; + courseId, JSON.toJSONString(coursePublish));</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;course:&quot;</span> + courseId, JSON.toJSONString(coursePublish),<span class="number">30</span>, TimeUnit.SECONDS); <span class="comment">//从数据库中查到value为null，照样存到数据库中，其值为null，设置过期时间30s（尽量较小） ，避免未来有正确的课程时其值还是null。 \xAC\xED\x00\x05t\x00\x04null</span></span><br><span class="line">            <span class="keyword">return</span> coursePublish;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>吞吐量1800。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩:"></a>缓存雪崩:</h2><p>在高并发的场景下，比如缓存1w个课程，有1w个key，但是这1w个课程的key过期时间一致，即key同时失效。这时候，大量的请求又会同时去请求数据库，造成数据库资源耗尽，最终造成雪崩。</p>
<p>解决缓存雪崩：</p>
<p>1.用锁解决：synchronized( Obj ){ }；效率不高。       </p>
<p> 2.key设置不同的时间即可：尽量避免再次同时访问数据库。对某一类的key缓存的时间是不一样的：入课程信息：300s，媒体信息：400s。&#x2F;&#x2F;设置过期时间300秒 redisTemplate.opsForValue().set(“course:” + courseId, JSON.<em>toJSONString</em>(coursePublish),300+new Random().nextInt(100), TimeUnit.<em>SECONDS</em>); </p>
<p>3.缓存预热：写个定时任务：发现key快失效了，再重新将key写入缓存。10s缓存一次。</p>
<h2 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h2><p>大量的并发同时访问同一个热点数据，当这个热点数据失效时，并发请求会同时去请求数据库，数据库资源耗尽。如某新品手机发布会，当缓存失效，大量并发到来，同时访问数据数据库。</p>
<p><img src="/img/hcjc.png"></p>
<p>解决缓存击穿：</p>
<p>1.加同步锁：使用同步锁控制查询数据库的代码，只允许有一个线程去查询数据库，查询得到的数据再存入缓存。synchronized(this){ 需要查询数据库的代码 };service ： 单例，多个线程共享实例，共同争抢这把锁，才能锁住。</p>
<p>   2.key-vlaue缓存时间不过期，后台做好缓存的同步即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  CoursePublish <span class="title function_">getCoursePublishCache</span><span class="params">(Long courseId)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询缓存</span></span><br><span class="line">    <span class="type">Object</span>  <span class="variable">jsonObj</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);</span><br><span class="line">    <span class="keyword">if</span>(jsonObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> jsonObj.toString();</span><br><span class="line">        <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);</span><br><span class="line">        <span class="keyword">return</span> coursePublish;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="comment">//第一次进来缓存肯定是空的，当第一个线程查完数据库，存入redis，第二个线程拿到锁直接查缓存，不需要再次查数据库。</span></span><br><span class="line">            <span class="type">Object</span>  <span class="variable">jsonObj</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);</span><br><span class="line">            <span class="keyword">if</span>(jsonObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> jsonObj.toString();</span><br><span class="line">                <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);</span><br><span class="line">                <span class="keyword">return</span> coursePublish;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;=========从数据库查询==========&quot;</span>);</span><br><span class="line">            <span class="comment">//从数据库查询</span></span><br><span class="line">            <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> getCoursePublish(courseId);</span><br><span class="line">            <span class="comment">//设置过期时间300秒</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;course:&quot;</span> + courseId, JSON.toJSONString(coursePublish),<span class="number">300</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">return</span> coursePublish;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="速记："><a href="#速记：" class="headerlink" title="速记："></a>速记：</h3><p>无中生有是穿透，布隆过滤null隔离。缓存击穿key过期， 锁与非期解难题。大量过期成雪崩，过期时间要随机。面试必考三兄弟，可用限流来保底。</p>
<h3 id="限流技术方案："><a href="#限流技术方案：" class="headerlink" title="限流技术方案："></a>限流技术方案：</h3><p>alibaba&#x2F;Sentinel nginx+Lua分布式锁：一个同步锁只能保证同一个虚拟中的多个进程，其中只有一个线程去查数据库。那么存在多个虚拟机，高并发网关通过网关负载均衡转发给各个虚拟机，此时就会存在多个线程去查数据库。        </p>
<h3 id="此时需要分布式锁："><a href="#此时需要分布式锁：" class="headerlink" title="此时需要分布式锁："></a>此时需要分布式锁：</h3><p>分布式环境下：所有虚拟机的线程去同步执行，让多个虚拟机去抢同一个锁。         此时的锁是一个单独的程序：提供解锁，上锁的服务，谁抢到锁，谁去查询数据库</p>
<p><img src="/img/fbss.png"></p>
<h1 id="实现分布式锁："><a href="#实现分布式锁：" class="headerlink" title="实现分布式锁："></a>实现分布式锁：</h1><h2 id="1-基于数据库实现："><a href="#1-基于数据库实现：" class="headerlink" title="1.基于数据库实现："></a>1.基于数据库实现：</h2><p>利用数据库主键唯一性的特点，索引唯一性，多个线程同时去插入相同的记录·，谁插入成功，谁抢到锁。（乐观锁，悲观锁）媒体资源的视频上传文件当中就运用了此分布式上传文件的方法。             </p>
<h2 id="2-基于redis实现锁："><a href="#2-基于redis实现锁：" class="headerlink" title="2.基于redis实现锁："></a>2.基于redis实现锁：</h2><p>SETNX，redission。SETNX的命令的工作过程是：去set一个不存在的key，多个线程去设置同一个key，只会有一个线程设置成功，设置成功的即拿到锁。             </p>
<h2 id="3-使用zookeeper实现。"><a href="#3-使用zookeeper实现。" class="headerlink" title="3.使用zookeeper实现。"></a>3.使用zookeeper实现。</h2><p>zookeeper的结构类似的文件目录，多线程向zookeeper创建一个子目录(节点)只会有一个创建成功，利用此特点可以实现分布式锁，谁创建该结点成功谁就获得锁实现分布式锁： </p>
<p>1.SETNX <a href="http://www.redis.cn/commands/set.html">http://www.redis.cn/commands/set.html</a> set lock01 01 NX EX 30  EX <em>seconds</em> – 设置键key的过期时间，单位时秒PX <em>milliseconds</em> – 设置键key的过期时间，单位时毫秒NX – 只有键key不存在的时候才会设置key的值XX – 只有键key存在的时候才会设置key的值</p>
<h2 id="如何释放锁："><a href="#如何释放锁：" class="headerlink" title="如何释放锁："></a>如何释放锁：</h2><h3 id="1-key过期自动释放"><a href="#1-key过期自动释放" class="headerlink" title="1.key过期自动释放"></a>1.key过期自动释放</h3><p>过期时间不好把控，快了则任务没处理完成，其他线程再来重复操作，慢了则增加其他线程等待时间。          </p>
<h3 id="2-手动删除"><a href="#2-手动删除" class="headerlink" title="2.手动删除"></a>2.手动删除</h3><p> if(缓存中有){<br> 返回缓存中的数据}else{<br> 获取分布式锁: Boolean lock01 &#x3D; redisTemplate.opsForValue().setIfAbsent(“coursequerylock”+courseId , 01，200，TimeUtil. Second) if(获取锁成功）{    try{     查询数据库   }finally{     if(redis.call(“get”,”lock”)&#x3D;&#x3D;”01”){      释放锁: redis.call(“del”,”lock”)     }}}}<br>这整个操作(拿锁，查数据库，释放锁)是原子性的：但是需要借助Lua脚本，即要么都成功，要么都失败，不能给CPu轮转时间片调度。最后，释放时间还是不好把控。   </p>
<h2 id="2-redisson"><a href="#2-redisson" class="headerlink" title="2.redisson:"></a>2.redisson:</h2><p>Redisson的文档地址：<a href="https://github.com/redisson/redisson/wiki/Table-of-Content">https://github.com/redisson/redisson/wiki/Table-of-Content</a> </p>
<p><img src="/img/reddison.png"></p>
<p>Redisson的执行逻辑：         </p>
<ol>
<li><h3 id="加锁机制："><a href="#加锁机制：" class="headerlink" title="加锁机制："></a>加锁机制：</h3><p>线程去获取锁，获取成功: 执行lua脚本，保存数据到redis数据库。线程去获取锁，获取失败: 一直通过while循环尝试获取锁，获取成功后，执行lua脚本，保存数据到redisRLock继承JDK的Lock接口，所以他有Lock接口的所有特性，比如lock、unlock、trylock等特性,同时它还有很多新特性：强制锁释放，带有效期的锁,使用Redisson可以方便的把Java本地内存中常用的数据结构对象搬到分布式缓存redis中。       ReentrantLock rtl &#x3D; new  ReentrantLock();       rtl.trylock();       try{       &#x2F;&#x2F;代码执行逻辑     }finally{     rtl.unlock();   }</p>
</li>
<li><h3 id="watchdog"><a href="#watchdog" class="headerlink" title="watchdog:"></a>watchdog:</h3><p>启动一个watch dog后台线程，不断的延长锁key的生存时间。对锁进行续期，30s后当前线程未完成再续时间。</p>
</li>
<li><h3 id="lua脚本："><a href="#lua脚本：" class="headerlink" title="lua脚本："></a>lua脚本：</h3><p>保证原子性操作：主要是如果你的业务逻辑复杂的话，通过封装在lua脚本中发送给redis，而且redis是单线程的，这样就保证这段复杂业务逻辑执行的原子性</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RRLock</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//----------------------Lock接口方法-----------------------</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁 锁的有效期默认30秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁 可以手动设置锁的有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁有效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit      时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tryLock()方法是有返回值的，用来尝试获取锁，</span></span><br><span class="line"><span class="comment">     * 如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false .</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，</span></span><br><span class="line"><span class="comment">     * 只不过区别在于这个方法在拿不到锁时会等待一定的时间，</span></span><br><span class="line"><span class="comment">     * 在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比上面多一个参数，多添加一个锁的有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waitTime  等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁有效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit      时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     * waitTime 大于 leaseTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>lock()<strong>：此方法为加锁，但是锁的有效期采用</strong>默认<strong><strong>30</strong></strong>秒</strong>如果主线程未释放，且当前锁未调用unlock方法，则进入到<strong>watchDog****机制</strong>如果主线程未释放，且当前锁调用unlock方法，则直接释放锁<br>代码编写：添加依赖。nacos中配置redisson的配置文件目录。在代码中添加singerServerConfig.yml文件：单机实例配置文件。    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  		<span class="meta">@Autowired</span></span><br><span class="line">        RedisTemplate redisTemplate;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        RedissonClient redissonClient;</span><br><span class="line">    <span class="comment">//Redisson分布式锁</span></span><br><span class="line">    <span class="keyword">public</span>  CoursePublish <span class="title function_">getCoursePublishCache</span><span class="params">(Long courseId)</span>&#123;</span><br><span class="line">        <span class="comment">//查询缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotEmpty(jsonString))&#123;</span><br><span class="line">            <span class="keyword">if</span>(jsonString.equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);</span><br><span class="line">            <span class="keyword">return</span> coursePublish;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//每门课程设置一个锁</span></span><br><span class="line">            <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;coursequerylock:&quot;</span>+courseId);</span><br><span class="line">            <span class="comment">//获取分布式锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                jsonString = (String) redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);</span><br><span class="line">                <span class="keyword">if</span>(StringUtils.isNotEmpty(jsonString))&#123;</span><br><span class="line">                    <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);</span><br><span class="line">                    <span class="keyword">return</span> coursePublish;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;=========从数据库查询==========&quot;</span>);</span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    Thread.sleep(60000);</span></span><br><span class="line"><span class="comment">//                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                    throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                <span class="comment">//从数据库查询</span></span><br><span class="line">                <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> getCoursePublish(courseId);</span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">&quot;course:&quot;</span> + courseId, JSON.toJSONString(coursePublish),<span class="number">1</span>,TimeUnit.DAYS);</span><br><span class="line">                <span class="keyword">return</span> coursePublish;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//手动释放锁，lua脚本</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/TTl.png"></p>
<p>TTL:自动续期：watchdog,不足30s，自动延期到30s，因为拿到锁还没有做完事情，做完事情会手动释放锁。最终测试：开启多个实例，只会有一个实例拿到锁，在过期时间前，进行数据库查询，再写入缓存。而另一个实例的线程进行等待。</p>
]]></content>
      <categories>
        <category>java项目</category>
      </categories>
      <tags>
        <tag>mybatis,java,ssm.spring,</tag>
      </tags>
  </entry>
</search>
