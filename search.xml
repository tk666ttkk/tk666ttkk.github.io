<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>driverlicense</title>
    <url>/2023/09/07/drivelicense/</url>
    <content><![CDATA[<h1 id="简简单单的练车日记"><a href="#简简单单的练车日记" class="headerlink" title="简简单单的练车日记"></a>简简单单的练车日记</h1><h2 id="科目一"><a href="#科目一" class="headerlink" title="科目一"></a>科目一</h2><p>哦对对对，科目一花了三天刷题，一天时间来模拟。91分飘过。</p>
<h2 id="科目二"><a href="#科目二" class="headerlink" title="科目二"></a>科目二</h2><p>8.31号开始练车，第一天熟悉地形和开车的手感，然后练了两天的侧方位，练了一天的直角转弯和曲线行驶，(<em>这里的一天指单指的45分钟或一小时</em>) ,约了18号的科二，2个星期搞定。一个星期也就练车3天，一天45分钟，但是一人一车是真的爽，教练就指导你一个，但是这教练仅仅只教了一遍点位，（此处省略C语言），抽烟，脾气不是一般的暴躁，不得不说这很符合教练的刻板印象。收了我100空调费。还是说全国的驾校教练都是统一的吗?但是总归来说，正常的教练还是希望你考证过的，不然一堆人堆积在那，驾校领导以为这个教练水平有问题，带个学员没几个考证的，可能考证之后还会有绩效什么之类的，总的来说还是希望你考过的，但是这过程注定不是轻松的。</p>
<p>倒库教了一遍就会了，9.8号所有科目都会了，再模拟几遍即可。</p>
<p>模拟过程：</p>
<p>1.上车前将座椅拉至最高处，调整座椅高度靠背，保持背是直立的，调整前后能轻松踩刹车，系安全带。</p>
<p>2.调整左右后视镜，车身位于三分之一处，第二个把手位于反光镜上沿。</p>
<p>3.踩刹车，挂挡，松手刹，起步。</p>
<p>4.9.18新港科目二：早上8点开始。</p>
<p>5.侧方位停车：行驶过程中对线，雨刷器右边对着线的左边，就是为了保持车身的平行。当前进到车头右边的黄线消失，此时看右后视镜，出现一个直角库角停止。开始侧方位。挂倒挡，当直角消失，迅速向右打满，当第一个库角出来，出来一半，还可以更多，回半圈，当第二个库角出来回一圈，当左后轮即将压线，就是准备压线，要提前向左打满，车身进来和边线保持平行停车。出去方向盘不动，打灯，挂前进档，当左侧车头碰线，回半圈，当雨刷器碰线，再回两圈，当车子驶出即将平行，回一圈。</p>
<p>6.直角转弯：行驶的过程中对线，还是雨刷器的右边对着黄线的左边。提前打灯，保持车身平行行驶。</p>
<p>当左侧前门把手刚好和直角垂直时，迅速向左打满，出去即将对准S弯回半圈，对准S弯再回一圈。</p>
<p>7.S弯：车速要慢，当左侧车头的线刚刚好碰上右边黄线，迅速向左打满一圈，此时立即往左带80度，将车头带进来，当车头带进30-40公分时，回80度。当左侧车头碰到左边黄线，迅速往右打一圈，当雨刷器刚刚好过线时，右边一圈，此时不急带50度，当准备出去时，此时会有向右的小弯，再带50度。当车子准备驶出，回50度，出去时再回一圈，尽量靠右行驶。</p>
<p>8.倒车入库：选择3-4号库即可。靠右行驶，行驶过程中保持车身平行，还是雨刷器的右边对准右边白线的左边，保持直线行驶。当开到肩膀位于第二和第三根黄线的中间时，停车，此时向左打满。出去差不多了，回半圈，车身即将平行，回一圈，保持方向盘前的矩形仪表盘的右边对准前方直角箭头下面黄线的左边。可以适当重叠，就是矩形和前面的矩形可以重叠一半。保持右边至一半重叠的范围即可。当前进到方向盘过线即可开始倒车入库。挂倒挡，左后视镜即将碰线，迅速向左打满，车速要慢，盖过第一根，第二根，在第二根和第三根黄线的空隙中间，回半圈，此时看右后视镜，当直角库角出现一个拳头时，回一圈。眯着左眼，右眼看，倒退至刚刚好盖过黄线，停车，这就是入库的点。右边出库，当前方门把手上的玻璃左角超过黄线大约一个拳头时向右打一圈加90度，这个出库的点不好把握，就是大概一个拳头的距离，此时可以适当松掉刹车，当右边黄线刚好和肩膀平行，停车，挂倒挡，倒回来，可适当松刹车，当准备对库角时，踩刹车放慢车速，对准第一个库角，右边半圈，就是往右打满，盖第一根黄线，第二根黄线，当盖到第三根黄线的中间时回半圈，这里不能回晚，晚了压右后轮回压右边前直角</p>
<p>此时看左后视镜，当左边直角库角出来大约一个拳头往左边回一圈，停至入库的点。还是出库的点，左边一圈加90度，出来差不多回半圈，车身即将平行，回一圈，此时已考试合格，右转，停至安全员检查成绩合格，踩刹车，挂P挡，拉手刹，解安全带。此时考试完毕。</p>
<p>9两辆车型对照:捷达和斯柯达。雨刷器和车头的线的区别。雨刷器中间有根钉子，左边是最高点，右边。捷达有两条线，S弯需要对着最外边的那根线，斯柯达只有一条线，对准即可。</p>
<p>10.前面有车辆正在进行项目：不能驶入，等待其完毕后才能继续进去考试。对线不要偏头。</p>
<h3 id="技巧篇"><a href="#技巧篇" class="headerlink" title="技巧篇"></a>技巧篇</h3><p>1.车速一定是慢的，快了不好调整回来。</p>
<p>2.打方向盘一定要快，车速慢，方向盘必须快。</p>
<p>3.记点位即可，科二都是点位的。</p>
<p>4.直角转弯：上窄下宽，往右打一点，就是偏左了。车身要和右边的线平行，不然会转弯压线</p>
<p>5.倒库：都一样，微调即可。</p>
<h3 id="侧方位停车"><a href="#侧方位停车" class="headerlink" title="侧方位停车"></a>侧方位停车</h3><p>1.挂倒档 看右边 直角消失右边打满<br>2.看左边 看到第一个角 左边半圈 第二个角 左边回一圈 后车轮压压线 左边打满<br>3.倒到车身平行 然后左转向灯 挂D1档<br>4.车左角压线 右回半圈 雨刮器压线右边两圈<br>车身平行往左边回一圈回正</p>
<p>车子不要踩死 要压着</p>
<h3 id="直角转弯"><a href="#直角转弯" class="headerlink" title="直角转弯"></a>直角转弯</h3><p>1.雨刷器的右边沿着边线的左边<br>2.打左转向灯 门把手垂直那根线 左边打满<br>3.等车头对准s弯道中间 往右边回正<br>4.车头最左角碰右边的线 左边一圈<br>5.出去带80度 左角带进来了30厘米80度就回掉<br>6.左角刚好要碰左边的线 右边一圈<br>7.雨刹器刚好碰过线 右边一圈<br>右边出去了大于一个拳头 就带右边50度<br>人对准中间那棵树 回正方向盘</p>
<h3 id="左边倒车入库"><a href="#左边倒车入库" class="headerlink" title="左边倒车入库"></a>左边倒车入库</h3><p>1.左边后视镜离线刚要碰上线立马往左边方向盘打死<br>2.左边后视镜 车屁股遮住第一二条虚线 在第三条虚线中间时回 半圈 觉得宽了就往左边加<br>3.看右边后视镜 直角出来一个拳头了边倒右边回一圈<br>4.倒车到那根线与自己身子一样<br>5.出库  出库这个点很微妙，要自己把握，出库晚了，右边倒库进来会压直角弯。</p>
<p>左边一圈加九十度 左边后视镜快碰到第一根虚线 回九十度 车身一平行 回正</p>
<h3 id="右边出库"><a href="#右边出库" class="headerlink" title="右边出库"></a>右边出库</h3><p>1.车出去 车侧边三分之一到线 右边一圈加九十度<br>2.一直不动到肩膀超过左边的那根线 肩膀平行过一点 停下倒车<br>3.倒车到直角的时候 右边打满 车屁股到最后一根虚线一半的地方 左边回半圈<br>4.看左边后视镜 直到平行多出一个拳头 左边回一圈<br>5.倒车到那根线与自己身子一样 到进库的地方停车</p>
<p>看左边是一个拳头回正<br>看右边是大半个拳头回正</p>
<h2 id="科目三"><a href="#科目三" class="headerlink" title="科目三"></a>科目三</h2><h2 id="科目四"><a href="#科目四" class="headerlink" title="科目四"></a>科目四</h2>]]></content>
      <categories>
        <category>日常生活</category>
      </categories>
  </entry>
  <entry>
    <title>linux</title>
    <url>/2023/09/08/linux/</url>
    <content><![CDATA[<h1 id="一-：开始："><a href="#一-：开始：" class="headerlink" title="一 ：开始："></a>一 ：开始：</h1><p>操作ctrl+alt+f2:进入shell界面 ctrl+alt+f1:进入图像界面ls &#x2F;usr&#x2F;sbin&#x2F; | grep service 查找子文件是否存在</p>
<h1 id="二：基本操作："><a href="#二：基本操作：" class="headerlink" title="二：基本操作："></a>二：基本操作：</h1><p>基本文件编辑cd:进入文件 vim：</p>
<p>文本编辑器（一 “:”进入命令模式 u 回撤 w 保存 q 退出 wq保存并退出!q强制退出 set nu 显示行号                i&#x2F;a当前光标头尾插入，I&#x2F;A行头尾插入 o&#x2F;O下上一行插入                     </p>
<p>普通模式 数字&amp;yy 复制 数字&amp;p 粘贴 数字&amp;dd 删除          </p>
<p>剪切一个字符 X 剪切光标的前一个字符            </p>
<p>y&#x2F;d&amp;w 复制删除一个单词 y&#x2F;d&amp;$复制删除光标之前      y&#x2F;d&amp;^复制删除光标之后            </p>
<p>r 替换字符 R 进入替换模式            </p>
<p>^行头 $行尾 w下一个词头 b上一个词头 e当前词尾 gg页头 G页尾 数字N&amp;G移动到目标行      </p>
<p>&#x2F;查找 n查找下一个 N查找上一个         </p>
<p>s&#x2F;old&#x2F;new替换首个 s&#x2F;old&#x2F;new&#x2F;g替换整行 %s&#x2F;old&#x2F;new替换所有行的首个                         %s&#x2F;old&#x2F;new&#x2F;g替换全篇)</p>
<h1 id="三：网络编辑"><a href="#三：网络编辑" class="headerlink" title="三：网络编辑"></a>三：网络编辑</h1><h2 id="windows网络高级设置："><a href="#windows网络高级设置：" class="headerlink" title="windows网络高级设置："></a>windows网络高级设置：</h2><p>可查看vmware虚拟网卡的ip（NAT）ping ip地址 进行网络连接cmd下：ipconfig查看所有连接网络的IP地址linux下: ifconfig查看所有连接网络的IP地址</p>
<h2 id="修改静态ip："><a href="#修改静态ip：" class="headerlink" title="修改静态ip："></a>修改静态ip：</h2><p>vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33添加#IP地址 IPADDR&#x3D;192.168.xxx.100(从100开始对应相应的主机名称)    #网关 GATEWAY&#x3D;192.168.xxx.2   #域名解释器 DNS1&#x3D;192.168.xxx.2重启网络配置：service network restart</p>
<h2 id="修改主机名："><a href="#修改主机名：" class="headerlink" title="修改主机名："></a>修改主机名：</h2><p>hostname set-hostname xx创建主机名和ip地址的映射关系: vim &#x2F;etc&#x2F;hosts192.168.32.100 hadoop100…</p>
<h1 id="四：远程登录cmd"><a href="#四：远程登录cmd" class="headerlink" title="四：远程登录cmd"></a>四：远程登录cmd</h1><p>：ssh root@hadoop100 yes 输入密码进入 linux 退出exit用XSell操作和Xftp传文件</p>
<h1 id="五：系统管理进程："><a href="#五：系统管理进程：" class="headerlink" title="五：系统管理进程："></a>五：系统管理进程：</h1><p>正在执行的程序或命令服务(.d结尾)：需要一直存在的进程，由守护进程来执行，形成服务。类似mysql80的自动启动（常驻后台）systemctl start&#x2F;stop&#x2F;restart&#x2F;status 服务名</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>lqb</title>
    <url>/2023/09/08/lq/</url>
    <content><![CDATA[<h1 id="近几年的题目分类："><a href="#近几年的题目分类：" class="headerlink" title="近几年的题目分类："></a>近几年的题目分类：</h1><h2 id="2022填空："><a href="#2022填空：" class="headerlink" title="2022填空："></a>2022填空：</h2><p>1.大数（BigInteger）2.回文字串（String.compareTo（new StringBuider().reverse().toString()）&#x3D;&#x3D;0 ）只有String之间才能进行比较3.次数最多的字母(HashMap List Collections)Collections.sort(list);桶排序   4.数组排序数组（非常好用）：Arrays.sort();<br>6.最大子矩阵暴力循环（四重循环）左上角开始循环矩阵，寻找子矩阵中的最大值最小值，计算limit，每次记录矩阵的最大面积，最后遍历结束即可输出最大的子矩阵；<br>7.</p>
<h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><p>1.ASCII码2.卡片拼数字  数位拆分：Arrays.fill(a,2021);3.直线:Set 不含重复元素的集合(纯纯考数学，不写了)4.货物摆放：ArrayList保存因子，暴力</p>
<h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p>1.ASCII码(译码 -&gt; 编码)2.纪念日( 日期)3.核酸4.分配口罩（位运算）1&lt;&lt;5 &#x3D; 将二进制下的1左移5位 即 2^6i &amp; (1&lt;&lt;j) :i &amp; (2^6) 表示i和2^6的按位与，即检测i的j位是否为1 ,为1给第一家，为0给第二家 i&#x3D;5 101 : for(j:0循环) i &amp; (1&lt;&lt;j) i &amp;(1) 101                                     1 数位相同，结果为1，分配给第一家医院 )    </p>
<h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><p>1.组队（签到题）2.不同的字串（HashSet）3.数列求值（开long，取余）4.数的分解（排列组合）</p>
<h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><p>（只会写第一题，好难！！！s）1.签到题2.求圆内的小方格(模拟坐标，判断直线)数学题3.复数（纯纯数学。。。。。）4.测试次数（二分 + 动态规划 ）</p>
<h1 id="按照题型分类的考点"><a href="#按照题型分类的考点" class="headerlink" title="按照题型分类的考点:"></a>按照题型分类的考点:</h1><p>题目的数据范围决定了变量的数据类型</p>
<h2 id="快读"><a href="#快读" class="headerlink" title="快读:"></a>快读:</h2><p> BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(System.in));读数据：long n &#x3D; Long.parseLong(in.readLine());字符串 : String str &#x3D; in.readLine(); 数组 :String nums[] &#x3D; in.readLine().split(“ “)；   int[] arr &#x3D; new int[nums.length];   for (int i &#x3D; 0; i &lt; nums.length; i++) {  arr[i] &#x3D; Integer.parseInt(nums[i]);} 多个数据：      String nums[] &#x3D; in.readLine().split(“ “)； int n &#x3D; Integer.parseInt(nums[0]);  int m &#x3D; Integer.parseInt(nums[1]);  多行输入：StringBuilder sb &#x3D; new StringBuilder();String line;while ((line &#x3D; in.readLine()) !&#x3D; null &amp;&amp; !line.isEmpty()) {  sb.append(line).append(“\n”);}String input &#x3D; sb.toString();</p>
<h2 id="快写"><a href="#快写" class="headerlink" title="快写:"></a>快写:</h2><p> PrintWriter out &#x3D; new PrintWriter(new OutputStreamWriter(System.out));out.print(n);out.flush();</p>
<h2 id="1-搜索spfa（路径）"><a href="#1-搜索spfa（路径）" class="headerlink" title="1.搜索spfa（路径）"></a>1.搜索spfa（路径）</h2><p>求单源起点到任意点的距离，图的权值有题目决定设置中间节点和距离简单的dfs（灌溉，长草，扫雷,受伤的皇后）板子题难一点的dfs（全球变暖，滑雪，剪格子）滑雪：dp数组保存最大的距离     剪格子：回溯，剪枝全球变暖：简单的bfs（迷宫带路径输出，01迷宫）队列操作，取节点，用节点，进节点难一点的bfs（青蛙跳杯子）每次比较队列里的不同的字符串，字符串保存在set集合中，每次bfs和当前两串‘*’之间的距离，</p>
<h2 id="2-字符串StringBuilder"><a href="#2-字符串StringBuilder" class="headerlink" title="2.字符串StringBuilder"></a>2.字符串StringBuilder</h2><p>StringBuffer 回文：String.compareto (StringB(String str).reverse.toString) &#x3D;&#x3D; 0;桶排序：记录每个字符串中每个字母出现的次数int book []&#x3D;new int [26];for(int i:n){book[str.charAt(i)-‘A’]++;}sysout((char)(‘A’+i));取所有子串：for(int i&#x3D;0;i&lt;n;i++){for(int j&#x3D;i;j&lt;n;j++){ String str &#x3D; s.subString(i,j+1);}}是否单调递增：abb型：最长平衡子串：Excel：卡片：数组存放每一张卡片，循环字符串数组减去。删除字符：留下的字典序最小，while(t&gt;0){ 每次比较两个字符即可; t–;}</p>
<h2 id="3-数论欧拉筛"><a href="#3-数论欧拉筛" class="headerlink" title="3.数论欧拉筛"></a>3.数论欧拉筛</h2><p>– 求解范围内的质数以及判断某个数是否是质数：private static boolean isprime(int n){  if(n&lt;2){return false;}<br>  boolean [] isprime &#x3D; new boolean[n+1];  Arrays.fill(isprime,true);    &#x2F;&#x2F;通过标记每个质数的倍数来筛选出所有的合数，如果一个数没有  for(int i&#x3D;2;i * i &lt;&#x3D; n;i++){    if(isprime[i]){    for(int j&#x3D; i * i;j&lt;&#x3D;n;j+&#x3D;i){      isprime[j] &#x3D; false;    }  }}  return isprime[n];}因子&#x2F;质因子分解–求解质因子个数：private static int zyfj(int n) {  if(n&lt;2) {    return 0;  }  int count&#x3D;0;  for(int i&#x3D;2;i<em>i&lt;&#x3D;n;i++){    while(n % i&#x3D;&#x3D;0) {      count++;      n&#x2F;&#x3D;i;    }  }  if(n&gt;1) {    count++;  }  return count;}唯一分解定理–求解约数个数：private static int wyfj(int n) {  int count &#x3D;1;  for(int i&#x3D;2;i</em>i&lt;&#x3D;n;i++) {    int ans &#x3D;0;    while(n % i &#x3D;&#x3D;0) {      ans++;      n&#x2F;&#x3D;i;    }    if(ans&gt;0) {      count *&#x3D; (ans+1);    }  }  if(n&gt;1) {    count *&#x3D;2;  }  return count;}<br>仓库：所有的因子添加到集合中，遍历找答案纯质数：数位拆分判断每一位是否为质数，boolean数组保存0-9[]的数是否为质数大数：BigInteger,含有mod，mutiply，divide，pow, abs, 利用大数的gcd求(1-n的)lcm：等差数列：d &#x3D; (an - a1) &#x2F; (n-1); Sn &#x3D; n * (an+a1) &#x2F; 2;等比数列：q &#x3D; an &#x2F; a1 ^ (1&#x2F;(n-1)); Sn &#x3D; a1 * (1-q^n) &#x2F; (1-q); 斐波那契数列：每60项数字的余数形成一个周期；分数的表示：printf(“%d &#x2F; %d”,a,b);小数的表示：printf(“%.2f”,（double) a);阶乘约数：求100!有多少个约数，(1-100)的唯一分解定理，桶排序存放因子的出现的次数；等差素数数列：模拟数字和公差 ,while(isp(a+j)){a &#x3D; a+j; cnt++;}寻找10个连续素数的公差 约数个数：取sqrt，每次+2；大数取余，%即可取后n位；</p>
<h2 id="4-日期判断日期的合法性以及模拟一个日期："><a href="#4-日期判断日期的合法性以及模拟一个日期：" class="headerlink" title="4.日期判断日期的合法性以及模拟一个日期："></a>4.日期判断日期的合法性以及模拟一个日期：</h2><p>记得重置二月份的天数：day[2] &#x3D; 28;格式化日期：SimpleDateFormat sdf &#x3D; new SDF(“yyyy-MM-dd HH:mm:ss”);将long-&gt;Date : Date d &#x3D; new Date(long start);将Date-&gt;long : long start &#x3D; sdf.parse(“2023-04-08 00:00:00”).getTime();跑步锻炼：每天星期一跑步：new Date(long start).toString.contains(“01 “); – 1后面含空格</p>
<h2 id="5-模拟枚举枚举："><a href="#5-模拟枚举枚举：" class="headerlink" title="5.模拟枚举枚举："></a>5.模拟枚举枚举：</h2><p>顺子日期：刷题统计：每天打卡题数形成数组，模拟天数（注意i++的位置）和日期换瓶盖：模拟瓶盖数和饮料总数<br>模拟：天干地支：两个数组分别存放天干地支，分别模拟1960年前后的年份，前面天干地支–，后面天干地支++，注意达到数组界限时，天干地支取数组上界或下界；玩具：直接找规律模拟即可纸张尺寸：A1，for(int i&#x3D;48;i&lt;c[1];i++){ } – 太妙了，模拟的是Ax尺寸的尺寸的次数翻硬币：两个数组，遍历，若元素不同则翻动两个硬币，三元符号表示： c[i] &#x3D;&#x3D;’<em>‘?’o’:’</em>‘;</p>
<h2 id="6-二分贪心贪心"><a href="#6-二分贪心贪心" class="headerlink" title="6.二分贪心贪心:"></a>6.二分贪心贪心:</h2><p>答疑：题目要求的是在中间时刻开始时，(即前一次答疑结束到下一次答疑的开始)，数组含多个元素的快速排序：Arrays.sort(nums,(a,b) -&gt; (a[0]+a[1]+a[2]) - (b[0]+b[1]+b[2]))for(int i&#x3D;0;i&lt;n;i++){for(int j&#x3D;0;j&lt;3;j++){ sum+&#x3D;nums[i][j]; if(j &#x3D;&#x3D; 1) ans+&#x3D;sum; }}谈判：付账：判断一个人的钱乘以n是否恰好等于总数   money *(n-1)&lt;s?需要付完 : 选择方差最小的金额付款; </p>
<p>二分：int l&#x3D;0,r &#x3D; 10000;while(l&lt;&#x3D;r){  int mid &#x3D; (l+r)&gt;&gt;1;  if(check()){ ret &#x3D; mid ; r &#x3D; mid -1;}else{ l &#x3D; mid+1;}} ret即是答案递增三元组：双指针，a和c数组分别模拟一个指针的移动，遍历b数组，直到找到满足条件的下标；数组a找最后一个，数组c找第一个分巧克力：按题目要求是分成正方形,即二分的题目求出符合题意的check()即可，count +&#x3D; (ab[i][0] &#x2F; mid) * (ab[i][1] &#x2F; mid );路标：两个路标之间的距离&lt;mid,不需要设置，否则在当前路标设置一个距离为mid的路标，不断重复模拟合适的mid。</p>
<h2 id="7-基础知识"><a href="#7-基础知识" class="headerlink" title="7.基础知识"></a>7.基础知识</h2><p>拷贝：答案存在小数+1的情况；ASCII码:’0’:48 A’65’ a’97’进制转换：Integer.toHex &#x2F; toOct &#x2F; toBina (将十进制转化为16 &#x2F; 8 &#x2F; 2 进制)一次向List添加多个数据ArrayList&lt;&gt;list &#x3D; new ; list.addAll(Arrays.asList(2,3,23,32,32,23,32));读文件 String Path &#x3D; “D:\lq\b.txt”;BuffR in &#x3D; new br(new inps(new fileinpt(new file(Path))));String line &#x3D; “”; while(){(line &#x3D; in.readline())!&#x3D; null}</p>
<h2 id="8-暴力位运算："><a href="#8-暴力位运算：" class="headerlink" title="8.暴力位运算："></a>8.暴力位运算：</h2><p>(左移)两家医院分15批口罩，求分得的口罩数的差值尽可能的小&#x2F;&#x2F;模拟1-2^15种所有的可能sfor(int i&#x3D;0;i&lt;(1&lt;&lt;15);i++) {      int sum1&#x3D;0;int sum2&#x3D;0;      &#x2F;&#x2F;j表示枚举每次的口罩将给那一家医院，在15位二进制数的      &#x2F;&#x2F;情况下，1给第一家,0给第二家      for(int j&#x3D;0;j&lt;15;j++) {        if( (i &amp; (1&lt;&lt;j) ) !&#x3D;0) {          sum1 +&#x3D;nums[j];        }else {          sum2 +&#x3D;nums[j];        }      }      &#x2F;&#x2F;每一种情况下，两家医院口罩数量的差值，保留最小的na一个      ans &#x3D; Math.min(ans, Math.abs(sum1 -sum2));    }<br>倍数问题：一个数组找三个数，是k的倍数，求三数之和从尾部开始暴力，for(int i&#x3D;n-1;i&gt;&#x3D;2;i–) {                for(int j&#x3D;i-1;j&gt;&#x3D;1;j–) {                  for(int q &#x3D; j-1;q&gt;&#x3D;0;q–) {                     &#x2F;&#x2F;剪枝 if(sum&lt;ans) break;                           &#x2F;&#x2F;后面都小于，不必再判断                           if(a[i]+a[j]+a[j-1]&lt;ans) {                             break;}}                           &#x2F;&#x2F;后面都小于，不必再判断                             if(a[i]+a[i-1]+a[i-2]&lt;ans) {                               break;                                    }&#x2F;&#x2F;(60%)<br>灯塔：暴力枚举每个点，计算它到灯塔的距离是否小于半径，即可判断能否被照到递增序列：暴力枚举每个点的中心散发的左下，右上，右下，同一行，同一列的直线是否递增<br>真-暴力: &#x2F;&#x2F;直接暴力三重循环  int count &#x3D; 0;  for (int i &#x3D; 0; i &lt; 30; i++) {    for (int j &#x3D; 0; j &lt; 50; j++) {        int num &#x3D; a[i][j];        &#x2F;&#x2F;每一行        for(int t &#x3D; i+1;t&lt;30;t++) {          if(num&lt;a[t][j]) {            count++;          }        }                &#x2F;&#x2F;每一列        for(int t&#x3D;j+1;t&lt;50;t++) {          if(num&lt;a[i][t]) {            count++;          }        }        &#x2F;&#x2F;左下斜线        for(int t &#x3D; i+1,tt &#x3D;j-1;t&lt;30&amp;&amp;tt&gt;&#x3D;0;t++,tt–){          if(num&lt;a[t][tt]) {            count++;          }        }        &#x2F;&#x2F;右上斜线        for(int t &#x3D; i-1,tt&#x3D;j+1;t&gt;&#x3D;0&amp;&amp;tt&lt;50;t–,tt++) {          if(num&lt;a[t][tt]) {            count++;          }        }        &#x2F;&#x2F;右下斜线        for(int t&#x3D;i+1,tt&#x3D;j+1;t&lt;30&amp;&amp;tt&lt;50;t++,tt++) {          if(num&lt;a[t][tt]) {            count++;          }        }      }    }<br>2019分解： 分解为3个不同数的和，有顺序：i取前1&#x2F;3,j取i后面，k取j后面，能保证取到的数不重复for(int i&#x3D;1;i&lt;s&#x2F;3+1;i++) {      for(int j&#x3D;i+1;j&lt;s;j++) {        for(int k&#x3D;j+1;k&lt;s;k++) {<br>卡片：三种卡片有6个不同的组合，n人至少需要i个：两层循环解决；4平方和：拉格朗日定理可以取相同的数：20 &#x3D; 0 0 2 4，后面的数一定是最大的，for (int i1&#x3D;0;i1<em>i1&lt;&#x3D;n;i1++)     for (int i2&#x3D;i1;i2</em>i2&lt;&#x3D;n;i2++)       for (int i3&#x3D;i2;i3<em>i3&lt;&#x3D;n;i3++)         for (int i4&#x3D;i3;i4</em>i4&lt;&#x3D;n;i4++)           if (i1<em>i1+i2</em>i2+i3<em>i3+i4</em>i4&#x3D;&#x3D;n) {</p>
<p>字母阵列：求中心散射的八个方向直线上形成”lanqiao”直接枚举8个点的方向：for(int i&#x3D;0;i&lt;n;i++) {        for(int j&#x3D;0;j&lt;n;j++) {          if(zhi[i][j]&#x3D;&#x3D;’L’) {&#x2F;&#x2F;向8个方向寻找搜索            if(j+6&lt;n&amp;&amp;zhi[i][j+1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i][j+2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i][j+3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i][j+4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i][j+5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i][j+6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向右寻找            }            if(i+6&lt;n&amp;&amp;zhi[i+1][j]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+2][j]&#x3D;&#x3D;’N’&amp;&amp;zhi[i+3][j]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i+4][j]&#x3D;&#x3D;’I’&amp;&amp;zhi[i+5][j]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+6][j]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向下寻找            }            if(j-6&gt;&#x3D;0&amp;&amp;zhi[i][j-1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i][j-2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i][j-3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i][j-4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i][j-5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i][j-6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向左寻找            }            if(i-6&gt;&#x3D;0&amp;&amp;zhi[i-1][j]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-2][j]&#x3D;&#x3D;’N’&amp;&amp;zhi[i-3][j]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i-4][j]&#x3D;&#x3D;’I’&amp;&amp;zhi[i-5][j]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-6][j]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向上寻找            }            if(j+6&lt;n&amp;&amp;i+6&lt;n&amp;&amp;zhi[i+1][j+1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+2][j+2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i+3][j+3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i+4][j+4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i+5][j+5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+6][j+6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向右下寻找            }            if(j-6&gt;&#x3D;0&amp;&amp;i+6&lt;n&amp;&amp;zhi[i+1][j-1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+2][j-2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i+3][j-3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i+4][j-4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i+5][j-5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+6][j-6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向左下寻找            }            if(i-6&gt;&#x3D;0&amp;&amp;j-6&gt;&#x3D;0&amp;&amp;zhi[i-1][j-1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-2][j-2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i-3][j-3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i-4][j-4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i-5][j-5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-6][j-6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向左上寻找            }            if(i-6&gt;&#x3D;0&amp;&amp;j+6&lt;n&amp;&amp;zhi[i-1][j+1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-2][j+2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i-3][j+3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i-4][j+4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i-5][j+5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-6][j+6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向右上寻找            }<br>最大子矩阵：四层循环遍历矩阵，从左上角遍历到右下角,每次取不同的子块来遍历，子矩阵最大最小值&lt;limit     for(int i&#x3D;N;i&gt;0;i–) {      for(int j&#x3D;M;j&gt;0;j–) { &#x2F;&#x2F; i*j的矩阵(右下角的坐标)        for(int x&#x3D;0;x&lt;&#x3D;N-i;x++) {          for(int y&#x3D;0;y&lt;&#x3D;M-j;y++) { &#x2F;&#x2F;左上角坐标            int max &#x3D; find_max(i,j,x,y);            int min &#x3D; find_min(i,j,x,y);<br>private static int find_max(int i, int j, int x, int y) {    &#x2F;&#x2F; 寻找最大值    int res &#x3D; Integer.MIN_VALUE;    for(int n&#x3D;x;n&lt;x+i;n++) {      for(int m&#x3D;y;m&lt;y+j;m++) {        res &#x3D; Math.max(res, arr[n][m]);      }    }    return res;  }</p>
<h1 id="其他知识点："><a href="#其他知识点：" class="headerlink" title="其他知识点："></a>其他知识点：</h1><p>1M&#x3D;1024kb 1kb&#x3D;1024字节 1字节&#x3D;8bit ASCII码：A:65 a:97<br>计算机算法：枚举、排序、搜索、计数、贪心、动态规划、图论、数论、博弈论<em>、概率论</em>、计算几何<em>、字符串算法等。数据结构：数组、对象&#x2F;结构、字符串、队列、栈、树、图、堆、平衡树&#x2F;线段树、复杂数据结构</em>、嵌套数据结构<em>等 暴力枚举需要注意变量的重置为0，即枚举下一个新的数时，需要将之前计算的值清零<br>ArrayList.addAll(Arrays.aslist(xx,xx,xx))ArrayList<Integer> arr &#x3D; new ArrayList<E>();添加数据到数组中，多用于求因子类的题目 remove()去掉首项 get()[从0开始]取元素Arrays.sort(数组自然排序)<br>基础：1.数位拆分 x % y x &#x2F; y &#x2F;&#x2F;计算一个数字每个位数之和public static int getsum(int num){int sum&#x3D;0;while(num !&#x3D;0){  sum +&#x3D; num %10;  num &#x2F;&#x3D;10;}return sum;}&#x2F;&#x2F;模拟字母public static String gename(int n){StringBuilder sb &#x3D; new StringBuilder();while(n&gt;0){n–;sb.append((char)(‘A’ + n % 26));n &#x2F;&#x3D;26;     }return sb.reverse().toString();   }}2.进制模拟String hexNum &#x3D; Integer.toHexString(var).toUpperCase();&#x2F;&#x2F;将十进制转化为十六进制且全部字母都为大写 Integer.toBinaryString(var) 十进制转为二进制 Integer.toOctalString(var)十进制转化八进制 匹配二进制 “^[01]+$” 八进制 “^[0-7]+$” 十六进制 “^[a-fA-F0-9]+$”<br>其他进制转化为十进制String Bin &#x3D; “01”;int x &#x3D; Integrt.parseInt(binary,2);int y &#x3D; Integer.parseInt(octal,8);String Hex &#x3D; “ABD”;int z &#x3D; Integer.parseInt(hex,16);<br>3.最大公约数 &amp; 最小公倍数public static int gcd(int x,int y) {      return y&#x3D;&#x3D;0?x:gcd(y,x % y);    }public static int lcm(int x,int y){    return x * y &#x2F; gcd(x,y);}4.位运算：if(i &amp; (1&gt;&gt;j) )!&#x3D;0 {};5.高精度模拟：printf(“%.2f”,a);6.素数初步： private static boolean isP(int num){  if(num &lt;&#x3D;1){  return false;} for(int i&#x3D;2;i&lt;&#x3D;Math.sqrt(num);i++){if(num % i &#x3D;&#x3D;0){return false;}}return true;}<br>7.余数及相关：%8.大数系列：BigInteger类大数可以+-<em>&#x2F; % 等操作(一般对数字进行的操作都会有)add,subtract,mod,BigInteger num &#x3D; new BigIntger(“20”);BigInteger ans &#x3D; new BigInteger(“1”);for(int i&#x3D;1;i&lt;&#x3D;22;i++){     ans &#x3D; ans.mutiply(num);}9.唯一分解定理：10.日期类：&#x2F;&#x2F;判断是否是闰年public static boolean isLeap(int year){ return (year % 4 &#x3D;&#x3D;0 &amp;&amp; year % 100 !&#x3D;0) || year % 400 &#x3D;&#x3D;0};&#x2F;&#x2F;计算某个月的天数public static int getDays(int year,int month){if(month &#x3D;&#x3D;2){  return isLeap(year)?29:28;}else if(month &#x3D;&#x3D; 4||month &#x3D;&#x3D;6||month&#x3D;&#x3D;9||month&#x3D;&#x3D;11){  return 30;}else{ return 31;}}<br>runningMax:例子SimpleDateformatlong (模拟毫秒数，以毫秒为单位模拟一天的增加)日期之间不能比较。但是转换为毫秒数之后可以相比Date(模拟日期) d &#x3D; new Date(long);SimpleDateFormat sdf &#x3D; new SimpleDateFormat(“yyyy-HH-dd hh:mm:ss”);用来格式化日期的格式，即题目给的日期格式Long start &#x3D; sdf.parse(“2022-02-02 02:02:02”).getTime(); &#x2F;&#x2F;将指定的格式化日期转化为相应的毫秒数Date d &#x3D; new Date(start);&#x2F;&#x2F;再将指定的毫秒数转为对应的日期sysout d.toString();&#x2F;&#x2F;输出日期&#x2F;&#x2F;模拟一天过去start &#x3D; new Date(start).getTime() + 24<em>60<em>60</em>1000L;<br>Calender(模拟日期)<br>字符串：<br> &#x2F;&#x2F;取一个字符串的所有的子串        for(int i&#x3D;0 ; i&lt;str.length(); i++){          for(int k&#x3D; i; k&lt;str.length(); k++){            String res &#x3D; str.substring(i,k+1);            System.<strong>out**.println(res)          }        }回文字符串使用一个方法private static boolean ishuiwen(String str){  int left &#x3D;0;int right &#x3D;str.length()-1;while(left &lt; right){if(str.charAt(leftt) !&#x3D; str.charAt(right)){  return false;}left++;right–;}sreturn true;}简单字符串统计：桶排序：int []a &#x3D; new int [n];char [] c &#x3D; a.tocharArray();a[(chatAt(c) - ‘A’)]++&#x2F;&#x2F;得出相应字母在数组中保存的数量(char)( i + ‘A’) &#x2F;&#x2F; 输出相对应的字母String 1.比较：compareTo() 返回0 表示相等2.String[] arr &#x3D; str.split(“”);切割字符串,形成字符串数组<br>Stringbuffer StringBuilder (反转：reverse())String 转型 int : str.valueOf();int 转型 String : 1 +“ ”   有字串的题目可以使用老白嫖方法-》》详情见字串分值<br>解密：模拟：周期串：困难串：<br>OJ几类格式训练：字符串hash+二分：正则表达式：<br>排序：冒泡+插入+选择+希尔+计数+堆排序….java对象排序：<br>数据结构：栈和队列：链表：Set<String> set &#x3D; new HashSet&lt;&gt;();set.add();set.contains();去重:(求不同的字符串子串）HashMap&lt;Character,Integer&gt; map &#x3D; new HashMap&lt;&gt;();(本质就是一个函数映射的关系，一个值对应一个数量,如 a ：2 ，b : 3）求出现字符最多的次数map.put( c , map.getorDefalut(c,0) +1);map.get(Object o);&#x2F;&#x2F;求一个值的数量循环map中的元素for(char c : map.keyset(){  map.get(c) ;}ArrayList<Integer> list &#x3D; new ArrayList&lt;&gt;();Collections.sort(list);&#x2F;&#x2F;运用集合对动态数组进行排序TreeMap 哈希表<br>穷举-模拟：   百钱白鸡凶手分糖果接雨水<br>递归：汉诺塔连分数<br>分治：归并快排快速幂<br>搜索：DFS:矩阵搜索，最短路径，迷宫1.设置矩阵的范围2.访问数组 visited[] ，访问一个位置后，修改它的值3.初始化需要求的数值（面积，数的和等）4.上下左右四个方向递归BFS<br>回溯剪枝<br>贪心：找零动态规划：1.返回值（避免重复遍历，只要dp[i][j] !&#x3D;0）if(dp[i][j!&#x3D;0]){return dp[i][j];}2.设置初值int max &#x3D;1;3.模拟每个位置的上下左右移动for(int k&#x3D;0;k&lt;4;k++){int x &#x3D; i+dx[k]; int y &#x3D; j + dy[k];}4.判断条件if(不符合的情况){continue;}5.状态转移方程(注意是否要+1)是取最大值还是数的和6.保存所求值LCSLISLPS最大子矩阵背包专题<br>二叉树：前中后层次遍历建树遍历二叉树还原字典树哈夫曼编码并查集<br>图：图的存储1.邻接矩阵2.邻接表<br>DFS<br>BFS最小生成树最短路径：有模板Dijkstra 算法是一种贪心算法，用于求加权图的单源最短路径问题，其中所有边的权重都必须是非负数。这个算法的基本思路是从起点开始，先确定起点到所有点的最短路径，然后不断扩大已确定最短路径的节点集合，直到到达终点。<br>难点：素数进阶矩阵快速幂前缀和与差分具体题目：</strong>“k倍区间”</em></em></em><em>一维数组的前缀和数组a[1,2,3,4,5] 前缀和sum[1,3,6,10,15] 余数[1,1,0,0,1] 余数(数量)[2,3];&#x2F;&#x2F;余数等于数组相应下标的个数</em>*   **余数为0的自成一个k倍区间 count+&#x3D;v[0];**<strong>余数不为0(余数相同)1.存储余数的数量。两两组合(求和公式)可以构成一个k倍区间 count+&#x3D;(v[i] *( v[ i ] - 1 ) ) &#x2F;2</strong> **2.存储余数。的根据同余定理，如果两个前缀和对 k 取余数的结果相同，那么它们的差or和一定是 k 的倍数(23%2 &#x3D; 1 ;13% 2&#x3D;&#x3D;1；|(13+-23)| %2 &#x3D;&#x3D;0)**小木棍 - 剪枝过关数位DPs区间DP状压DP线段树</p>
]]></content>
      <categories>
        <category>lqb</category>
      </categories>
      <tags>
        <tag>lqb</tag>
      </tags>
  </entry>
  <entry>
    <title>rk</title>
    <url>/2023/09/08/rk/</url>
    <content><![CDATA[<p>按照题型分类补充一些知识点：</p>
]]></content>
      <categories>
        <category>rk</category>
      </categories>
      <tags>
        <tag>rk</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2023/09/09/mst/</url>
    <content><![CDATA[<h1 id="学成在线项目的面试题："><a href="#学成在线项目的面试题：" class="headerlink" title="学成在线项目的面试题："></a>学成在线项目的面试题：</h1><h2 id="1-Maven："><a href="#1-Maven：" class="headerlink" title="1.Maven："></a>1.Maven：</h2><p>mvn clean compile test package install deploy 清除target 编译源代码 执行单元测试 打包 打包并保存到本地 打包并上传到服务器 </p>
<h3 id="1-1依赖版本冲突怎么处理："><a href="#1-1依赖版本冲突怎么处理：" class="headerlink" title="1.1依赖版本冲突怎么处理："></a>1.1依赖版本冲突怎么处理：</h3><p>1.使用exclusion排除依赖 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 排除 Spring Boot 依赖的日志包冲突 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.通常在父工程对依赖版本进行曲管理</p>
<p>在父工程的pom.xml文件中使用dependencymanager进行依赖版本的管理即可。</p>
<p>1.2</p>
<h2 id="2-Mysql"><a href="#2-Mysql" class="headerlink" title="2.Mysql"></a>2.Mysql</h2><h3 id="2-1Mysql-常见的存储引擎和区别："><a href="#2-1Mysql-常见的存储引擎和区别：" class="headerlink" title="2.1Mysql 常见的存储引擎和区别："></a>2.1Mysql 常见的存储引擎和区别：</h3><h4 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1.InnoDB"></a>1.InnoDB</h4><p>1.支持事务控制</p>
<p>2.使用的锁粒度默认为行级锁，可以支持更高的并发，也支持表锁。</p>
<p>3.支持外键约束；外键约束其实降低了表的查询速度，增加了表之间的耦合度。</p>
<h4 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2.MyISAM"></a>2.MyISAM</h4><p>1.不提供事务支持</p>
<p>2.只支持表级锁</p>
<p>3.不支持外键</p>
<h4 id="3-memory"><a href="#3-memory" class="headerlink" title="3.memory"></a>3.memory</h4><p>数据存储在内存中</p>
<h4 id="4-总结："><a href="#4-总结：" class="headerlink" title="4.总结："></a>4.总结：</h4><p>InnoDB用于事务处理，具有ACID事务支持等特性，应用中需执行大量的insert &amp;&amp; update 等操作</p>
<p>MyISAM管理非事务表，提供高速存储和检索以及全文搜索的能力，应用需执行大量select</p>
<h3 id="2-2Mysql建表注意事项"><a href="#2-2Mysql建表注意事项" class="headerlink" title="2.2Mysql建表注意事项:"></a>2.2Mysql建表注意事项:</h3><h4 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1.存储引擎"></a>1.存储引擎</h4><p>是否支持事务控制</p>
<h4 id="2-字段类型选择"><a href="#2-字段类型选择" class="headerlink" title="2.字段类型选择"></a>2.字段类型选择</h4><p>日期：datetime （时分秒） date（年月日）</p>
<p>字符：固定长度 char 不定长 varchar</p>
<p>长文本: text longtest</p>
<p>图片等二进制数据：blob，longblob</p>
<p>金额: DECIMAL</p>
<p>数值类型：确保取值范围足够的前提下使用较小空间的类型</p>
<h4 id="3-字段"><a href="#3-字段" class="headerlink" title="3.字段"></a>3.字段</h4><p>3.1自然主键（id就好）建议使用int unsigned类型, 该主键不能有业务意义，特殊场景使用bigint</p>
<p>3.2如果要存储test，blob字段建议单独建表，在使用外键关联</p>
<p>3.3尽量不要定义外键，保证表的独立性，可以存在外键意义的字段</p>
<p>3.4设置字段的默认值，并写清楚注释，注意字段的约束（非空，唯一，主键等）</p>
<h3 id="2-3Mysql如何查询树形表"><a href="#2-3Mysql如何查询树形表" class="headerlink" title="2.3Mysql如何查询树形表"></a>2.3Mysql如何查询树形表</h3><p>树形表的标记字段是parentid即父节点的id</p>
<p>有两种方法：</p>
<p>1）当层级固定时可以使用表的自连接</p>
<p>2）如果想灵活查询每一个层级可以使用mysql递归的方法，使用 with RESCURSIVE</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">with recursive t1 <span class="title function_">as</span> <span class="params">(</span></span><br><span class="line"><span class="params">    select * from course_category where id=#&#123;id&#125;</span></span><br><span class="line"><span class="params">    union all</span></span><br><span class="line"><span class="params">    select t2.* from course_category t2 inner join t1 on t1.id = t2.parentid</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">select * from t1</span><br><span class="line">order by t1.id</span><br></pre></td></tr></table></figure>

<h2 id="3-SpingBoot"><a href="#3-SpingBoot" class="headerlink" title="3.SpingBoot"></a>3.SpingBoot</h2><h3 id="3-1springBoot接口开发常用的注解有哪些："><a href="#3-1springBoot接口开发常用的注解有哪些：" class="headerlink" title="3.1springBoot接口开发常用的注解有哪些："></a>3.1springBoot接口开发常用的注解有哪些：</h3><p>1.@Controller标记此类是控制器，可以返回视图解析器指定的html页面，通过@ResponseBody可以将结果返回json，xml数据</p>
<p>2.RestController相当于@ResponseBody+@Controller实现rest接口开发，返回json数据，不能返回html页面。</p>
<p>3.RequestMapping定义接口地址，类或方法上方，支持http的post，put，get</p>
<p>4.PostMapping 定义post接口，添加记录，复杂条件的查询接口</p>
<p>5.GetMapping 定义get接口，查询接口</p>
<p>6.PutMapping 定义put接口，修改接口</p>
<p>7.DeleteMapping 定义delete接口，删除接口，</p>
<p>8.@RequestBody 定义在方法上，将json串数据转为java对象。</p>
<p>9.@PathVarible 接收请求路径中的占位符的值，地址传参</p>
<p>10.@ApiOperation swagger 注解，对接口方法进行说明</p>
<p>11.@Autowired 基于类型注入service接口，从容器中找到service的javabean</p>
<p>12.@Resource 基于名称注入，失败则转化为进行基于类型注入</p>
<p>13.@Api swagger 注解，读接口类进行说明</p>
<h3 id="3-2请求参数的合法性校验"><a href="#3-2请求参数的合法性校验" class="headerlink" title="3.2请求参数的合法性校验"></a>3.2请求参数的合法性校验</h3><h4 id="3-2-1数据的校验"><a href="#3-2-1数据的校验" class="headerlink" title="3.2.1数据的校验"></a>3.2.1数据的校验</h4><p>必填项校验，数据格式校验（非空，是否符合日期格式）</p>
<p>基于JSR303校验框架实现，SpringBoot提供了JSR-303的支持，它就是spring-boot-starter-validation,它包含很多校验规则，只需要在模型类中通过注解指定校验规则，在controller方法上开启。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.content.api;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ApiOperation(&quot;新增课程&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/course&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CourseBaseInfoDto <span class="title function_">createCourseBase</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(ValidationGroups.Inster.class)</span> AddCourseDto addCourseDto)</span>&#123;</span><br><span class="line"></span><br><span class="line">        SecurityUtil.<span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> SecurityUtil.getUser();</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">//获取到用户所属机构的id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">companyId1</span> <span class="operator">=</span> user.getCompanyId();</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">companyId</span> <span class="operator">=</span> Long.parseLong(companyId1);</span><br><span class="line"><span class="comment">//        int i = 1/0;</span></span><br><span class="line">        <span class="type">CourseBaseInfoDto</span> <span class="variable">courseBase</span> <span class="operator">=</span> courseBaseInfoService.createCourseBase(companyId, addCourseDto);</span><br><span class="line">        <span class="keyword">return</span> courseBase;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.content.model.dto;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(value=&quot;AddCourseDto&quot;, description=&quot;新增课程基本信息&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddCourseDto</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@NotEmpty(message = &quot;新增课程名称不能为空&quot;,groups=&#123;ValidationGroups.Inster.class&#125;)</span></span><br><span class="line"> <span class="meta">@NotEmpty(message = &quot;修改课程名称不能为空&quot;,groups=&#123;ValidationGroups.Update.class&#125;)</span></span><br><span class="line"><span class="comment">// @NotEmpty(message = &quot;课程名称不能为空&quot;)</span></span><br><span class="line"> <span class="meta">@ApiModelProperty(value = &quot;课程名称&quot;, required = true)</span></span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@NotEmpty(message = &quot;适用人群不能为空&quot;)</span></span><br><span class="line"> <span class="meta">@Size(message = &quot;适用人群内容过少&quot;,min = 10)</span></span><br><span class="line"> <span class="meta">@ApiModelProperty(value = &quot;适用人群&quot;, required = true)</span></span><br><span class="line"> <span class="keyword">private</span> String users;</span><br></pre></td></tr></table></figure>

<p>校验分组：不同类型的校验需要不同的组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.base.exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 用于分级校验，定义一些常用的组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/14 9:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidationGroups</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Inster</span>&#123;&#125;;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Update</span>&#123;&#125;;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Delete</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2业务逻辑的校验"><a href="#3-2-2业务逻辑的校验" class="headerlink" title="3.2.2业务逻辑的校验"></a>3.2.2业务逻辑的校验</h4><p>在service中校验即可，例如判断只有本机构才能修改本机构的课程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据合法性校验</span></span><br><span class="line"><span class="comment">//根据具体的业务逻辑去校验</span></span><br><span class="line"><span class="comment">//本机构只能修改本机构的课程</span></span><br><span class="line"><span class="keyword">if</span>(!companyId.equals(courseBase.getCompanyId()))&#123;</span><br><span class="line">    XueChengPlusException.cast(<span class="string">&quot;本机构只能修改本机构的课程&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Mybatis"><a href="#4-Mybatis" class="headerlink" title="4.Mybatis"></a>4.Mybatis</h2><h3 id="4-1Mybatis分页插件原理"><a href="#4-1Mybatis分页插件原理" class="headerlink" title="4.1Mybatis分页插件原理:"></a>4.1Mybatis分页插件原理:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.auth.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *；</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;P&gt;</span></span><br><span class="line"><span class="comment"> *        Mybatis-Plus 配置</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.xuecheng.ucenter.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 新的分页插件</span></span><br><span class="line"><span class="comment">    * 需要设置 MybatisConfiguration#useDeprecatedExecutor = false</span></span><br><span class="line"><span class="comment">    * 避免缓存出现问题(该属性会在旧插件移除后一同移除)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">      interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">      <span class="keyword">return</span> interceptor;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现原理：首先将分页参数放到ThreadLocal中，拦截执行的sql，根据数据库类型添加对应的分页语句重写sql，例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">（<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> a）<span class="comment">--&gt; (select count(*) from table where a ) 和 （select * from table where a limit）</span></span><br></pre></td></tr></table></figure>

<p>计算出total总条数，pageNum当前第几页，pageSize每页大小和当前页的数据，是否为首尾页和总页数等，</p>
<h3 id="4-2Mybatis的ResultType-和-ResultMap的区别"><a href="#4-2Mybatis的ResultType-和-ResultMap的区别" class="headerlink" title="4.2Mybatis的ResultType 和 ResultMap的区别"></a>4.2Mybatis的ResultType 和 ResultMap的区别</h3><p>Result指定映射的类型，只要查询字段名和类型的属性名匹配即可自动映射，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectTreeNodes&quot;</span>  parameterType=<span class="string">&quot;string&quot;</span> resultType=<span class="string">&quot;com.xuecheng.content.model.dto.CourseCategoryTreeDto&quot;</span>&gt;</span><br><span class="line">    with recursive t1 <span class="title function_">as</span> <span class="params">(</span></span><br><span class="line"><span class="params">        select * from course_category where id=#&#123;id&#125;</span></span><br><span class="line"><span class="params">        union all</span></span><br><span class="line"><span class="params">        select t2.* from course_category t2 inner join t1 on t1.id = t2.parentid</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">    select * from t1</span><br><span class="line">    order by t1.id</span><br><span class="line"></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>ResultMap 自定义映射规则，不匹配，实现一对一，一对多的映射。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 通用查询映射结果 --&gt;</span><br><span class="line">&lt;resultMap id=<span class="string">&quot;BaseResultMap&quot;</span> type=<span class="string">&quot;com.xuecheng.content.model.po.CourseCategory&quot;</span>&gt;</span><br><span class="line">    &lt;id column=<span class="string">&quot;id&quot;</span> property=<span class="string">&quot;id&quot;</span> /&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;name&quot;</span> property=<span class="string">&quot;name&quot;</span> /&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;label&quot;</span> property=<span class="string">&quot;label&quot;</span> /&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;parentid&quot;</span> property=<span class="string">&quot;parentid&quot;</span> /&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;is_show&quot;</span> property=<span class="string">&quot;isShow&quot;</span> /&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;orderby&quot;</span> property=<span class="string">&quot;orderby&quot;</span> /&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;is_leaf&quot;</span> property=<span class="string">&quot;isLeaf&quot;</span> /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-和-的区别"><a href="#4-3-和-的区别" class="headerlink" title="4.3 #{} 和${} 的区别"></a>4.3 #{} 和${} 的区别</h3><p>#{} 是标记一个占位符，可以防止sql注入</p>
<p>${} 用于在动态sql中拼接字符串，可能导致sql注入</p>
<h2 id="5-系统如何进行异常处理"><a href="#5-系统如何进行异常处理" class="headerlink" title="5.系统如何进行异常处理"></a>5.系统如何进行异常处理</h2><p>自定义一个统一的异常处理器，去捕获并处理异常</p>
<p>1)处理自定义异常</p>
<p>自定义一个异常类，里面有各种异常的信息，主动抛出自定义类的异常对象，并指出详细异常信息，异常处理器捕获日志记录并响应给用户</p>
<p>2）处理未知异常</p>
<p>异常由异常处理器统一捕获，记录异常日志，统一响应500错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.base.exception;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 通用错误信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/6 11:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">CommonError</span> &#123;</span><br><span class="line"></span><br><span class="line">   UNKOWN_ERROR(<span class="string">&quot;执行过程异常，请重试。&quot;</span>),</span><br><span class="line">   PARAMS_ERROR(<span class="string">&quot;非法参数&quot;</span>),</span><br><span class="line">   OBJECT_NULL(<span class="string">&quot;对象为空&quot;</span>),</span><br><span class="line">   QUERY_NULL(<span class="string">&quot;查询结果为空&quot;</span>),</span><br><span class="line">   REQUEST_NULL(<span class="string">&quot;请求参数为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String errMessage;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getErrMessage</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errMessage;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">CommonError</span><span class="params">( String errMessage)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.errMessage = errMessage;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.base.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *；</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/12 17:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="comment">//@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//对项目的自定义异常类型进行处理</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="meta">@ExceptionHandler(XueChengPlusException.class)</span></span><br><span class="line">   <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line"> <span class="keyword">public</span> RestErrorResponse <span class="title function_">customException</span><span class="params">(XueChengPlusException e)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录异常</span></span><br><span class="line">    log.error(<span class="string">&quot;系统异常&#123;&#125;&quot;</span>,e.getErrMessage(),e);</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析出异常信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">errMessage</span> <span class="operator">=</span> e.getErrMessage();</span><br><span class="line">    <span class="type">RestErrorResponse</span> <span class="variable">restErrorResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestErrorResponse</span>(errMessage);</span><br><span class="line">    <span class="keyword">return</span> restErrorResponse;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//MethodArgumentNotValidException</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> RestErrorResponse <span class="title function_">methodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException e)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> e.getBindingResult();</span><br><span class="line">        <span class="comment">//存储错误信息</span></span><br><span class="line">        List&lt;String&gt; errors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        bindingResult.getFieldErrors().stream().forEach(item-&gt;&#123;</span><br><span class="line">            errors.add(item.getDefaultMessage());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将list中的错误信息拼接起来</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">errMessage</span> <span class="operator">=</span> StringUtils.join(errors, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="comment">//记录异常</span></span><br><span class="line">        log.error(<span class="string">&quot;系统异常&#123;&#125;&quot;</span>,e.getMessage(),errMessage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析出异常信息</span></span><br><span class="line">        <span class="type">RestErrorResponse</span> <span class="variable">restErrorResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestErrorResponse</span>(errMessage);</span><br><span class="line">        <span class="keyword">return</span> restErrorResponse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> RestErrorResponse <span class="title function_">exception</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.error(<span class="string">&quot;【系统异常】&#123;&#125;&quot;</span>,e.getMessage(),e);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span>(e.getMessage().equals(<span class="string">&quot;不允许访问&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestErrorResponse</span>(<span class="string">&quot;没有操作此功能的权限&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestErrorResponse</span>(CommonError.UNKOWN_ERROR.getErrMessage());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-什么情况下事务回失效："><a href="#6-什么情况下事务回失效：" class="headerlink" title="6.什么情况下事务回失效："></a>6.什么情况下事务回失效：</h2><h3 id="1-在方法中捕获异常没有抛出"><a href="#1-在方法中捕获异常没有抛出" class="headerlink" title="1)在方法中捕获异常没有抛出"></a>1)在方法中捕获异常没有抛出</h3><p>没有throw该异常</p>
<h3 id="2）非事务方法调用事务方法"><a href="#2）非事务方法调用事务方法" class="headerlink" title="2）非事务方法调用事务方法"></a>2）非事务方法调用事务方法</h3><p>此时需要以代理对象去调用，</p>
<p>1.注入当前的service,创建当前的代理对象 </p>
<p>@AutoWired</p>
<p>MediaFileService currentProxy;</p>
<p>2.在事务方法上声明@Transcation</p>
<h3 id="3）事务方法内部调用事务方法"><a href="#3）事务方法内部调用事务方法" class="headerlink" title="3）事务方法内部调用事务方法"></a>3）事务方法内部调用事务方法</h3><p>在一个事务方法中，不是通过当前代理对象去调用另一个事务方法，不会新建另一个新的事务。</p>
<p>@Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</p>
<h3 id="4-Transactional标记的方法不是public"><a href="#4-Transactional标记的方法不是public" class="headerlink" title="4)@Transactional标记的方法不是public"></a>4)@Transactional标记的方法不是public</h3><h3 id="5-抛出的异常与rollbackFor指定的异常不匹配"><a href="#5-抛出的异常与rollbackFor指定的异常不匹配" class="headerlink" title="5)抛出的异常与rollbackFor指定的异常不匹配"></a>5)抛出的异常与rollbackFor指定的异常不匹配</h3><p>可以在@Transaction()注解中自定义当抛出特定的异常时才需要进行事务控制，进行回滚。</p>
<p>例如 @Transaction(rollbackFor(XxException.class)) </p>
<h3 id="6）数据库表不支持事务处理"><a href="#6）数据库表不支持事务处理" class="headerlink" title="6）数据库表不支持事务处理"></a>6）数据库表不支持事务处理</h3><p>MYISLAM做存储引擎</p>
<h3 id="7）springboot的传播行为导致事务的失效"><a href="#7）springboot的传播行为导致事务的失效" class="headerlink" title="7）springboot的传播行为导致事务的失效"></a>7）springboot的传播行为导致事务的失效</h3><p>@Transaction(PROPAGATION_REQUIRES_NEW)注解中添加需要的代码</p>
<table>
<thead>
<tr>
<th>传播行为</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>当前方法必须在一个事务中运行。如果当前存在事务，方法将加入到当前事务中，如果没有事务，它将创建一个新事务。这是默认的传播行为。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>创建一个新事务，如果当前存在事务，则将其挂起。新事务独立于当前事务运行。成功提交会影响数据库，失败只会影响新事务。</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>当前方法必须在一个事务中运行，但可以创建一个嵌套事务。嵌套事务有自己的保存点，可以回滚到嵌套事务的开始，不影响外部事务。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>方法可以在事务中运行，如果没有事务，则在非事务状态下运行。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>方法在非事务状态下运行，如果当前存在事务，将其挂起，执行完方法后不会提交事务。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>方法绝对不能在事务中运行，如果当前存在事务，将抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>方法必须在一个已存在的事务中运行，如果没有事务存在，将抛出异常。</td>
</tr>
</tbody></table>
<h3 id="8）总结：只有通过当前代理对象调用的方法才能正确进行事务控制"><a href="#8）总结：只有通过当前代理对象调用的方法才能正确进行事务控制" class="headerlink" title="8）总结：只有通过当前代理对象调用的方法才能正确进行事务控制"></a>8）总结：只有通过当前代理对象调用的方法才能正确进行事务控制</h3><h2 id="7-断点续传"><a href="#7-断点续传" class="headerlink" title="7.断点续传"></a>7.断点续传</h2><p>1）前端对文件进行分块 chunk001</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageResult&lt;MediaFiles&gt; <span class="title function_">queryMediaFiels</span><span class="params">(Long companyId, PageParams pageParams, QueryMediaParamsDto queryMediaParamsDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建查询条件对象</span></span><br><span class="line">    LambdaQueryWrapper&lt;MediaFiles&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分页对象</span></span><br><span class="line">    Page&lt;MediaFiles&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageParams.getPageNo(), pageParams.getPageSize());</span><br><span class="line">    <span class="comment">// 查询数据内容获得结果</span></span><br><span class="line">    Page&lt;MediaFiles&gt; pageResult = mediaFilesMapper.selectPage(page, queryWrapper);</span><br><span class="line">    <span class="comment">// 获取数据列表</span></span><br><span class="line">    List&lt;MediaFiles&gt; list = pageResult.getRecords();</span><br><span class="line">    <span class="comment">// 获取数据总数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> pageResult.getTotal();</span><br><span class="line">    <span class="comment">// 构建结果集</span></span><br><span class="line">    PageResult&lt;MediaFiles&gt; mediaListResult = <span class="keyword">new</span> <span class="title class_">PageResult</span>&lt;&gt;(list, total, pageParams.getPageNo(), pageParams.getPageSize());</span><br><span class="line">    <span class="keyword">return</span> mediaListResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）前端使用多线程一块一块上传，上传前给服务端发送信息，核验当前当前分块是否已经上传，否则继续上传。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkFile</span><span class="params">(String fileMd5)</span> &#123;</span><br><span class="line">    <span class="comment">//先查询数据库</span></span><br><span class="line">    <span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> mediaFilesMapper.selectById(fileMd5);</span><br><span class="line">    <span class="keyword">if</span>(mediaFiles!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//桶</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bucket</span> <span class="operator">=</span> mediaFiles.getBucket();</span><br><span class="line">        <span class="comment">//objectname</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> mediaFiles.getFilePath();</span><br><span class="line">        <span class="comment">//如果数据库存在再查询 minio</span></span><br><span class="line">        <span class="type">GetObjectArgs</span> <span class="variable">getObjectArgs</span> <span class="operator">=</span> GetObjectArgs.builder()</span><br><span class="line">                .bucket(bucket)</span><br><span class="line">                .object(filePath)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//查询远程服务获取到一个流对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FilterInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> minioClient.getObject(getObjectArgs);</span><br><span class="line">            <span class="keyword">if</span>(inputStream!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//文件已存在</span></span><br><span class="line">                <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件不存在</span></span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）等到所有分块上传完毕，服务端合并所有分块，校验分块的完整性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkChunk</span><span class="params">(String fileMd5, <span class="type">int</span> chunkIndex)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据md5得到分块文件所在目录的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFileFolderPath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果数据库存在再查询 minio</span></span><br><span class="line">    <span class="type">GetObjectArgs</span> <span class="variable">getObjectArgs</span> <span class="operator">=</span> GetObjectArgs.builder()</span><br><span class="line">            .bucket(bucket_video)</span><br><span class="line">            .object(chunkFileFolderPath+chunkIndex)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">//查询远程服务获取到一个流对象</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FilterInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> minioClient.getObject(getObjectArgs);</span><br><span class="line">        <span class="keyword">if</span>(inputStream!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//文件已存在</span></span><br><span class="line">            <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件不存在</span></span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分块文件全都上传到了服务器，服务器按顺序进行合并，就是将每一个分块文件按照内容顺序一次写入一个文件中，使用字节流进行读文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">uploadChunk</span><span class="params">(String fileMd5, <span class="type">int</span> chunk, String localChunkFilePath)</span> &#123;</span><br><span class="line">    <span class="comment">//分块文件的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFilePath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5) + chunk;</span><br><span class="line">    <span class="comment">//获取mimeType</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> getMimeType(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//将分块文件上传到minio</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> addMediaFilesToMinIO(localChunkFilePath, mimeType, bucket_video, chunkFilePath);</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.validfail(<span class="literal">false</span>,<span class="string">&quot;上传分块文件失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上传成功</span></span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">mergechunks</span><span class="params">(Long companyId, String fileMd5, <span class="type">int</span> chunkTotal, UploadFileParamsDto uploadFileParamsDto)</span> &#123;</span><br><span class="line">        <span class="comment">//分块文件所在目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">chunkFileFolderPath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5);</span><br><span class="line">        <span class="comment">//找到所有的分块文件</span></span><br><span class="line">        List&lt;ComposeSource&gt; sources = Stream.iterate(<span class="number">0</span>, i -&gt; ++i).limit(chunkTotal).map(i -&gt; ComposeSource.builder().bucket(bucket_video).object(chunkFileFolderPath + i).build()).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">//源文件名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> uploadFileParamsDto.getFilename();</span><br><span class="line">        <span class="comment">//扩展名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> filename.substring(filename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="comment">//合并后文件的objectname</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> getFilePathByMd5(fileMd5, extension);</span><br><span class="line">        <span class="comment">//指定合并后的objectName等信息</span></span><br><span class="line">        <span class="type">ComposeObjectArgs</span> <span class="variable">composeObjectArgs</span> <span class="operator">=</span> ComposeObjectArgs.builder()</span><br><span class="line">                .bucket(bucket_video)</span><br><span class="line">                .object(objectName)<span class="comment">//合并后的文件的objectname</span></span><br><span class="line">                .sources(sources)<span class="comment">//指定源文件</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//===========合并文件============</span></span><br><span class="line">        <span class="comment">//报错size 1048576 must be greater than 5242880，minio默认的分块文件大小为5M</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            minioClient.composeObject(composeObjectArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">&quot;合并文件出错,bucket:&#123;&#125;,objectName:&#123;&#125;,错误信息:&#123;&#125;&quot;</span>,bucket_video,objectName,e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> RestResponse.validfail(<span class="literal">false</span>,<span class="string">&quot;合并文件异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//===========校验合并后的和源文件是否一致，视频上传才成功===========</span></span><br><span class="line">        <span class="comment">//先下载合并后的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> downloadFileFromMinIO(bucket_video, objectName);</span><br><span class="line">        <span class="comment">//文件大小</span></span><br><span class="line">        uploadFileParamsDto.setFileSize(file.length());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        try(FileInputStream fileInputStream = new FileInputStream(file))&#123;</span></span><br><span class="line"><span class="comment">//            //计算合并后文件的md5</span></span><br><span class="line"><span class="comment">//            String mergeFile_md5 = DigestUtils.md5Hex(fileInputStream);</span></span><br><span class="line"><span class="comment">//            //比较原始md5和合并后文件的md5</span></span><br><span class="line"><span class="comment">////            if(!fileMd5.equals(mergeFile_md5))&#123;</span></span><br><span class="line"><span class="comment">////                log.error(&quot;校验合并文件md5值不一致,原始文件:&#123;&#125;,合并文件:&#123;&#125;&quot;,fileMd5,mergeFile_md5);</span></span><br><span class="line"><span class="comment">////                return RestResponse.validfail(false,&quot;文件校验失败&quot;);</span></span><br><span class="line"><span class="comment">////            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">//            return RestResponse.validfail(false,&quot;文件校验失败&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//==============将文件信息入库============</span></span><br><span class="line">        <span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> currentProxy.addMediaFilesToDb(companyId, fileMd5, uploadFileParamsDto, bucket_video, objectName);</span><br><span class="line">        <span class="keyword">if</span>(mediaFiles == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> RestResponse.validfail(<span class="literal">false</span>,<span class="string">&quot;文件入库失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//==========清理分块文件=========</span></span><br><span class="line">        clearChunkFiles(chunkFileFolderPath,chunkTotal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>4）前端给服务端传了一个md5的值，服务端合并后计算MD5值是否与前端提供的相符，一样则说明文件完整，否则可能出现丢包等导致文件不完整。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取文件的md5</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getFileMd5</span><span class="params">(File file)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileMd5</span> <span class="operator">=</span> DigestUtils.md5Hex(fileInputStream);</span><br><span class="line">        <span class="keyword">return</span> fileMd5;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）分块文件清理问题</p>
<p>假如上传文件上传到一半，之前存储的minio文件需要清理吗？</p>
<p>1.在数据库中有一张文件记录表记录minio存储的文件信息</p>
<p>2.文件开始上传时会写入文件表，状态为上传中，当上传完毕在更新状态为上传完成</p>
<p>3.当文件没有完全上传成功，会有定时任务查询文件表中的记录，如果没有上传完成则删除minio没有上传成功的文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除分块文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkFileFolderPath 分块文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkTotal 分块文件总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clearChunkFiles</span><span class="params">(String chunkFileFolderPath,<span class="type">int</span> chunkTotal)</span>&#123;</span><br><span class="line">    Iterable&lt;DeleteObject&gt; objects =  Stream.iterate(<span class="number">0</span>, i -&gt; ++i).limit(chunkTotal).map(i -&gt; <span class="keyword">new</span> <span class="title class_">DeleteObject</span>(chunkFileFolderPath+ i)).collect(Collectors.toList());;</span><br><span class="line">    <span class="type">RemoveObjectsArgs</span> <span class="variable">removeObjectsArgs</span> <span class="operator">=</span> RemoveObjectsArgs.builder().bucket(bucket_video).objects(objects).build();</span><br><span class="line">    Iterable&lt;Result&lt;DeleteError&gt;&gt; results = minioClient.removeObjects(removeObjectsArgs);</span><br><span class="line">    <span class="comment">//要想真正删除</span></span><br><span class="line">    results.forEach(f-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DeleteError</span> <span class="variable">deleteError</span> <span class="operator">=</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-xxl-job"><a href="#8-xxl-job" class="headerlink" title="8.xxl -job"></a>8.xxl -job</h2><h3 id="8-1原理："><a href="#8-1原理：" class="headerlink" title="8.1原理："></a>8.1原理：</h3><p>xxl-job分布式任务调度服务由调用中心和执行器组成，调用中心负责按任务调度策略向执行器下发任务，执行器负责接收任务并执行。</p>
<p>1）部署并启动xxl-job调度中心（java工程）</p>
<p>2）在微服务添加xxl-job的依赖，在微服务中心配置服务器</p>
<p>3）启动微服务，执行器向调度中心上报自己</p>
<p>4）在微服务中写一个方法并用xxl-job的注解去标记执行任务的方法名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;videoJobHandler&quot;)</span></span><br></pre></td></tr></table></figure>

<p>5）调度中心配置任务调度策略</p>
<p>6）在xxl-job调度中心启动任务</p>
<p>7)调度中心根据任务调度策略，到达时间就开始下发任务给执行器</p>
<p>8）执行器收到任务就开始执行</p>
<h3 id="8-2如何保证任务不会重复执行"><a href="#8-2如何保证任务不会重复执行" class="headerlink" title="8.2如何保证任务不会重复执行"></a>8.2如何保证任务不会重复执行</h3><p>1）调度中心按分片广播的方式去下发任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、分片广播任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@XxlJob(&quot;shardingJobHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shardingJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分片参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();<span class="comment">//执行器的序号，从0开始</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();<span class="comment">//执行器总数</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;shardIndex=&quot;</span>+shardIndex+<span class="string">&quot;,shardTotal=&quot;</span>+shardTotal);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/xxl-job.png"></p>
<p>2）执行器收到作业分片广播的参数：分片总数和分片序号，计算 任务id &#x2F; 分片总数 得到一个余数，如果余数等于分片序号，当前执行器就去执行这个任务，这里保证了不同的执行器执行不同的任务。</p>
<p>例如：分片总数为2，分片序号0,1，2，3，两个任务，从任务1开始：假设当前执行器是2</p>
<p>1 % 2 &#x3D; 1 执行器2执行</p>
<p>2 % 2 &#x3D; 0 执行器1执行</p>
<p>3 % 2 &#x3D; 1 执行器2执行</p>
<p>3）配置调度过期策略为“忽略”，避免同一个执行器多次重复执行同一个任务。</p>
<p>4）配置任务阻塞处理策略为“丢弃后续调度”，注意：丢弃也没事，下次调度即可。</p>
<p>5）另外还要保证任务处理的幂等性，执行过的任务可以打上“已完成”的标记状态，下次再调度执行该任务判断任务状态确认是否已经完成。</p>
<p>我们在数据库视频处理表中添加处理状态的字段，视频处理完成更新状态为完成。下次执行该任务前先判断状态在决定是否执行该任务。</p>
<h3 id="8-3如何保证任务的幂等性"><a href="#8-3如何保证任务的幂等性" class="headerlink" title="8.3如何保证任务的幂等性"></a>8.3如何保证任务的幂等性</h3><p>幂等性：它描述了一次和多次请求某一个资源对于资源本身一个具有同样的结果。</p>
<p>幂等性是为了解决重复提交的问题，比如:恶意刷单，重复支付。</p>
<p>解决幂等性常用的方案：</p>
<p>1）数据库约束，比如：唯一索引，主键。同一个主键不可能两次插入成功。</p>
<p>2）唯一序列号,请求前生成唯一序列号，携带序列号去请求，执行时在redis记录该序列号，表示该序列号已经请求过了，如果请求携带的是redis中已经存有的序列号，说明该次请求是重复的。</p>
<p>3）乐观锁，常用于数据库，更新数据时根据乐观锁的状态去更新。</p>
<p>什么是乐观锁、悲观锁？synchronized是一种悲观锁，在执行被synchronized包裹的代码时需要首先获取锁，没有拿到锁则无法执行，是总悲观的认为别的线程会去抢，所以要悲观锁。乐观锁的思想是它不认为会有线程去争抢，尽管去执行，如果没有执行成功就再去重试。    </p>
<p>通常，它使用版本号或时间戳字段来检测并发修改，并确保在多个并发更新尝试中只有一个成功</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="keyword">UPDATE</span> media_process m</span><br><span class="line"><span class="keyword">SET</span> m.status<span class="operator">=</span><span class="string">&#x27;4&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> (m.status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">OR</span> m.status<span class="operator">=</span><span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> m.fail_count <span class="operator">&lt;</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">AND</span> m.id<span class="operator">=</span>?</span><br><span class="line"></span><br><span class="line"><span class="number">2</span><span class="keyword">UPDATE</span> media_process t</span><br><span class="line"><span class="keyword">SET</span> t.count <span class="operator">=</span> t.count <span class="operator">+</span> <span class="number">1</span>, t.version<span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="keyword">WHERE</span> t.version <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>1这个UPDATE语句将名为<code>media_process</code>的表中的记录的<code>status</code>字段设置为’4’，条件是当前<code>status</code>字段的值为’1’或’3’，<code>fail_count</code>字段的值小于3，且满足指定的<code>id</code>条件。这个操作将满足条件的记录的<code>status</code>字段更新为’4’，表示这些记录已经被处理。</p>
<p>2这个UPDATE语句将名为<code>media_process</code>的表中的记录的<code>count</code>字段递增1，同时将<code>version</code>字段更新为2，条件是当前<code>version</code>字段的值为1。这个操作通常用于对某些记录进行计数或标记，确保在并发情况下不会出现竞态条件</p>
<h2 id="9-分布式事务："><a href="#9-分布式事务：" class="headerlink" title="9.分布式事务："></a>9.分布式事务：</h2><h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>是在单一数据库或数据源上执行的事务操作，它具有ACID特性，适用于单一数据源的业务逻辑。</p>
<ol>
<li><strong>单一数据源</strong>：本地事务发生在单一的数据库或数据源上，所有的数据库操作都在同一个事务中进行。</li>
<li><strong>ACID特性</strong>：本地事务通常遵循ACID（原子性、一致性、隔离性和持久性）特性。这意味着事务要么完全成功，要么完全失败，并且在事务期间数据库保持一致性状态。</li>
<li><strong>事务管理</strong>：在本地事务中，通常需要事务管理器或编程框架（例如JDBC、Hibernate等）来管理事务的开始、提交、回滚和异常处理。</li>
<li><strong>锁定和隔离级别</strong>：本地事务中，可以使用锁定和隔离级别来控制并发访问数据库的方式，以确保事务的隔离性。</li>
<li><strong>性能和吞吐量</strong>：本地事务通常具有较高的性能和吞吐量，因为它们涉及的是单一数据源，没有涉及网络通信或多个系统之间的协调。</li>
<li><strong>适用性</strong>：本地事务适用于那些不需要跨多个数据源或数据库的业务逻辑，例如传统的单体应用程序。</li>
</ol>
<h3 id="分布式事务："><a href="#分布式事务：" class="headerlink" title="分布式事务："></a>分布式事务：</h3><p><img src="/img/fbs.png"></p>
<p>分布式事务是指涉及多个独立的数据源、系统或服务的事务操作。这些数据源、系统或服务可以位于不同的地理位置、运行在不同的计算机或容器中，可能使用不同的技术栈和编程语言。分布式事务的目标是确保在分布式环境下的多个操作能够以事务的方式一起成功或失败，以维护数据的一致性和可靠性。</p>
<ol>
<li><strong>多个参与者</strong>：分布式事务通常涉及多个事务参与者，每个参与者负责管理自己的数据源或系统。</li>
<li><strong>全局事务协调器</strong>：在分布式事务中，需要有一个全局事务协调器（也称为事务管理器或协调者），它负责协调各个参与者的事务操作，确保它们的状态一致。</li>
<li><strong>事务的隔离性</strong>：与本地事务一样，分布式事务也需要遵循ACID特性，包括事务的隔离性，以确保数据一致性。</li>
<li><strong>事务的提交和回滚</strong>：全局事务协调器负责决定是否提交或回滚整个分布式事务，这意味着所有参与者要么都提交成功，要么都回滚失败。</li>
<li><strong>两阶段提交（2PC）</strong>：2PC是一种常见的分布式事务协议，它包括两个阶段：准备阶段（协调者询问参与者是否可以提交事务）和提交阶段（如果准备阶段成功，则协调者通知所有参与者提交事务）。</li>
<li><strong>补偿事务</strong>：在分布式环境中，由于网络故障或参与者故障，可能会发生部分参与者已经提交而另一部分参与者未提交的情况。为了处理这种情况，可以使用补偿事务来回滚已经提交的部分。</li>
<li><strong>幂等性</strong>：为了确保分布式事务的幂等性，操作必须能够多次执行而不会产生不一致的结果。这对于处理重试和失败恢复非常重要。</li>
<li><strong>分布式事务模型</strong>：不同的分布式事务模型（例如XA事务、TCC事务、SAGA事务等）提供不同的机制和适用性，可以根据业务需求选择合适的模型。</li>
<li><strong>性能和复杂性权衡</strong>：分布式事务通常比本地事务更复杂，因为需要处理网络通信、故障恢复和协调多个参与者。因此，需要权衡性能和复杂性</li>
</ol>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p> CAP 定理，CAP 是 Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容忍性）的缩写，</p>
<ol>
<li><strong>一致性（Consistency）</strong>：所有节点在同一时间点看到相同的数据视图。这意味着无论在哪个节点上进行读取操作，都应该获得最新的数据，并且写入操作应该立即反映在所有节点上。</li>
<li><strong>可用性（Availability）</strong>：每个请求都必须得到响应，无论它是否成功。即使系统的一部分节点故障，仍然需要继续提供服务。</li>
<li><strong>分区容忍性（Partition tolerance）</strong>：系统可以在网络分区或节点故障的情况下继续工作。分区容忍性意味着系统的某些部分无法与其他部分通信，但仍然可以继续运行。</li>
</ol>
<p>只能满足AP或CP</p>
<ol>
<li><p><strong>CP（一致性和分区容忍性）</strong>：如果系统选择了 CP，这意味着在面临网络分区时，系统会牺牲可用性以保持数据的一致性。这意味着系统可能在分区发生时停止接受新的请求，以确保数据的一致性。</p>
<p><em><strong>例如 ： 银行转账，开户操作</strong></em></p>
</li>
<li><p><strong>AP（可用性和分区容忍性）</strong>：如果系统选择了 AP，这意味着在面临网络分区时，系统会牺牲一致性以保持可用性。这意味着系统可能在分区发生时继续提供服务，但数据可能会处于不一致状态，直到分区恢复。</p>
</li>
</ol>
<p>​		<em><strong>例如：订单退款，注册送积分，支付短信通知</strong></em></p>
<h3 id="BASE理论："><a href="#BASE理论：" class="headerlink" title="BASE理论："></a>BASE理论：</h3><p>BASE 是一个分布式系统的理论模型，与 ACID（原子性、一致性、隔离性和持久性）相对立。</p>
<ol>
<li><strong>基本可用性（Basic Availability）</strong>：BASE 要求系统在面临故障或分区的情况下仍然能够保持基本的可用性。这意味着系统在一些部分或节点出现故障时，仍然可以继续提供有限的服务。</li>
<li><strong>软状态（Soft State）</strong>：BASE 接受系统在某一时刻的状态可能是不一致的，也就是说，在分布式系统中，一些数据的状态可能因为数据同步延迟或其他原因而有所不同。</li>
<li><strong>最终一致性（Eventually Consistency）</strong>：BASE 强调系统的一致性是最终达到的，而不需要实时保持一致。分布式系统可以在一段时间内处于不一致状态，但最终会收敛到一致状态。</li>
</ol>
<h3 id="分布式事务控制有哪些常用的方式："><a href="#分布式事务控制有哪些常用的方式：" class="headerlink" title="分布式事务控制有哪些常用的方式："></a>分布式事务控制有哪些常用的方式：</h3><ol>
<li><p><strong>实现CP - 一致性和分区容忍性</strong>：</p>
<p>a. <strong>Seata框架基于AT模式实现</strong>：</p>
<ul>
<li>Seata 是一个开源的分布式事务框架，支持多种事务模式，包括AT（原子性事务）。使用AT模式，Seata能够协调多个参与者，以实现分布式事务的一致性和分区容忍性。</li>
<li>AT模式基于两阶段提交（2PC）协议，确保在所有参与者上的操作要么全部提交成功，要么全部回滚失败。这可以实现强一致性。</li>
</ul>
<p>b. <strong>Seata框架基于TCC模式实现</strong>：</p>
<ul>
<li>除了AT模式，Seata还支持TCC（Try-Confirm-Cancel）模式，它通过预备、确认和取消三个阶段来实现分布式事务。TCC模式可以提供更大的灵活性和定制化，以满足特定的业务需求。</li>
</ul>
</li>
<li><p><strong>实现AP - 最终数据一致性</strong>：</p>
<p>a. <strong>使用消息队列通知的方式</strong>：</p>
<ul>
<li>在分布式系统中，可以使用消息队列来实现最终一致性。当需要跨多个数据存储或服务时，将数据更改的通知发布到消息队列，其他系统可以订阅这些通知并在本地进行处理。</li>
<li>为了实现可用性，可以配置消息队列以自动重试通知，直到达到最大失败次数。如果通知在一段时间内无法成功传递，可以进行人工处理。</li>
</ul>
<p>b. <strong>使用任务调度的方案</strong>：</p>
<ul>
<li>另一种实现最终一致性的方法是使用任务调度。例如，定期启动任务调度来将数据从一个数据库同步到其他数据存储或服务，以确保数据一致性。</li>
<li>这种方式通常需要开发者编写和管理同步任务，确保数据按计划同步。</li>
</ul>
</li>
</ol>
<p><img src="/img/fbs1.png"></p>
<p>本地消息表（mq_message表）+任务调度的机制</p>
<p><img src="/img/fbs2.png"></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2023/09/08/redis/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><p>Nosql，非结构化语言,无关联的，非SQL，BASE</p>
<p>键值性：redis，文档：mangodb，列表：HBase；GRaph ：Neo4j</p>
<p>SQL，结构化，关联，SQL查询，ACID</p>
<p>REDIS:远程词典服务器：基于内存的键值型NoSQL数据库</p>
<p>key-value，value支持不同的数据结构</p>
<p>单线程，每个命令具备原子性，</p>
<p>低延迟，速度快，（基于内存，io多路复用，良好的编码）</p>
<p>支持数据持久化</p>
<p>支持主从集群，分片集群</p>
<p>支持多语言客户端</p>
<h2 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h2><table>
<thead>
<tr>
<th>String</th>
<th>hello world</th>
</tr>
</thead>
<tbody><tr>
<td>Hash</td>
<td>{name:”jack”,age:21}</td>
</tr>
<tr>
<td>List</td>
<td>[A-&gt;B-&gt;C-&gt;C]</td>
</tr>
<tr>
<td>Set</td>
<td>{A,B,C}</td>
</tr>
<tr>
<td>SortedSet</td>
<td>{A:1,B:2,C:3}</td>
</tr>
<tr>
<td>GEO</td>
<td>{A:(120.3,30.5)}</td>
</tr>
<tr>
<td>BitMap</td>
<td>0110110101110101011</td>
</tr>
<tr>
<td>HyperLog</td>
<td>0110110101110101011</td>
</tr>
</tbody></table>
<h2 id="通用命令："><a href="#通用命令：" class="headerlink" title="通用命令："></a>通用命令：</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>KEYS</td>
<td>查看符合模板的所有key，不建议在生产环境使用</td>
<td><code>KEYS mypattern*</code></td>
</tr>
<tr>
<td>DEL</td>
<td>删除一个指定的key</td>
<td><code>DEL mykey</code></td>
</tr>
<tr>
<td>EXISTS</td>
<td>判断key是否存在</td>
<td><code>EXISTS mykey</code></td>
</tr>
<tr>
<td>EXPIRE</td>
<td>给一个key设置有效期，到期该key会自动删除</td>
<td><code>EXPIRE mykey 3600</code></td>
</tr>
<tr>
<td>TTL</td>
<td>查看key的剩余有效时间</td>
<td><code>TTL mykey</code></td>
</tr>
</tbody></table>
<h3 id="String"><a href="#String" class="headerlink" title="String:"></a>String:</h3><p>字符串类型，可分为3类：</p>
<p>string:普通字符串 hello world</p>
<p>int: 整数，自增自减 10 </p>
<p>float:浮点数，自增自减 92.2</p>
<p>底层都是字节数组，编码方式不同，最大空间：512m</p>
<h4 id="常见命令："><a href="#常见命令：" class="headerlink" title="常见命令："></a>常见命令：</h4><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>SET</td>
<td>添加或修改已存在的String键值对</td>
<td><code>SET mykey &quot;Hello, Redis!&quot;</code></td>
</tr>
<tr>
<td>GET</td>
<td>根据key获取对应的value</td>
<td><code>GET mykey</code></td>
</tr>
<tr>
<td>MSET</td>
<td>批量插入键值对</td>
<td><code>MSET key1 value1 key2 value2 key3 value3</code></td>
</tr>
<tr>
<td>MGET</td>
<td>根据key，批量获取value</td>
<td><code>MGET key1 key2 key3</code></td>
</tr>
<tr>
<td>INCR</td>
<td>让整形key自增1</td>
<td><code>INCR mycounter</code></td>
</tr>
<tr>
<td>INCRBY</td>
<td>让整形key按规定步长自增</td>
<td><code>INCRBY mycounter 5</code></td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td>让浮点型key按规定步长自增</td>
<td><code>INCRBYFLOAT myfloat 0.5</code></td>
</tr>
<tr>
<td>SETNX</td>
<td>添加键值对，前提是不存在</td>
<td><code>SETNX uniquekey &quot;This is a unique value&quot;</code></td>
</tr>
<tr>
<td>SETEX</td>
<td>添加键值对并指定有效期</td>
<td><code>SETEX timedkey 3600 &quot;This will expire in 1 hour&quot;</code></td>
</tr>
</tbody></table>
<h3 id="key的层级结构："><a href="#key的层级结构：" class="headerlink" title="key的层级结构："></a>key的层级结构：</h3><p>Redis中的key允许多个单词形成层级结构，多个单词之间:隔开，例如 项目名:业务名:类型:id</p>
<p>举例子：若value是java对象，则可以将对象序列化为JSON字符串后存储。</p>
<table>
<thead>
<tr>
<th>KEY</th>
<th>VALUE:</th>
</tr>
</thead>
<tbody><tr>
<td>heima:user:1</td>
<td>{“id”:1,”name”:”jack”,”age”:21}</td>
</tr>
<tr>
<td>heima:product:1</td>
<td>{“id”:1,”name”:”oneplus8T”,”price”:2599}</td>
</tr>
</tbody></table>
<h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型:"></a>Hash类型:</h3><p>散列，其value是一个无序字典，类似java中的HashMap结构</p>
<p>相对于String转化为JSON字符串存储，当需要修改对象的某个字段很不方便</p>
<p>Hash结构可以将对象的每个字段独立存储，可针对单个字段做CRUD</p>
<table>
<thead>
<tr>
<th>KEY</th>
<th>VALUE</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>field</td>
<td>value</td>
</tr>
<tr>
<td>heima:user:1</td>
<td>name</td>
<td>jack</td>
</tr>
<tr>
<td></td>
<td>age</td>
<td>21</td>
</tr>
<tr>
<td>heima:user:2</td>
<td>name</td>
<td>Rose</td>
</tr>
<tr>
<td></td>
<td>age</td>
<td>18</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>HSET</td>
<td>设置哈希表字段和值</td>
<td><code>HSET heima:user:1 name jack</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>HSET heima:user:1 age 21</code></td>
</tr>
<tr>
<td>HGET</td>
<td>获取哈希表中指定字段的值</td>
<td><code>HGET heima:user:1 name</code></td>
</tr>
<tr>
<td>HMGET</td>
<td>批量获取哈希表中多个字段的值</td>
<td><code>HMGET heima:user:1 name age heima:user:2 name age</code></td>
</tr>
<tr>
<td>HDEL</td>
<td>删除哈希表中的一个或多个字段</td>
<td><code>HDEL heima:user:1 age</code></td>
</tr>
<tr>
<td>HGETALL</td>
<td>获取哈希表中所有字段和值</td>
<td><code>HGETALL heima:user:1</code></td>
</tr>
<tr>
<td>HINCRBY</td>
<td>为哈希表字段增加整数值</td>
<td><code>HINCRBY heima:user:1 age 5</code></td>
</tr>
<tr>
<td>HINCRBYFLOAT</td>
<td>为哈希表字段增加浮点数值</td>
<td><code>HINCRBYFLOAT heima:user:1 age 0.5</code></td>
</tr>
<tr>
<td>HEXISTS</td>
<td>判断哈希表中是否存在指定字段</td>
<td><code>HEXISTS heima:user:1 name</code></td>
</tr>
<tr>
<td>HKEYS</td>
<td>获取哈希表中的所有字段名</td>
<td><code>HKEYS heima:user:1</code></td>
</tr>
<tr>
<td>HVALS</td>
<td>获取哈希表中的所有字段值</td>
<td><code>HVALS heima:user:1</code></td>
</tr>
</tbody></table>
<h3 id="List类型："><a href="#List类型：" class="headerlink" title="List类型："></a>List类型：</h3><p>和java的LinkedList类似，常用来存储一个有序数据，可以看做一个双向链表结构，可正向和反向检索。</p>
<p><em><strong>Redis的List类型通常用于存储具有时间顺序的数据，例如日志、消息队列等。</strong></em></p>
<p>特征：</p>
<ol>
<li><strong>有序</strong>：Redis List是有序的数据结构，它按照元素插入的顺序来存储数据。你可以在列表的两端执行插入和删除操作。</li>
<li><strong>元素可以重复</strong>：与集合（Set）不同，Redis List允许元素重复出现。这意味着你可以在同一个List中多次存储相同的元素。</li>
<li><strong>插入和删除快</strong>：Redis List对于在列表的两端执行插入和删除操作非常快速。这是因为它是一个双向链表结构，使得在列表的头部或尾部添加或删除元素的时间复杂度是O(1)。</li>
<li><strong>查询速度一般</strong>：虽然Redis List对于插入和删除操作非常高效，但对于随机访问（根据索引或值查找元素）而言，速度较慢。这是因为在链表中进行随机访问需要遍历链表，时间复杂度是O(n)。</li>
</ol>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>LPUSH</td>
<td>在列表的头部插入一个或多个元素</td>
<td><code>LPUSH mylist value1 value2</code></td>
</tr>
<tr>
<td>RPUSH</td>
<td>在列表的尾部插入一个或多个元素</td>
<td><code>RPUSH mylist value3 value4</code></td>
</tr>
<tr>
<td>LPOP</td>
<td>移除并返回列表的头部元素</td>
<td><code>LPOP mylist</code></td>
</tr>
<tr>
<td>RPOP</td>
<td>移除并返回列表的尾部元素</td>
<td><code>RPOP mylist</code></td>
</tr>
<tr>
<td>LINDEX</td>
<td>根据索引获取列表中的元素</td>
<td><code>LINDEX mylist 0</code></td>
</tr>
<tr>
<td>LRANGE</td>
<td>获取列表中指定范围内的元素</td>
<td><code>LRANGE mylist 0 2</code></td>
</tr>
<tr>
<td>LLEN</td>
<td>获取列表的长度</td>
<td><code>LLEN mylist</code></td>
</tr>
<tr>
<td>BLPOP</td>
<td>从左边（头部）阻塞弹出元素。</td>
<td>BLPOP mylist 10</td>
</tr>
<tr>
<td>BRPOP</td>
<td>从右边（尾部）阻塞弹出元素。</td>
<td>BLPOP mylist 10</td>
</tr>
</tbody></table>
<h3 id="Set类型："><a href="#Set类型：" class="headerlink" title="Set类型："></a>Set类型：</h3><p>和java的HashSet类似，value为null的HashMap，因此也是一个Hash表</p>
<p><em><strong>Redis的Set类型通常用于存储不重复的元素集合，例如用户的标签、喜好、关注列表等。</strong></em></p>
<p>特征：</p>
<ol>
<li><strong>无序</strong>：Redis Set是无序的，这意味着元素在集合中的存储顺序不是固定的，与元素的插入顺序无关。</li>
<li><strong>元素不可重复</strong>：与List不同，Set类型不允许重复元素，每个元素在集合中只能出现一次。</li>
<li><strong>查找快</strong>：Redis Set内部是通过哈希表实现的，因此查找元素的速度非常快，时间复杂度是O(1)。</li>
<li><strong>支持并集、差集和交集功能</strong>：Redis提供了一系列用于集合操作的命令，如并集（<code>SUNION</code>）、差集（<code>SDIFF</code>）和交集（<code>SINTER</code>）等，这些命令可以用于对多个集合进行操作，如合并、比较和筛选等</li>
</ol>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>SADD</td>
<td>向集合中添加一个或多个元素</td>
<td><code>SADD myset member1 member2</code></td>
</tr>
<tr>
<td>SREM</td>
<td>从集合中移除一个或多个元素</td>
<td><code>SREM myset member1</code></td>
</tr>
<tr>
<td>SMEMBERS</td>
<td>获取集合中的所有元素</td>
<td><code>SMEMBERS myset</code></td>
</tr>
<tr>
<td>SISMEMBER</td>
<td>检查元素是否存在于集合中</td>
<td><code>SISMEMBER myset member1</code></td>
</tr>
<tr>
<td>SCARD</td>
<td>获取集合的基数（元素数量）</td>
<td><code>SCARD myset</code></td>
</tr>
<tr>
<td>SUNION</td>
<td>计算多个集合的并集</td>
<td><code>SUNION set1 set2 set3</code></td>
</tr>
<tr>
<td>SDIFF</td>
<td>计算多个集合的差集</td>
<td><code>SDIFF set1 set2</code></td>
</tr>
<tr>
<td>SINTER</td>
<td>计算多个集合的交集</td>
<td><code>SINTER set1 set2</code></td>
</tr>
</tbody></table>
<h3 id="SortedSet类型："><a href="#SortedSet类型：" class="headerlink" title="SortedSet类型："></a>SortedSet类型：</h3><p>可排序的Set集合，和java的TreeSet类似，但TS底层是红黑树，而SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加Hash表</p>
<p>特征:</p>
<ol>
<li><strong>可排序</strong>：Redis Sorted Set是一个可排序的集合，它根据每个元素的分数（score）属性对元素进行排序。这允许你按照特定顺序访问元素，无论是升序还是降序。</li>
<li><strong>元素不重复</strong>：与Set类型类似，Sorted Set中的元素是不重复的，每个元素只能出现一次。</li>
<li><strong>查询速度快</strong>：Redis Sorted Set的底层实现是一个跳表（Skip List）和一个哈希表（Hash Table）的结合，这使得查找元素的速度非常快，时间复杂度是O(log(N))。</li>
<li><strong>每个元素都有一个分数（score）属性</strong>：与普通Set不同，Sorted Set中的每个元素都关联有一个分数，这个分数可以是任意浮点数值，用于排序和比较元素。</li>
</ol>
<p><em><strong>Redis的Sorted Set常用于需要按分数排序的场景，如排行榜、计分系统、优先级队列等。</strong></em></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>ZADD</td>
<td>向有序集合中添加一个或多个元素，每个元素关联一个分数</td>
<td><code>ZADD myzset 1 &quot;member1&quot; 2 &quot;member2&quot;</code></td>
</tr>
<tr>
<td>ZREM</td>
<td>从有序集合中移除一个或多个元素</td>
<td><code>ZREM myzset &quot;member1&quot;</code></td>
</tr>
<tr>
<td>ZRANGE</td>
<td>按照元素的分数范围获取元素</td>
<td><code>ZRANGE myzset 0 -1</code> (获取所有元素)</td>
</tr>
<tr>
<td>ZRANK</td>
<td>按照元素的分数范围获取元素，以逆序返回</td>
<td><code>ZRANK myzset member1</code> (获取元素对应的排名)</td>
</tr>
<tr>
<td>ZSCORE</td>
<td>获取指定元素的分数</td>
<td><code>ZSCORE myzset &quot;member1&quot;</code></td>
</tr>
<tr>
<td>ZINCRBY</td>
<td>为指定元素的分数增加指定值</td>
<td><code>ZINCRBY myzset 2 &quot;member1&quot;</code> (增加 member1 的分数 by 2)</td>
</tr>
<tr>
<td>ZCARD</td>
<td>获取有序集合的基数（元素数量）</td>
<td><code>ZCARD myzset</code> (获取有序集合中元素的数量)</td>
</tr>
<tr>
<td>ZCOUNT</td>
<td>统计分数在指定范围内的元素数量</td>
<td><code>ZCOUNT myzset 1 3</code> (统计分数在 1 到 3 范围内的元素数量)</td>
</tr>
<tr>
<td>ZREVRANGEBYSCORE</td>
<td>按照元素的分数范围获取元素，以逆序返回</td>
<td><code>ZREVRANGEBYSCORE myzset max min</code> (逆序获取指定分数范围内的元素)</td>
</tr>
<tr>
<td>ZDIFF</td>
<td>计算多个有序集合的差集</td>
<td><code>ZDIFF output-key input-key1 input-key2</code> (计算 input-key1 和 input-key2 的差集并将结果存储在 output-key 中)</td>
</tr>
<tr>
<td>ZINTER</td>
<td>计算多个有序集合的交集</td>
<td><code>ZINTER output-key input-key1 input-key2 WEIGHTS 2 3</code> (计算 input-key1 和 input-key2 的交集并指定权重)</td>
</tr>
<tr>
<td>ZUNION</td>
<td>计算多个有序集合的并集</td>
<td><code>ZUNION output-key input-key1 input-key2 AGGREGATE SUM</code> (计算 input-key1 和 input-key2 的并集并指定聚合方式)</td>
</tr>
</tbody></table>
<h2 id="Java客户端："><a href="#Java客户端：" class="headerlink" title="Java客户端："></a>Java客户端：</h2><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis:"></a>Jedis:</h3><p>实例线程是不安全的，多线程环境下需要基于连接池来使用</p>
<ol>
<li><p><strong>连接到Redis服务器</strong>：使用Jedis，你可以轻松地连接到Redis服务器。你需要提供Redis服务器的主机名（或IP地址）和端口号。</p>
</li>
<li><p><strong>执行Redis操作</strong>：Jedis库允许你执行各种Redis操作，包括字符串、列表、集合、有序集合、哈希表等。你可以使用Jedis提供的方法来执行这些操作。</p>
</li>
<li><p><strong>异常处理</strong>：Jedis处理了与Redis连接和操作相关的异常，这使得在Java应用程序中与Redis交互更加稳定。</p>
</li>
<li><p><strong>连接池</strong>：Jedis还提供了连接池的支持，这有助于在多个线程之间共享Redis连接，并且可以有效地管理和重用连接。</p>
</li>
<li><p><strong>支持Redis事务</strong>：Jedis支持Redis事务，你可以使用<code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code>等命令来执行事务操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Jedis客户端连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行Redis操作</span></span><br><span class="line">        jedis.set(<span class="string">&quot;mykey&quot;</span>, <span class="string">&quot;Hello, Redis!&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;mykey&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Value of &#x27;mykey&#x27;: &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭Jedis连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p> <em><strong>Jedis连接池</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisPoolExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建连接池配置</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">10</span>); <span class="comment">// 设置最大连接数</span></span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">5</span>);   <span class="comment">// 设置最大空闲连接数</span></span><br><span class="line">        poolConfig.setMinIdle(<span class="number">1</span>);   <span class="comment">// 设置最小空闲连接数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接池</span></span><br><span class="line">        <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig, <span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从连接池获取连接</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource()) &#123;</span><br><span class="line">            <span class="comment">// 执行Redis操作</span></span><br><span class="line">            jedis.set(<span class="string">&quot;mykey&quot;</span>, <span class="string">&quot;Hello, Jedis Pool!&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;mykey&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Value of &#x27;mykey&#x27;: &quot;</span> + value);</span><br><span class="line">        &#125; <span class="comment">// 连接会在此处自动关闭并返回连接池</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接池</span></span><br><span class="line">        jedisPool.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce:"></a>Lettuce:</h3><p> Lettuce是一个Java编写的高性能、异步的Redis客户端库，用于与Redis服务器进行交互。它被设计成异步和非阻塞的，允许开发者在高并发应用中高效地与Redis数据库进行通信。</p>
<ol>
<li><p><strong>异步和非阻塞</strong>：Lettuce是一个异步、非阻塞的Redis客户端，它允许你执行Redis操作而不会阻塞应用程序的执行线程。这对于高并发的应用程序非常有用，因为它可以减少线程等待时间，提高性能。</p>
</li>
<li><p><strong>连接池</strong>：Lettuce内置了连接池支持，这使得在多个线程之间共享Redis连接变得容易，同时能够有效地管理和重用连接。</p>
</li>
<li><p><strong>集成Redis Sentinel和Cluster</strong>：Lettuce可以轻松地与Redis Sentinel和Redis Cluster一起工作，支持高可用性和分布式部署。</p>
</li>
<li><p><strong>支持SSL&#x2F;TLS</strong>：Lettuce支持通过SSL&#x2F;TLS加密与Redis服务器之间的通信，提供数据安全性。</p>
</li>
<li><p><strong>Reactive编程模型</strong>：Lettuce还提供了对响应式编程模型的支持，可以与Spring Framework的Project Reactor等库集成，允许开发者编写异步和响应式的Redis操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.lettuce.core.api.StatefulRedisConnection;</span><br><span class="line"><span class="keyword">import</span> io.lettuce.core.api.sync.RedisCommands;</span><br><span class="line"><span class="keyword">import</span> io.lettuce.core.RedisClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LettuceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建RedisClient</span></span><br><span class="line">        <span class="type">RedisClient</span> <span class="variable">redisClient</span> <span class="operator">=</span> RedisClient.create(<span class="string">&quot;redis://localhost:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        StatefulRedisConnection&lt;String, String&gt; connection = redisClient.connect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取同步的Redis命令对象</span></span><br><span class="line">        RedisCommands&lt;String, String&gt; syncCommands = connection.sync();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行Redis操作</span></span><br><span class="line">        syncCommands.set(<span class="string">&quot;mykey&quot;</span>, <span class="string">&quot;Hello, Lettuce!&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> syncCommands.get(<span class="string">&quot;mykey&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Value of &#x27;mykey&#x27;: &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接和客户端</span></span><br><span class="line">        connection.close();</span><br><span class="line">        redisClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson:"></a>Redisson:</h3><p>Redisson是一个基于Java的Redis客户端和分布式应用框架，它提供了一系列高级功能和工具，使得在Java应用程序中与Redis进行交互和利用分布式特性变得更加容易。</p>
<ol>
<li><strong>分布式数据结构</strong>：Redisson提供了丰富的分布式数据结构，如分布式集合、分布式映射、分布式队列、分布式锁等。这些数据结构可以直接在Java应用中使用，无需手动编写复杂的分布式代码。</li>
<li><strong>Redis连接池</strong>：Redisson内置了连接池管理，使得连接到Redis服务器更加高效，可以有效地重用和管理连接。5</li>
<li><strong>分布式锁和信号量</strong>：Redisson提供了分布式锁和信号量的支持，使得多个应用程序实例可以协调和同步访问共享资源。</li>
<li><strong>发布&#x2F;订阅</strong>：Redisson支持发布&#x2F;订阅模式，允许应用程序通过Redis进行实时消息传递和事件通知。</li>
<li><strong>集成Spring</strong>：Redisson可以轻松集成到Spring Framework中，以便更容易地与Spring应用程序一起使用。</li>
<li><strong>Redis Sentinel和Redis Cluster支持</strong>：Redisson支持与Redis Sentinel和Redis Cluster一起工作，实现高可用性和分布式部署。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Redisson配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://localhost:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Redisson客户端连接</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行Redis操作</span></span><br><span class="line">        redisson.getBucket(<span class="string">&quot;mykey&quot;</span>).set(<span class="string">&quot;Hello, Redisson!&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redisson.getBucket(<span class="string">&quot;mykey&quot;</span>).get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Value of &#x27;mykey&#x27;: &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭Redisson客户端连接</span></span><br><span class="line">        redisson.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis:"></a>SpringDataRedis:</h3><p>SpringData是Spring中数据操作的模块，包含多各种数据库的集成. Spring Data Redis是Spring框架的一部分，它提供了对Redis数据库的集成和支持。</p>
<ol>
<li><strong>注解驱动</strong>：Spring Data Redis提供了一组注解，可以用于在Java类中定义与Redis数据存储相关的操作。这些注解包括<code>@RedisHash</code>、<code>@RedisSet</code>、<code>@RedisList</code>等，可以帮助你将Java对象映射到Redis数据结构。</li>
<li><strong>Redis模板</strong>：Spring Data Redis引入了<code>RedisTemplate</code>类，它提供了一种便捷的方式来执行Redis操作，如数据存储、检索、删除等。你可以使用<code>RedisTemplate</code>来与Redis数据库进行交互。</li>
<li><strong>连接池管理</strong>：Spring Data Redis可以与连接池管理集成，以确保有效地管理和重用Redis连接。你可以配置连接池的参数，以满足性能和资源管理的需求。</li>
<li><strong>事务支持</strong>：Spring Data Redis提供了事务支持，允许你在多个Redis操作中创建事务。你可以使用<code>@Transactional</code>注解来管理Redis事务。</li>
<li><strong>Spring Boot集成</strong>：Spring Data Redis与Spring Boot紧密集成，使得在Spring Boot应用程序中使用Redis变得更加简单。Spring Boot自动配置了Redis连接池和<code>RedisTemplate</code>，你只需添加相关依赖即可。</li>
</ol>
<h4 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h4><p><code>RedisTemplate</code>是Spring Data Redis中的一个关键组件，它是一个通用的Redis操作模板，用于执行各种Redis操作，如数据存储、检索、删除等。<code>RedisTemplate</code>提供了一种便捷的方式来与Redis数据库进行交互，同时隐藏了与底层Redis客户端库的复杂性。</p>
<ol>
<li><strong>数据类型支持</strong>：<code>RedisTemplate</code>支持多种Redis数据类型，包括字符串、列表、集合、有序集合、散列表等。你可以根据需要选择适当的方法来执行不同类型的操作。</li>
<li><strong>序列化和反序列化</strong>：<code>RedisTemplate</code>负责将Java对象序列化为Redis支持的格式，并在从Redis检索数据时进行反序列化。你可以配置使用的序列化器，或者使用默认的序列化器。</li>
<li><strong>连接池管理</strong>：<code>RedisTemplate</code>可以与连接池管理集成，以确保有效地管理和重用Redis连接。你可以配置连接池的参数，以满足性能和资源管理的需求。</li>
<li><strong>事务支持</strong>：<code>RedisTemplate</code>提供了事务支持，允许你在多个Redis操作中创建事务。你可以使用<code>multi()</code>和<code>exec()</code>方法来开启和提交Redis事务。</li>
<li><strong>Pipeline支持</strong>：<code>RedisTemplate</code>支持Redis的Pipeline操作，允许你一次发送多个命令并一次接收多个响应，以提高性能。</li>
</ol>
<p><em><strong>默认的JDK字节序列化数据</strong></em></p>
<p>可读性差 二进制的字节数据</p>
<p>内存占用大 看起来臃肿</p>
<h4 id="自定义RedisTemplate的序列化"><a href="#自定义RedisTemplate的序列化" class="headerlink" title="自定义RedisTemplate的序列化"></a>自定义RedisTemplate的序列化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> </span><br><span class="line">            							<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate:"></a>StringRedisTemplate:</h4><p>统一使用String序列化器，要求只能存储String类型的key和Value</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;verify:phone:13600527634&quot;</span>, <span class="string">&quot;124143&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">// 手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">        <span class="comment">// 手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇:"></a>实战篇:</h2><h3 id="黑马点评："><a href="#黑马点评：" class="headerlink" title="黑马点评："></a>黑马点评：</h3><h4 id="短信登录："><a href="#短信登录：" class="headerlink" title="短信登录："></a>短信登录：</h4><h5 id="1-Redis的共享session应用"><a href="#1-Redis的共享session应用" class="headerlink" title="1.Redis的共享session应用"></a>1.Redis的共享session应用</h5><p>1.发送验证码到session</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 发送手机验证码</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@PostMapping(&quot;code&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone, HttpSession session)</span> &#123;</span><br><span class="line">      <span class="comment">// TODO 发送短信验证码并保存验证码</span></span><br><span class="line">          <span class="keyword">return</span> userService.sendCode(phone,session);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">     <span class="comment">//1.校验手机号</span></span><br><span class="line">     <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">         <span class="comment">//2.no，报错</span></span><br><span class="line">         <span class="keyword">return</span> Result.fail(<span class="string">&quot;phone error&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//3验证码</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">     <span class="comment">//4存到session中</span></span><br><span class="line">     session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">     <span class="comment">//发送验证码</span></span><br><span class="line">     log.debug(<span class="string">&quot;send successful! code:&#123;&#125;&quot;</span>,code);</span><br><span class="line">     <span class="keyword">return</span>  Result.ok();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>2.phone+code登录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loginForm 登录参数，包含手机号、验证码；或者手机号、密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginFormDTO loginForm, HttpSession session)</span>&#123;</span><br><span class="line">    <span class="comment">// TODO 实现登录功能</span></span><br><span class="line">    <span class="keyword">return</span> userService.login(loginForm, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">       <span class="comment">//1.校验手机号</span></span><br><span class="line">       <span class="keyword">if</span>(RegexUtils.isPhoneInvalid( phone))&#123;</span><br><span class="line">           <span class="comment">//2.no，报错</span></span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;phone error&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//校验验证码</span></span><br><span class="line">       <span class="type">Object</span> <span class="variable">cachecode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">       <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">       <span class="keyword">if</span>(cachecode == <span class="literal">null</span> || !cachecode.toString().equals(code))&#123;</span><br><span class="line">           <span class="comment">//报错，</span></span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;code error&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//查询，</span></span><br><span class="line">       <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>,phone).one();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//登录或注册</span></span><br><span class="line">       <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">           user = createUserWithPhone(phone);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//save to session</span></span><br><span class="line">       session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtil.copyProperties(user,UserDTO.class));</span><br><span class="line">       <span class="keyword">return</span> Result.ok();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//save user to DB</span></span><br><span class="line"> <span class="keyword">private</span> User <span class="title function_">createUserWithPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">         <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">         user.setPhone(phone);</span><br><span class="line">         user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="number">7</span>));</span><br><span class="line">         save(user);</span><br><span class="line">         <span class="keyword">return</span> user;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>3.登录校验拦截器</p>
<p>拦截需要请求的路径，根据实际生产情况来设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"><span class="comment">//登录拦截器，当需要访问指定端口时控制拦截</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@creats</span> 2023-09-12 20:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//获取用户</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//不存在，拦截</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在，保存在ThreadLocal中</span></span><br><span class="line">        UserHolder.saveUser((UserDTO)user);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截器完成后，获取用户信息，</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//移除用户</span></span><br><span class="line">            UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在拦截器，实现从cookie中获取session中的用户信息，拦截用户信息，判断是否存在，保存到TreadLocal中，</p>
<p>4.集群的session共享问题:</p>
<p>多台TOmcat并不共享Session,会造成数据丢失.</p>
<h5 id="2-基于Redis实现短信登录"><a href="#2-基于Redis实现短信登录" class="headerlink" title="2.基于Redis实现短信登录"></a>2.基于Redis实现短信登录</h5><p>修改之前的从session中获取改为从redis中获取，保存到redis之后，在设置一个token来获取用户信息</p>
<p>选择合适的数据结构来存储到redis中并设置合理的有效期,类的属性不符合可以redis的标准，可以转化，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *；</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-12-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate StringredisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">//1.校验手机号</span></span><br><span class="line">        <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">            <span class="comment">//2.no，报错</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;phone error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//4存到session中</span></span><br><span class="line"><span class="comment">//        session.setAttribute(&quot;code&quot;,code);</span></span><br><span class="line">        <span class="comment">//保存到redis中,        //设置有效期</span></span><br><span class="line">        StringredisTemplate.opsForValue().set( LOGIN_CODE_KEY +phone,code,LOGIN_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//发送验证码</span></span><br><span class="line">        log.debug(<span class="string">&quot;send successful! code:&#123;&#125;&quot;</span>,code);</span><br><span class="line">        <span class="keyword">return</span>  Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">        <span class="comment">//1.校验手机号</span></span><br><span class="line">        <span class="keyword">if</span>(RegexUtils.isPhoneInvalid( phone))&#123;</span><br><span class="line">            <span class="comment">//2.no，报错</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;phone error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//校验验证码</span></span><br><span class="line"><span class="comment">//        Object cachecode = session.getAttribute(&quot;code&quot;);</span></span><br><span class="line">        <span class="type">String</span>  <span class="variable">cachecode</span> <span class="operator">=</span> StringredisTemplate.opsForValue().get( LOGIN_CODE_KEY + phone);</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">        <span class="keyword">if</span>(cachecode == <span class="literal">null</span> || !cachecode.equals(code))&#123;</span><br><span class="line">            <span class="comment">//报错，</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;code error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询，</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>,phone).one();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//登录或注册</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            user = createUserWithPhone(phone);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//save to session</span></span><br><span class="line"><span class="comment">//        session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user,UserDTO.class));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.token 2. Hash 3.save 4.timelimite 4.back to head</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span>   UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDto</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">        <span class="comment">//map 中的id是long类型的，但是使用的是stringredistemplate,需要转换</span></span><br><span class="line">        Map&lt;String,Object&gt; userMap =  BeanUtil.beanToMap(userDto,<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                CopyOptions.create().setIgnoreNullValue(<span class="literal">true</span>).setFieldValueEditor((fieldName,fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">        StringredisTemplate.opsForHash().putAll(LOGIN_USER_KEY + token,userMap);</span><br><span class="line">        StringredisTemplate.expire(LOGIN_USER_KEY + token, LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//save user to DB</span></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">createUserWithPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setPhone(phone);</span><br><span class="line">            user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="number">7</span>));</span><br><span class="line">            save(user);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="解决不登录的用户浏览页面，但是time-out时已经登录过用户的信息会被清除"><a href="#解决不登录的用户浏览页面，但是time-out时已经登录过用户的信息会被清除" class="headerlink" title="解决不登录的用户浏览页面，但是time out时已经登录过用户的信息会被清除"></a><strong>解决不登录的用户浏览页面，但是time out时已经登录过用户的信息会被清除</strong></h6><p>添加另外一个新的拦截器，按先后顺序执行,第一个拦截器不管登录与否都刷新token，第二个拦截器根据ThreadLocal，肯定包含用户信息，因为第一个拦截器已经实现获取用户的功能了，最后设置一下拦截器的执行顺序即可</p>
<p>要实现的功能就是，当用户登录之后，他的token是有效期的，过期需要重新登陆，但是这时候如果用户还没有浏览完毕就会严重影响用户的体验，所以就是实现在登录浏览的期间只要用户有操作就不断的刷新token的有效期，让其一直保持在有效期的范围内，就不会token失效而需要重新登陆</p>
<p>第一个拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@creats</span> 2023-09-12 20:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflashLoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate RedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReflashLoginInterceptor</span><span class="params">(StringRedisTemplate RedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.RedisTemplate = RedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取session</span></span><br><span class="line"><span class="comment">//        HttpSession session = request.getSession();</span></span><br><span class="line">        <span class="comment">//get token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isBlank(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取用户</span></span><br><span class="line"><span class="comment">//        Object user = session.getAttribute(&quot;user&quot;);</span></span><br><span class="line">       Map&lt;Object,Object&gt; map = RedisTemplate.opsForHash().entries(LOGIN_USER_KEY + token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(map.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//不存在，拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将查询的HashMap转为UserDto对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDto</span> <span class="operator">=</span>  BeanUtil.fillBeanWithMap(map,<span class="keyword">new</span> <span class="title class_">UserDTO</span>(),<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//存在，保存在ThreadLocal中</span></span><br><span class="line">        UserHolder.saveUser(userDto);</span><br><span class="line">        <span class="comment">//刷新token有效期</span></span><br><span class="line">        RedisTemplate.expire(LOGIN_USER_KEY + token,LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截器完成后，获取用户信息，</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//移除用户</span></span><br><span class="line">            UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二个拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.hmdp.utils.RedisConstants.LOGIN_USER_KEY;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.hmdp.utils.RedisConstants.LOGIN_USER_TTL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@creats</span> 2023-09-12 20:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断ThreadLocal中是否包含用户上</span></span><br><span class="line">        <span class="keyword">if</span>(UserHolder.getUser() == <span class="literal">null</span>)&#123;</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已存在用户，放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置拦截器的执行顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">ReflashLoginInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="商户查询缓存：缓存雪崩，击穿，穿透，"><a href="#商户查询缓存：缓存雪崩，击穿，穿透，" class="headerlink" title="商户查询缓存：缓存雪崩，击穿，穿透，"></a>商户查询缓存：缓存雪崩，击穿，穿透，</h4><p>缓存：数据交换的缓冲区，Cache，存储数据的临时地，读写性能高</p>
<ol>
<li><strong>浏览器缓存：</strong> 浏览器缓存是最基本的缓存层，在用户访问你的网站时，浏览器会将页面资源（如图片、样式表、JavaScript文件）缓存到本地，以便下次访问时可以更快地加载。你可以通过设置HTTP响应头来控制浏览器缓存的行为，例如设置<code>Cache-Control</code>和<code>Expires</code>头。</li>
<li><strong>数据库查询缓存：</strong> 如果你的应用使用数据库，可以使用数据库查询缓存来减少对数据库的查询次数。许多数据库系统（如MySQL和Redis）都支持查询结果缓存，可以根据查询参数将查询结果缓存到内存中，以便下次查询相同参数时可以直接从缓存中获取。</li>
</ol>
<p>作用：降低后端负载，提高读写效率，降低响应时间</p>
<p>成本：数据一致性，代码维护,运维成本</p>
<p><em><strong>商户信息添加缓存：</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.hmdp.utils.RedisConstants.CACHE_SHOP_KEY;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-12-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShopMapper, Shop&gt; <span class="keyword">implements</span> <span class="title class_">IShopService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span>  StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//从redis查询缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY +id);</span><br><span class="line">        <span class="comment">//是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">           <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span>  JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从数据库</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;shop no exit!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存在写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop));</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><em><strong>店铺信息添加缓存:</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-12-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopTypeServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShopTypeMapper, ShopType&gt; <span class="keyword">implements</span> <span class="title class_">IShopTypeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getlist</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_TYPE_KEY;</span><br><span class="line">        <span class="comment">//1.在redis中间查询</span></span><br><span class="line">        List&lt;String&gt; shopTypeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        shopTypeList = stringRedisTemplate.opsForList().range(key,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//2.判断是否缓存中了</span></span><br><span class="line">        <span class="comment">//3.中了返回</span></span><br><span class="line">        <span class="keyword">if</span>(!shopTypeList.isEmpty())&#123;</span><br><span class="line">            List&lt;ShopType&gt; typeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String s:shopTypeList) &#123;</span><br><span class="line">                <span class="type">ShopType</span> <span class="variable">shopType</span> <span class="operator">=</span> JSONUtil.toBean(s,ShopType.class);</span><br><span class="line">                typeList.add(shopType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(typeList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.没中数据库中查</span></span><br><span class="line">        List&lt;ShopType&gt; typeList = query().orderByAsc(<span class="string">&quot;sort&quot;</span>).list();</span><br><span class="line">        <span class="comment">//5.不存在直接返回错误</span></span><br><span class="line">        <span class="keyword">if</span>(typeList.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不存在分类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(ShopType shopType : typeList)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSONUtil.toJsonStr(shopType);</span><br><span class="line">            shopTypeList.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.存在直接添加进缓存</span></span><br><span class="line">        stringRedisTemplate.opsForList().rightPushAll(key, shopTypeList);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(typeList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="缓存更新策略："><a href="#缓存更新策略：" class="headerlink" title="缓存更新策略："></a>缓存更新策略：</h5><p>内存淘汰：内存不足，自动淘汰部分数据，下次查询更新缓存</p>
<p>超时剔除：expire,TTL,</p>
<p>主动更新：编写业务逻辑，修改数据库同时更新缓存</p>
<h5 id="主动更新实现："><a href="#主动更新实现：" class="headerlink" title="主动更新实现："></a>主动更新实现：</h5><p>Read&#x2F;Write through Pattern ： 缓存与数据库整合一个服务，由服务来维护一致性</p>
<p>Write Behind Cache Pattern:调用者操作缓存，由其他线程的异步将缓存数据持久化到数据库，保证最终一致性</p>
<p>Cache Aside Pattern：由缓存调用者，更新数据库更新缓存</p>
<p>1.删除缓存还是更新缓存</p>
<p>更新缓存：每次更新数据库都行更新缓存，无效的写操作较多</p>
<p>删除缓存：更新数据库让缓存失效，当有查询时在更新缓存</p>
<p>2.如何保障缓存和数据库的操作同时成功或失败</p>
<p>单体系统：将缓存和数据库操作放在一个事务</p>
<p>分布式系统：利用TCC等分布式事务</p>
<p>3先操作缓存还是数据库</p>
<p><img src="/img/cache.png"></p>
<p>先操作数据库，再删除缓存</p>
<h5 id="给查询shop添加超时剔除和主动更新："><a href="#给查询shop添加超时剔除和主动更新：" class="headerlink" title="给查询shop添加超时剔除和主动更新："></a>给查询shop添加超时剔除和主动更新：</h5><p>加了过期时间，修改时先更新数据库，并删除缓存，当下次重新查询的时候会重新插入缓存,添加事务控制@Transactional</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">upDate</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">       <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">       <span class="keyword">if</span>(id == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;id is null&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//更新数据库</span></span><br><span class="line">       updateById(shop);</span><br><span class="line">       <span class="comment">//删除缓存</span></span><br><span class="line">       stringRedisTemplate.delete(CACHE_SHOP_KEY +id);</span><br><span class="line">       <span class="keyword">return</span> Result.ok();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="缓存穿透：数据在缓存和数据库都不存在，缓存永不会生效。此时请求都会打到数据库"><a href="#缓存穿透：数据在缓存和数据库都不存在，缓存永不会生效。此时请求都会打到数据库" class="headerlink" title="缓存穿透：数据在缓存和数据库都不存在，缓存永不会生效。此时请求都会打到数据库"></a>缓存穿透：数据在缓存和数据库都不存在，缓存永不会生效。此时请求都会打到数据库</h5><p>缓存空对象：</p>
<p>进来查缓存，判断缓存是否命中，命中是否为null，null就直接结束，不再去查询数据库，不是b命中后不是null，直接返回shop信息。</p>
<p>若未命中，查询数据库，shop是否存在，存在则写入redis，不存在则将null写入redis</p>
<p><img src="/img/cache3.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span>  StringRedisTemplate stringRedisTemplate;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">      <span class="comment">//从redis查询缓存</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY +id);</span><br><span class="line">      <span class="comment">//是否命中</span></span><br><span class="line">      <span class="keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">              <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span>  JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">              <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//前面已经判断有值的情况，还剩有值但值是空和null两种情况，</span></span><br><span class="line">      <span class="comment">// 再判断命中的是否是null，真的null</span></span><br><span class="line">      <span class="keyword">if</span>(shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> Result.fail(<span class="string">&quot;shop not exit!w&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//从数据库</span></span><br><span class="line">      <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">      <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="comment">//将null写入redis</span></span><br><span class="line">          stringRedisTemplate.opsForValue().set(</span><br><span class="line">                  CACHE_SHOP_KEY + id, <span class="string">&quot;&quot;</span> ,CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;shop no exit!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//存在写入redis</span></span><br><span class="line">      stringRedisTemplate.opsForValue().set(</span><br><span class="line">              CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">      <span class="comment">//返回</span></span><br><span class="line">      <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>布隆过滤：实现较复杂,增强id的复杂度，避免id被猜测的规律，做好数据的基础格式校验，加强用户权限,对热点参数限流</p>
<h5 id="缓存雪崩：同一时段大量的存储key同时失效或者redis服务宕机，导致大量请求到达数据库，带来巨大压力-即未命中redis。"><a href="#缓存雪崩：同一时段大量的存储key同时失效或者redis服务宕机，导致大量请求到达数据库，带来巨大压力-即未命中redis。" class="headerlink" title="缓存雪崩：同一时段大量的存储key同时失效或者redis服务宕机，导致大量请求到达数据库，带来巨大压力,即未命中redis。"></a>缓存雪崩：同一时段大量的存储key同时失效或者redis服务宕机，导致大量请求到达数据库，带来巨大压力,即未命中redis。</h5><p>解决方案：</p>
<p>给不同key的TTl添加随机值</p>
<p>利用redis集群的提高服务的可能性 </p>
<p>给缓存业务添加降级限流策略</p>
<p>给业务添加多级缓存</p>
<h5 id="缓存击穿-：热点key问题，就是一个被高并发访问且缓存创建业务较复杂的key突然失效，无数的请求在瞬间给数据库带来巨大的冲击"><a href="#缓存击穿-：热点key问题，就是一个被高并发访问且缓存创建业务较复杂的key突然失效，无数的请求在瞬间给数据库带来巨大的冲击" class="headerlink" title="缓存击穿 ：热点key问题，就是一个被高并发访问且缓存创建业务较复杂的key突然失效，无数的请求在瞬间给数据库带来巨大的冲击"></a>缓存击穿 ：热点key问题，就是一个被高并发访问且缓存创建业务较复杂的key突然失效，无数的请求在瞬间给数据库带来巨大的冲击</h5><p><em><strong>互斥锁</strong></em>:线程1加获取互斥锁，查询数据库并写入缓存，最后释放锁。</p>
<p>​			在释放锁之前其他线程都只能等待，获取不到锁，无法查数据库。</p>
<p>​			SETNX：key不存在才能设置成功</p>
<p>只有一个线程能成功查询数据库，并写入缓存，其他线程只能等待</p>
<p><img src="/img/cache2.png"></p>
<p>获取互斥锁和释放锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取互斥锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span>stringRedisTemplate.opsForValue().setIfAbsent(key,<span class="string">&quot;1&quot;</span>,LOCK_SHOP_TTL,TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决缓存击穿</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//缓存击穿</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从redis查询缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY +id);</span><br><span class="line">    <span class="comment">//是否命中</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span>  JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前面已经判断有值的情况，还剩有值但值是空和null两种情况，</span></span><br><span class="line">    <span class="comment">// 再判断命中的是否是null，真的null</span></span><br><span class="line">    <span class="keyword">if</span>(shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//实现缓存重建 1.获取互斥锁 2.是否成功，成功执行查询 失败，休眠并重试</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(LOCK_SHOP_KEY);</span><br><span class="line">        <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">           <span class="keyword">return</span> queryWithMutex(id);<span class="comment">//重新去获取互斥锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从数据库</span></span><br><span class="line">        shop = getById(id);</span><br><span class="line">        <span class="comment">//模拟重建的延迟</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将null写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(</span><br><span class="line">                    CACHE_SHOP_KEY + id, <span class="string">&quot;&quot;</span> ,CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(</span><br><span class="line">                CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放互斥锁</span></span><br><span class="line">        unlock(LOCK_SHOP_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em><strong>逻辑过期</strong></em>: 线程1查询缓存，发现逻辑时间已经过期，获取互斥锁，开启新线程2, 最后返回过期数据。</p>
<pre><code>                 线程2查询数据库，重建缓存数据。写入缓存，重置逻辑过期时间，释放锁。这时候若有其他线程3来访问，它获取锁是失败的，它就不会去查询数据库,佛系线程。
</code></pre>
<p>​					最后只会有一个线程成功写入缓存，其他线程不做请求。</p>
<p><img src="/img/cache1.png"></p>
<p>先预热，将数据缓存的redis中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//热点数据的预热，先把数据存到缓存中，设置假的逻辑过期时间，用逻辑过期的方式为了解决缓存击穿</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShoptoRedis</span><span class="params">(Long id ,Long expiretime)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="comment">//1.查询店铺信息</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">       <span class="comment">//封装逻辑过期时间</span></span><br><span class="line">       <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">       redisData.setExpireTime(LocalDateTime.now().plusMinutes(expiretime));</span><br><span class="line">       redisData.setData(shop);</span><br><span class="line">       <span class="comment">//写入Redis</span></span><br><span class="line">       stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id,JSONUtil.toJsonStr(redisData));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>开启新线程，进行缓存重建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑过期解决缓存击穿，需要创建线程池</span></span><br><span class="line"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span>  <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>



<p>逻辑过期时间解决缓存击穿</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑过期解决互斥锁</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从redis查询缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY +id);</span><br><span class="line">    <span class="comment">//是否命中</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isBlank(shopJson))&#123;</span><br><span class="line">        <span class="comment">//未命中，返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//命中，需要吧json反序列化为对象,</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(shopJson,RedisData.class);</span><br><span class="line">    <span class="comment">//我们设置的是Object对象，但是shop对象需要我们自己转化</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span>  JSONUtil.toBean((JSONObject) redisData.getData(),Shop.class);</span><br><span class="line">    <span class="comment">//判断是否过期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="keyword">return</span>  shop;</span><br><span class="line">        <span class="comment">//未过期，直接返回shop信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//已过期，需要进行缓存重建</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockkey</span> <span class="operator">=</span> LOCK_SHOP_KEY +id;</span><br><span class="line">    <span class="comment">//获取互斥锁，判断锁获取成功与否，</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">islock</span> <span class="operator">=</span> tryLock(lockkey);</span><br><span class="line">    <span class="keyword">if</span>(islock)&#123;</span><br><span class="line">        <span class="comment">//成功开启线程查询并缓存，最后返回shop信息</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShoptoRedis(id,CACHE_SHOP_TTL);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                unlock(lockkey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回过期的shop信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="缓存工具封装"><a href="#缓存工具封装" class="headerlink" title="缓存工具封装:"></a>缓存工具封装:</h5><p>封装了四个工具类，下次当java中的对象需要解决redis缓存问题的时候调用即可。不确定的对象和类型都使用了泛型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将任意java对象序列化为JSON存储在String类型的key中，设置TTL</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit timeUnit)</span>&#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>这里查数据库只能提前查，就是查数据库写入缓存，在此方法不知道具体对象，不好查询数据库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将任意java对象序列化为JSON存储在String类型的key中，设置逻辑过期时间，解决缓存击穿</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit timeUnit)</span>&#123;</span><br><span class="line">    <span class="comment">//设置逻辑过期时间</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(value);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time)));</span><br><span class="line">    <span class="comment">//写入redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据指定的key查询缓存，并反序列化为指导类型，利用缓存空值的方式解决缓存穿透</span></span><br><span class="line"><span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID,R&gt; dbFallback,Long time, TimeUnit timeUnit)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从redis查询缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">Json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(keyPrefix +id);</span><br><span class="line">    <span class="comment">//是否命中</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(Json))&#123;</span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(Json, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前面已经判断有值的情况，还剩有值但值是空和null两种情况，</span></span><br><span class="line">    <span class="comment">// 再判断命中的是否是null，真的null</span></span><br><span class="line">    <span class="keyword">if</span>(Json != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从数据库</span></span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//将null写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(</span><br><span class="line">                CACHE_SHOP_KEY + id, <span class="string">&quot;&quot;</span> ,CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存在写入redis</span></span><br><span class="line">    <span class="built_in">this</span>.set(keyPrefix +id,r,time,timeUnit);</span><br><span class="line">    <span class="comment">//返回r</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em><strong>需要先进行缓存预热，就是先查数据库将信息写入缓存，设置假的逻辑过期时间，</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">////根据指定的key查询缓存，并反序列化为指导类型，利用逻辑过期的方式解决缓存击穿</span></span><br><span class="line"><span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID,R&gt; dbFallback,Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从redis查询缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">Json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY +id);</span><br><span class="line">    <span class="comment">//是否命中</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isBlank(Json))&#123;</span><br><span class="line">        <span class="comment">//未命中，返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//命中，需要吧json反序列化为对象,</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(Json,RedisData.class);</span><br><span class="line">    <span class="comment">//我们设置的是Object对象，但是shop对象需要我们自己转化</span></span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span>  JSONUtil.toBean((JSONObject) redisData.getData(),type);</span><br><span class="line">    <span class="comment">//判断是否过期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="keyword">return</span>  r;</span><br><span class="line">        <span class="comment">//未过期，直接返回shop信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//已过期，需要进行缓存重建</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockkey</span> <span class="operator">=</span> LOCK_SHOP_KEY +id;</span><br><span class="line">    <span class="comment">//获取互斥锁，判断锁获取成功与否，</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">islock</span> <span class="operator">=</span> tryLock(lockkey);</span><br><span class="line">    <span class="keyword">if</span>(islock)&#123;</span><br><span class="line">        <span class="comment">//成功开启线程查询并缓存，最后返回shop信息</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="comment">//查数据库，在写入缓存</span></span><br><span class="line">                <span class="type">R</span> <span class="variable">r1</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                <span class="built_in">this</span>.setWithLogicalExpire(CACHE_SHOP_KEY +id,r1,time,timeUnit);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                unlock(lockkey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回过期的shop信息</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="优惠券秒杀：Redis的计数器，Lua脚本Redis，分布式锁，Redis的三种消息队列"><a href="#优惠券秒杀：Redis的计数器，Lua脚本Redis，分布式锁，Redis的三种消息队列" class="headerlink" title="优惠券秒杀：Redis的计数器，Lua脚本Redis，分布式锁，Redis的三种消息队列"></a>优惠券秒杀：Redis的计数器，Lua脚本Redis，分布式锁，Redis的三种消息队列</h4><h5 id="全局唯一ID："><a href="#全局唯一ID：" class="headerlink" title="全局唯一ID："></a>全局唯一ID：</h5><p>当用户抢购时，生成订单保存到tb_voucher_order，订单表如果使用数据库自增ID：</p>
<p>id规律性太明显，受表单数据量的限制</p>
<p>全局ID生成器：是一种在分布式系统下来生成全局唯一ID的工具：</p>
<p>1.唯一性</p>
<p>2.高可用</p>
<p>3.高性能</p>
<p>4.递增性</p>
<p>5.安全性</p>
<p>ID:Redis自增数值，并拼接其他信息：</p>
<p><img src="/img/id.png"></p>
<p>,每天一个keyy，计算订单量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始的时间戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BIT</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span>&#123;</span><br><span class="line">    <span class="comment">//1.生成时间戳</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">    <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.生成序列号</span></span><br><span class="line">    <span class="comment">//获取日期</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy::MM:dd&quot;</span>));</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span>  stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr&quot;</span> + keyPrefix+<span class="string">&quot;:&quot;</span>+ date);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.拼接并返</span></span><br><span class="line">    <span class="comment">//时间抽向左移动，空出32位给序列号</span></span><br><span class="line">    <span class="keyword">return</span> timestamp&lt;&lt; COUNT_BIT | count ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2022</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">seconds</span> <span class="operator">=</span>    time.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">    System.out.println(seconds);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h5 id="实现优惠券秒杀下单："><a href="#实现优惠券秒杀下单：" class="headerlink" title="实现优惠券秒杀下单："></a>实现优惠券秒杀下单：</h5><p>平价券：随意购买，</p>
<p>特价券：秒杀抢购,秒杀有效期，库存量</p>
<h5 id="超卖问题："><a href="#超卖问题：" class="headerlink" title="超卖问题："></a>超卖问题：</h5><p><img src="/img/cache4.png"></p>
<p>加锁：</p>
<p><img src="/img/cache5.png"></p>
<p>悲观锁：</p>
<p>乐观锁：判断之前查询的数据是否被修改，</p>
<p>版本号：<img src="/img/cache6.png"></p>
<p>CAS: <img src="/img/cache7.png"></p>
<p>成功率太低：数据库压力较大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-12-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService voucherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span>  voucherService.getById(voucherId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断有效期</span></span><br><span class="line">       <span class="keyword">if</span>(seckillVoucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(seckillVoucher.getEndTime().isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//库存</span></span><br><span class="line">        <span class="keyword">if</span>(seckillVoucher.getStock() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;stock not fill!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//扣减库存,乐观锁</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">sucess</span> <span class="operator">=</span>  voucherService.update()</span><br><span class="line">               <span class="comment">//</span></span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock -1&quot;</span>)</span><br><span class="line">               <span class="comment">//where id =? and stock &gt; 0</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>,voucherId).gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>)</span><br><span class="line">                .update();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!sucess)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;stock not fill!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderid</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderid);</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="type">long</span> <span class="variable">userid</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        voucherOrder.setUserId(userid);</span><br><span class="line">        <span class="comment">//返回订单id</span></span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="一人一单："><a href="#一人一单：" class="headerlink" title="一人一单："></a>一人一单：</h5><p>每个人每张优惠券只能抢购一张</p>
<p>悲观锁实现的：用户id作为锁，就是该方法对每个新用户自己上锁，一人一单, </p>
<p>获取锁，进行事务控制，事务完毕，释放锁，保证流程最终是成功的。这就是一致性。原子性。</p>
<p>synchronized (userid.toString().intern()) { &#x2F;&#x2F;去字符串常量池找值一样的，返回地址或引用。就是要确保当用户id一样，锁就是一样的，只锁当前用户。就是尽量减小锁的范围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-12-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService voucherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IVoucherOrderService currentproxyService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span>  voucherService.getById(voucherId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断有效期</span></span><br><span class="line">       <span class="keyword">if</span>(seckillVoucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(seckillVoucher.getEndTime().isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//库存</span></span><br><span class="line">        <span class="keyword">if</span>(seckillVoucher.getStock() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;stock not fill!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userid</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//去字符串常量池找值一样的，返回地址或引用。就是要确保当用户id一样，锁就是一样的，只锁当前用户。就是尽量减小锁的范围。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (userid.toString().intern()) &#123;</span><br><span class="line">            <span class="comment">//非事务方法调用事务方法，注入当前代理对象即可</span></span><br><span class="line">            <span class="keyword">return</span> currentproxyService.createVoucherOrder(voucherId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span>  Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//一人一单</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userid</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">            <span class="comment">//查询，是否存在，</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userid).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;该用户已经抢购!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//扣减库存</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">sucess</span> <span class="operator">=</span> voucherService.update()</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    .setSql(<span class="string">&quot;stock = stock -1&quot;</span>)</span><br><span class="line">                    <span class="comment">//where id =? and stock &gt; 0</span></span><br><span class="line">                    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                    .update();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!sucess) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;stock not fill!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建订单</span></span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">            <span class="type">long</span> <span class="variable">orderid</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            voucherOrder.setId(orderid);</span><br><span class="line">            voucherOrder.setVoucherId(voucherId);</span><br><span class="line">            voucherOrder.setUserId(userid);</span><br><span class="line">            <span class="comment">//返回订单id</span></span><br><span class="line">            save(voucherOrder);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(orderid);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁:"></a>分布式锁:</h5><p>单体项目，在集群模式下会有并发问题。</p>
<p>多个JVM的多线程只会有一个线程拿到锁。满足分布式系统或集群模式多线可见并且互斥的锁。</p>
<p>高可用，搞性能，安全性，</p>
<p><img src="/img/cache8.png"></p>
<p>简单的SetNX的实现：上锁和加锁，redis层级的锁，所有集群的所有线程都来抢同一把锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//锁的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//SETNX</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">//获取线程表示</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span>  Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">sucess</span> <span class="operator">=</span> stringRedisTemplate</span><br><span class="line">                .opsForValue().setIfAbsent(KEY_PREFIX+name,threadId+<span class="string">&quot;&quot;</span>,timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">return</span> Boolean.TRUE.equals(sucess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>抢锁，执行，完成释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分布式锁解决一人一单，上面的只是单机成功而已，集群下需要以下的分布式来解决</span></span><br><span class="line">  <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span>   <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userid,stringRedisTemplate);</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span>   lock.tryLock(<span class="number">1200</span>);</span><br><span class="line">  <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">      <span class="comment">//获取锁失败</span></span><br><span class="line">      <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复抢购&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentproxyService.createVoucherOrder(voucherId);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>







<h5 id="Redis秒杀优化"><a href="#Redis秒杀优化" class="headerlink" title="Redis秒杀优化:"></a>Redis秒杀优化:</h5><h5 id="Redis消息队列实现异步秒杀："><a href="#Redis消息队列实现异步秒杀：" class="headerlink" title="Redis消息队列实现异步秒杀："></a>Redis消息队列实现异步秒杀：</h5><p>达人探店：基于List的点赞列表，基于SortedSet的点赞排行榜</p>
<p>好友关注：基于Set集合的关注，取关，共同关注，消息推送</p>
<p>附近商户：Redis的GeoHash</p>
<p>UV统计：Hyperlog，Log统计功能</p>
<p>用户签到：BitMap数据统计</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>xc-plus-project</title>
    <url>/2023/09/07/xc-plus-project/</url>
    <content><![CDATA[<h1 id="技术架构："><a href="#技术架构：" class="headerlink" title="技术架构："></a>技术架构：</h1><p>1.VMwarepro 虚拟机</p>
<p>充当云服务器，docker 中开启 nacos，xxl-job，minio，redis，elsticsearch，kibana，gogs,rabbitmq,mysql服务，xshell远程连接，Navicat开启数据库。<br>2.前端静态页面存在D:&#x2F;&#x2F;JAVA&#x2F;xc-res&#x2F;中，修改相关内容即可。还有一个前端工程，Vue编写的。<br>3.后端代码存在ideacode中，分每个微服务来写。<br>4.nacos是每个微服务的配置，xx-dev.yml文件，服务启动后会显示<br>5.xxl-job是分布式任务的处理，视频的处理，和课程的发布。分布式任务显示<br>6.minio存储需要的media和video，相当于一个数据库，存储文件，<br>7.e&amp;k,索引，搜索，把数据库表中的字段和值，通过映射到e&amp;k中，用于网页的索引和搜索。<br>8.gogs实现git代码的管理，每天一次commit到本地和push到远程。<br>9.redis存储本地的验证码，登录账户密码，图片验证码</p>
<p>11.rabbitmq消息队列，处理每个任务之间的逻辑，当前一个任务完成的时候，在队列中通知下一个任务的可以进行</p>
<p>10.在前端修改上传文件的大小和浏览器设置上传文件的服务器设置</p>
<p>11代理对象，事务控制(事务优化，代理对象处理事务需要在方法上添加@Transaction注解)</p>
<h1 id="详细技术介绍："><a href="#详细技术介绍：" class="headerlink" title="详细技术介绍："></a>详细技术介绍：</h1><h2 id="0-gogs"><a href="#0-gogs" class="headerlink" title="0 gogs"></a>0 gogs</h2><p>相当于git,Gogs是一个简单而功能齐全的自托管Git服务，适用于小型团队和个人开发者，帮助他们管理和协作开发代码项目。</p>
<ol>
<li><strong>轻量级和易于安装</strong>：Gogs以轻量级和快速部署为设计目标，可以在各种操作系统上安装和运行，包括Linux、Windows、macOS等。</li>
<li><strong>自托管</strong>：您可以在自己的服务器上搭建Gogs，完全掌握代码托管的控制权，而无需依赖第三方服务。</li>
<li><strong>Web界面</strong>：Gogs提供了一个直观的Web界面，允许用户创建和管理Git仓库、查看提交历史、管理问题和PR、设置Web钩子等。</li>
<li><strong>多用户支持</strong>：Gogs支持多用户和组织，可以创建和管理不同用户的账户，进行协作开发。</li>
<li><strong>Web钩子和集成</strong>：Gogs支持Web钩子，可以与CI&#x2F;CD工具、问题跟踪系统和通知服务集成，实现自动化和通知。</li>
<li><strong>访问控制</strong>：Gogs提供了丰富的访问控制选项，包括仓库级别和组织级别的权限管理，以确保代码的安全性和隐私性。</li>
<li><strong>问题跟踪和PR</strong>：Gogs具有内置的问题跟踪系统和Pull Request（PR）功能，方便团队协作和代码审查。</li>
<li><strong>自动备份和迁移</strong>：Gogs支持自动备份和迁移，确保代码不会丢失。</li>
<li><strong>多语言支持</strong>：Gogs支持多种语言，包括英语、中文、日语等，以满足全球用户的需求。</li>
</ol>
<h2 id="1swagger-ui"><a href="#1swagger-ui" class="headerlink" title="1swagger-ui"></a>1swagger-ui</h2><p>Swagger UI 使 API 开发变得更加高效和可视化，同时提供了强大的工具来创建、测试和文档化 RESTful API。它已经成为了许多开发者和团队在构建和维护 API 时的首选工具之一。通过提供可视化的 API 文档和测试界面，Swagger UI 提高了 API 的可用性和可维护性。</p>
<ol>
<li><strong>自动生成文档</strong>：Swagger UI 可以自动从 API 的注释、注解和代码中生成 API 文档。开发者无需手动编写文档，只需在代码中添加适当的注释和注解。</li>
<li><strong>交互式界面</strong>：Swagger UI 提供了一个交互式的 Web 界面，允许开发者浏览 API 的端点、请求参数、响应数据等信息。这有助于更好地理解和测试 API。</li>
<li><strong>支持多种编程语言</strong>：Swagger UI 支持多种编程语言和框架，包括 Java、Python、Node.js、Ruby 等。这意味着您可以在不同的编程环境中使用 Swagger UI。</li>
<li><strong>在线 API 测试</strong>：Swagger UI 允许开发者在界面中直接测试 API 端点，输入参数并查看响应，以确保 API 正确工作。</li>
<li><strong>生成客户端代码</strong>：Swagger UI 可以生成用于调用 API 的客户端代码，这些客户端代码可以用于不同编程语言，帮助开发者更轻松地与 API 进行交互。</li>
<li><strong>可自定义</strong>：Swagger UI 具有可自定义的界面，您可以根据自己的需求进行样式和布局的调整，以适应项目的设计风格。</li>
<li><strong>整合现有项目</strong>：您可以将 Swagger UI 集成到现有的 Web 项目中，以提供 API 文档和测试的功能。</li>
<li><strong>安全性</strong>：Swagger UI 支持 API 安全性的设置和测试，可以模拟授权和认证过程。</li>
</ol>
<h2 id="2nacos-Ali"><a href="#2nacos-Ali" class="headerlink" title="2nacos(Ali)"></a>2nacos(Ali)</h2><p>​	Nacos 是一个功能强大的分布式配置和服务发现系统，适用于构建和管理微服务架构的应用程序</p>
<ol>
<li><strong>配置管理</strong>：Nacos 允许开发者集中管理配置，包括应用程序的配置文件、环境变量、数据库连接等。配置可以动态刷新，无需重启应用程序。</li>
<li><strong>服务发现</strong>：Nacos 提供了服务注册和发现功能，使微服务之间可以轻松地发现和通信。它支持多种负载均衡算法。</li>
<li><strong>动态DNS</strong>：Nacos 支持动态DNS，允许为服务分配动态的域名和IP地址。</li>
<li><strong>多环境支持</strong>：Nacos 支持多个环境（如开发、测试、生产）的配置管理，可以在不同环境中使用不同的配置。</li>
<li><strong>分布式存储</strong>：Nacos 使用分布式存储来保证高可用性和数据的一致性，支持多种存储后端，包括MySQL、Redis等。</li>
<li><strong>健康检查</strong>：Nacos 提供了健康检查机制，允许检测服务的健康状态并自动剔除不健康的实例。</li>
<li><strong>灰度发布</strong>：Nacos 支持灰度发布，允许逐步将新版本的服务引入生产环境，减小风险。</li>
<li><strong>多语言支持</strong>：Nacos 提供多种编程语言的客户端 SDK，可以与多种编程语言的应用程序集成。</li>
<li><strong>集成Spring Cloud</strong>：Nacos 可以与Spring Cloud框架集成，使得在微服务架构中更容易实现配置管理和服务发现。</li>
</ol>
<h2 id="3minio"><a href="#3minio" class="headerlink" title="3minio"></a>3minio</h2><p>MinIO 是一个开源的对象存储服务器，用于存储和管理大规模的数据，通常被用于构建分布式存储、备份和数据湖等应用。</p>
<ol>
<li><strong>开源和免费</strong>：MinIO 是一个完全开源的项目，使用Apache License 2.0许可，允许您免费使用、修改和分发它。</li>
<li><strong>对象存储</strong>：MinIO 提供了对象存储的功能，您可以将数据以对象的形式存储在 MinIO 中，并使用唯一的键来检索它们。</li>
<li><strong>高性能</strong>：MinIO 被设计成高性能的存储系统，可以处理大规模的数据并提供低延迟的读写操作。</li>
<li><strong>可扩展性</strong>：MinIO 可以轻松地水平扩展，以应对不断增长的存储需求。您可以添加新的MinIO实例，构建集群来实现高可用性和负载均衡。</li>
<li><strong>S3兼容</strong>：MinIO 提供了与Amazon S3兼容的API，这意味着您可以使用现有的S3客户端和工具与MinIO进行交互，而无需修改代码。</li>
<li><strong>安全性</strong>：MinIO 提供了数据加密、访问控制、身份验证和安全传输等安全特性，以确保您的数据安全。</li>
<li><strong>版本控制</strong>：MinIO 具备版本控制的功能，允许您保留和管理多个对象版本，以便回溯或还原数据。</li>
<li><strong>分布式存储</strong>：MinIO 支持分布式存储，可以将数据分散存储在多个地点，以提高可用性和数据冗余。</li>
<li><strong>容器化部署</strong>：MinIO 可以轻松部署到容器化环境中，例如Kubernetes，以便在容器编排平台上管理和扩展。</li>
<li><strong>监控和日志</strong>：MinIO 提供了监控和日志记录功能，可以用于监视存储使用情况和性能，并进行故障排除。</li>
</ol>
<h2 id="5xxl-job-ALi"><a href="#5xxl-job-ALi" class="headerlink" title="5xxl-job(ALi)"></a>5xxl-job(ALi)</h2><p>XXL-Job 是一个非常有用的任务调度平台，特别适用于需要管理和调度大量定时任务的场景，如数据处理、数据导入、定时报表生成等。</p>
<ol>
<li><strong>分布式任务调度</strong>：XXL-Job 可以在多台服务器上分布式执行定时任务，确保任务的高可用性和负载均衡。</li>
<li><strong>多语言支持</strong>：支持多种编程语言（如Java、Python、Shell等）编写任务执行器，使用户能够使用不同的编程语言编写任务逻辑。</li>
<li><strong>任务调度管理</strong>：XXL-Job 提供了任务调度管理的功能，包括任务新增、编辑、删除、暂停、恢复等。</li>
<li><strong>任务依赖</strong>：支持任务之间的依赖关系，可以配置任务的执行顺序和触发条件。</li>
<li><strong>分片执行</strong>：任务可以分片执行，每个分片可以在不同的执行器上并行执行，提高任务执行效率。</li>
<li><strong>任务日志和监控</strong>：XXL-Job 提供了任务执行日志记录和监控功能，可以查看任务的执行日志和状态。</li>
<li><strong>动态参数</strong>：支持动态参数传递，任务执行时可以动态传递参数，提高任务的通用性。</li>
<li><strong>报警机制</strong>：XXL-Job 支持任务执行失败时的报警通知，可以配置邮件报警、钉钉报警等。</li>
<li><strong>定时任务</strong>：支持定时任务的配置，可以按照固定的时间点触发任务执行。</li>
<li><strong>API接口</strong>：提供了API接口，可以与其他系统集成，实现任务的自动化管理和调度。</li>
<li><strong>任务执行日志</strong>：任务执行后，可以查看任务的详细执行日志，有助于故障排查和任务监控。</li>
<li><strong>分布式调度中心</strong>：支持将任务调度中心部署在多个节点，以实现高可用性和负载均衡。</li>
</ol>
<h2 id="6nginx"><a href="#6nginx" class="headerlink" title="6nginx:"></a>6nginx:</h2><p>Nginx（发音为 “engine x”）是一个高性能的开源Web服务器，也可以用作反向代理服务器、负载均衡器和HTTP缓存服务器。</p>
<p>网页前端页面，部署网页的位置，config文件，配置网页，拿图片，视频</p>
<ol>
<li><strong>高性能</strong>：Nginx 是为高并发和高负载设计的，能够处理数千个并发连接而不会过度消耗系统资源。</li>
<li><strong>反向代理</strong>：Nginx 可以用作反向代理服务器，将客户端的请求代理到后端服务器，以实现负载均衡、安全性和性能优化。</li>
<li><strong>负载均衡</strong>：Nginx 支持负载均衡，可以将请求分发到多个后端服务器，提高系统的可用性和性能。</li>
<li><strong>静态文件服务</strong>：Nginx 可以高效地提供静态文件服务，例如HTML、CSS、JavaScript、图像等，从而减轻后端服务器的负担。</li>
<li><strong>HTTP缓存</strong>：Nginx 具有内置的HTTP缓存支持，可以缓存静态和动态内容，提高响应速度。</li>
<li><strong>SSL&#x2F;TLS支持</strong>：Nginx 支持SSL&#x2F;TLS加密，可以保护数据传输的安全性，用于HTTPS协议。</li>
<li><strong>虚拟主机</strong>：Nginx 支持虚拟主机配置，允许在同一服务器上托管多个域名或应用程序。</li>
<li><strong>模块化架构</strong>：Nginx 的模块化架构使得可以根据需求添加各种功能和扩展，以满足不同场景的需求。</li>
<li><strong>动态模块加载</strong>：Nginx 支持动态模块加载，可以在运行时加载或卸载模块，无需重新编译和部署。</li>
<li><strong>日志记录</strong>：Nginx 提供强大的日志记录功能，可以记录访问日志、错误日志等，有助于监控和故障排查。</li>
<li><strong>反爬虫和安全性</strong>：Nginx 可以配置反爬虫规则、访问控制、DDoS防护等安全性功能。</li>
<li><strong>可扩展性</strong>：Nginx 可以与其他服务和技术集成，如FastCGI、uWSGI、PHP-FPM等，以构建复杂的Web应用和微服务架构。</li>
</ol>
<h2 id="7freemarker"><a href="#7freemarker" class="headerlink" title="7freemarker:"></a>7freemarker:</h2><p>FreeMarker（全名 “FreeMarker Template Engine”）是一个开源的模板引擎，用于生成动态文本输出，通常用于在Web应用程序中生成HTML、XML、JSON等格式的内容。</p>
<ol>
<li><p><strong>模板引擎</strong>：FreeMarker 是一个模板引擎，允许开发者将静态模板和动态数据结合起来生成动态内容。</p>
</li>
<li><p><strong>模板语言</strong>：FreeMarker 提供了一种简单而强大的模板语言，支持条件语句、循环、变量定义、宏等功能，以便更好地控制模板生成的内容。</p>
</li>
<li><p><strong>分离视图和数据</strong>：FreeMarker 鼓励将视图（模板）和数据（模型）分离，以提高代码的可维护性和可重用性。</p>
</li>
<li><p><strong>强大的表达式</strong>：FreeMarker 支持表达式，可以进行各种操作，如字符串拼接、数学运算、日期格式化等。</p>
</li>
<li><p><strong>多用途</strong>：FreeMarker 不仅可以用于生成HTML页面，还可以用于生成XML文档、JSON数据、配置文件等各种类型的文本输出。</p>
</li>
<li><p><strong>可扩展性</strong>：FreeMarker 是可扩展的，允许开发者编写自定义指令和函数，以适应不同的需求。</p>
</li>
<li><p><strong>跨平台</strong>：由于FreeMarker是Java编写的，因此可以在各种操作系统上运行，并且易于与Java应用程序集成。</p>
</li>
<li><p><strong>开源</strong>：FreeMarker 是一个开源项目，使用Apache License 2.0许可，可以免费使用和修改。</p>
</li>
<li><p><strong>模板缓存</strong>：FreeMarker 支持模板缓存，可以提高模板渲染的性能，避免每次请求都重新解析模板。</p>
</li>
<li><p><strong>国际化支持</strong>：FreeMarker 支持国际化和本地化，可以轻松处理多语言和不同地区的内容生成。</p>
<p><img src="/img/free.png"></p>
<p>我有一个静态化页面的模版，course_template.ftl  每次生成页面都会根据这模版来生成，动态模板拿数据，从数据库拿数据展示到网页<a href="http://freemarker.foofun.cn/ref_directives.html">http://freemarker.foofun.cn/ref_directives.html</a></p>
<p>课程预览的时候会提前在缓存中加载好静态化的页面模版，每次新的课程生成新的页面时，会动态拿一些数据再结合静态化模版生成新的页面</p>
<p>course_template.ftl.：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;banner-left&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>$&#123;model.courseBase.mtName&#125;<span class="tag">&lt;<span class="name">span</span>&gt;</span>\ $&#123;model.courseBase.stName&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;tit&quot;</span>&gt;</span>$&#123;model.courseBase.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span>&gt;</span></span><br><span class="line">        &lt;#if model.courseBase.charge==&#x27;201000&#x27;&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;new-pic&quot;</span>&gt;</span>免费<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        &lt;#else&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;new-pic&quot;</span>&gt;</span>特惠价格￥$&#123;model.courseBase.price!&#x27;&#x27;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;old-pic&quot;</span>&gt;</span>原价￥$&#123;model.courseBase.originalPrice!&#x27;&#x27;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//课程预览</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/coursepreview/&#123;courseId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">preview</span><span class="params">(<span class="meta">@PathVariable(&quot;courseId&quot;)</span> Long courseId)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">//查询课程的信息作为模型数据</span></span><br><span class="line">    <span class="type">CoursePreviewDto</span> <span class="variable">coursePreviewInfo</span> <span class="operator">=</span> coursePublishService.getCoursePreviewInfo(courseId);</span><br><span class="line">    <span class="comment">//指定模型</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;model&quot;</span>, coursePreviewInfo);</span><br><span class="line">    <span class="comment">//指定模板</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;course_template&quot;</span>);<span class="comment">//根据视图名称加.ftl找到模板</span></span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="8feign"><a href="#8feign" class="headerlink" title="8feign"></a>8feign</h2><p>在一个微服务中调用另一个微服务，并使用 Feign 进行远程连接，同时使用 FreeMarker 进行动态化结合静态化模板生成页面是一种常见的微服务架构和页面生成方式。<br>Feign 是一个在 Spring Cloud 生态系统中广泛使用的声明式 HTTP 客户端库。</p>
<p>Feign 是一个非常方便的工具，特别适用于构建微服务架构中的服务间通信。如果您需要在 Spring Cloud 中实现服务之间的通信</p>
<p>远程调用@JsonFormat(shape &#x3D; JsonFormat.Shape.STRING,pattern &#x3D; “yyyy-MM-dd HH:mm:ss”)</p>
<p>以下是 Feign 的一些关键特点和用途：</p>
<ol>
<li><strong>声明式 API 定义</strong>：Feign 允许开发者使用注解方式定义和描述 HTTP 请求。这使得创建和维护 API 定义变得非常直观和易于理解。</li>
<li><strong>集成 Spring Cloud</strong>：Feign 是 Spring Cloud 中的一部分，与其他 Spring Cloud 组件（如Eureka、Ribbon等）集成得非常好，可以轻松实现负载均衡、服务注册和发现等功能。</li>
<li><strong>自动编码和解码</strong>：Feign 自动处理请求和响应的编码和解码，开发者无需手动进行序列化和反序列化操作。</li>
<li><strong>拦截器支持</strong>：Feign 提供了拦截器机制，允许开发者在请求发送和响应接收的过程中执行自定义逻辑，例如添加认证信息、记录请求日志等。</li>
<li><strong>动态代理</strong>：Feign 使用动态代理生成客户端代码，从而使得远程服务调用看起来像本地方法调用。这种透明性极大地简化了代码的编写和维护。</li>
<li><strong>多种 HTTP 方法支持</strong>：Feign 支持常见的 HTTP 请求方法，包括 GET、POST、PUT、DELETE 等，开发者可以根据需要选择合适的方法来调用远程服务。</li>
<li><strong>错误处理</strong>：Feign 提供了丰富的错误处理机制，可以捕获和处理远程服务调用中的异常情况。</li>
<li><strong>可扩展性</strong>：Feign 可以通过编写自定义组件和配置来满足更复杂的需求，例如自定义负载均衡策略、连接池配置等。</li>
</ol>
<h2 id="9elasticsearch"><a href="#9elasticsearch" class="headerlink" title="9elasticsearch"></a>9elasticsearch</h2><p>作为索引及搜索服务。kibana 是 ELK（Elasticsearch , Logstash, Kibana ）之一，kibana 一款开源的数据分析和可视化平台，通过可视化界面访问elasticsearch的索引库，并可以生成一个数据报表。开发中主要使用kibana通过api对elasticsearch进行索引和搜索操作，<em>docker-compose up：安装docker-compose.yml中的配置启动kibana和ela</em></p>
<ol>
<li><strong>全文搜索</strong>：Elasticsearch 是一个强大的全文搜索引擎，可以轻松地索引和搜索文本数据，支持复杂的查询、过滤和排序。</li>
<li><strong>分布式性能</strong>：Elasticsearch 可以轻松水平扩展，将数据和负载分布到多个节点上，从而实现高性能和高可用性。它使用分片和复制机制来处理数据的分布和冗余。</li>
<li><strong>实时数据</strong>：Elasticsearch 是实时的，可以在数据被索引后几乎立即进行搜索和分析。这使得它非常适合处理实时日志、监控数据和事件流等数据源。</li>
<li><strong>多样化的数据支持</strong>：除了文本数据，Elasticsearch 还支持结构化数据、地理空间数据、数值数据等多种数据类型。它可以作为一个通用的数据存储和检索引擎。</li>
<li><strong>复杂查询和聚合</strong>：Elasticsearch 支持复杂的查询和聚合操作，包括范围查询、模糊查询、多字段搜索、聚合统计等。这使得它非常适合用于数据分析和报告生成。</li>
<li><strong>开源生态系统</strong>：Elasticsearch 是开源的，并且有一个庞大的生态系统，包括插件、工具和库，可以用于扩展其功能和集成到各种应用程序中。</li>
<li><strong>可视化工具</strong>：Elasticsearch 配合 Kibana 可以提供可视化的数据仪表板，用于监控、分析和可视化数据。</li>
<li><strong>安全性</strong>：Elasticsearch 提供了安全性功能，可以控制访问、认证和授权，以确保数据的安全性。</li>
</ol>
<h2 id="10redis"><a href="#10redis" class="headerlink" title="10redis"></a>10redis</h2><p>存储验证码调用redis需要再bootstrap.yml文件中调用nacos中的配置，还有pom.xml文件中引入相关的依赖。</p>
<h2 id="11rabbitmq"><a href="#11rabbitmq" class="headerlink" title="11rabbitmq"></a>11rabbitmq</h2><p>RabbitMQ 是一个开源的消息队列中间件，用于在分布式系统中传递和存储消息。它是一种高度可靠的消息代理，广泛用于构建分布式、可扩展和高可用性的应用程序。</p>
<ol>
<li><p><strong>消息队列</strong>：RabbitMQ 是一个消息队列中间件，用于将消息从一个发送者传递到一个或多个接收者。这种异步消息传递模型有助于解耦应用程序的不同部分，提高了应用程序的可维护性和可扩展性。</p>
</li>
<li><p><strong>支持多种消息协议</strong>：RabbitMQ 支持多种消息协议，包括AMQP（高级消息队列协议）、STOMP、MQTT 等，使得它能够与多种编程语言和应用程序集成。</p>
</li>
<li><p><strong>可靠性</strong>：RabbitMQ 提供了持久性消息、确认机制、事务等功能，确保消息的可靠传递和处理。即使在系统故障后，也可以确保不会丢失消息。</p>
</li>
<li><p><strong>多种消息交换模式</strong>：RabbitMQ 支持多种消息交换模式，包括直连交换、主题交换、扇出交换等，这些模式允许不同类型的消息路由和分发。</p>
</li>
<li><p><strong>灵活的消息路由</strong>：RabbitMQ 具有强大的路由功能，可以根据消息的内容、标签或其他属性将消息路由到指定的队列，从而实现消息的精确控制和分发。</p>
</li>
<li><p><strong>可扩展性</strong>：RabbitMQ 可以轻松水平扩展，通过添加更多的节点和队列来增加处理能力和容量。它还支持集群和镜像队列，以提高可用性。</p>
</li>
<li><p><strong>管理界面</strong>：RabbitMQ 提供了一个易于使用的管理界面，允许管理员监控和管理消息队列、队列和交换机的状态和配置。</p>
</li>
<li><p><strong>广泛的应用场景</strong>：RabbitMQ 适用于多种应用场景，包括异步任务处理、事件驱动架构、日志和监控数据传输、微服务通信、电子商务订单处理等。</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>+————–+        +————–+        +————–+<br>|  Producer   |  –&gt;   |  Exchange    |  –&gt;   |  Queue       |  –&gt;   |  Consumer   |<br>+————–+        +————–+        +————–+<br>|  发送消息   |        |  消息路由   |        |  存储消息   |        |  处理消息   |<br>+————–+        +————–+        +————–+</p>
</li>
<li><p>生产者发送消息到 Exchange</p>
</li>
<li><p>Exchange 根据路由规则将消息路由到一个或多个队列</p>
</li>
<li><p>队列存储消息等待消费</p>
</li>
<li><p>消费者获取队列中的消息并处理</p>
<p><strong>18：消息队列</strong></p>
<p>处理支付完成之后的插入课程表。<a href="http://192.168.101.65:15672/#/exchanges%E7%94%9F%E4%BA%A7%E6%96%B9%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5%E5%88%B0%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%80%9A%E8%BF%87%E5%B9%BF%E6%92%AD%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%91%E9%80%81%E7%BB%99%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E6%B6%88%E8%B4%B9%E6%96%B9%E9%80%9A%E8%BF%87%E7%9B%91%E5%90%AC%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BF%A1%E6%81%AF%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82">http://192.168.101.65:15672/#/exchanges生产方发送通知到交换机，交换机通过广播的方式发送给消息队列，消费方通过监听消息队列的信息进行相应的操作。</a></p>
<p>rabbitMq，消息持久化，交换机持久化。</p>
<p>PayNotifyconfig配置 生产端：orders服务，消费端：learning（创建交换机和队列，队列绑定交换机）发送：消息发送到交换机，删除数据库中的消息。发送失败则向数据库中callback插入消息。接受：监听消息队列发送的消息。进行数据的处理，插表改状态等操作。</p>
<h3 id="四六级的服务器："><a href="#四六级的服务器：" class="headerlink" title="四六级的服务器："></a>四六级的服务器：</h3><p>错误信息：ALREADY CLOSE THE AMQP OPERATION WAS INTERRUPTE AMQP CLOSE-REASON, INITIATED BY PEER, CODE&#x3D;404, TEXT&#x3D;’NOT_FOUND - HOME NODE ‘RABBIT@CET-BM202’ OF DURABLE QUEUE ‘CET_ADD_SUBJECT_ALTERNATE_QUEUE’ IN VHOST ‘CET’ IS DOWN OR INACCESSIBLE’, CLASSID&#x3D;50, METHODID&#x3D;10</p>
<p>错误信息中涉及了以下技术和知识点：</p>
<ol>
<li><p>**AMQP (Advanced Message Queuing Protocol)**：AMQP 是一种消息传递协议，用于处理消息队列中的消息。它是一种用于在分布式系统中传递和存储消息的协议。错误信息中的 “AMQP CLOSE-REASON” 指的是 AMQP 关闭原因。</p>
</li>
<li><p><strong>消息队列</strong>：消息队列是一种用于在不同组件之间异步传递消息的通信方式。在这种情况下，它用于处理四六级报名请求。消息队列可以帮助解耦系统的不同部分，使它们可以独立运行，从而提高系统的可扩展性和性能。</p>
</li>
<li><p>**节点 (Node)**：在分布式系统中，节点是指系统中的一个独立部分或服务器。错误信息中提到的 “HOME NODE ‘RABBIT@CET-BM202’” 指的是消息队列系统中的一个节点，它可能是一个 RabbitMQ 节点。</p>
</li>
<li><p>**队列 (Queue)**：队列是消息队列系统中用于存储消息的地方。错误信息中提到的 “DURABLE QUEUE ‘CET_ADD_SUBJECT_ALTERNATE_QUEUE’” 指的是一个持久队列，用于存储四六级报名请求。</p>
</li>
<li><p>**虚拟主机 (VHOST)**：虚拟主机是消息队列系统中的逻辑隔离单位，允许多个应用程序在同一个消息队列服务器上独立运行，就像它们在不同的服务器上一样。错误信息中提到的 “VHOST ‘CET’” 指的是一个虚拟主机。</p>
</li>
<li><p>**错误代码 (CODE)**：错误代码是一种标识错误类型的数字或代码。在这种情况下，错误代码 404 表示资源未找到。</p>
</li>
<li><p>**错误消息 (TEXT)**：错误消息提供了有关错误的详细信息。在这种情况下，它指出队列 ‘CET_ADD_SUBJECT_ALTERNATE_QUEUE’ 所在的节点 ‘RABBIT@CET-BM202’ 处于关闭或不可访问状态。</p>
</li>
<li><p>**类 (CLASSID) 和方法 (METHODID)**：这些是与 AMQP 协议相关的标识，用于指定错误的具体类型和来源。</p>
</li>
</ol>
<p>综合来说，错误信息涉及到消息队列、AMQP协议、分布式系统、节点、队列、虚拟主机以及错误处理等多个技术和知识点。解决此问题通常需要对这些概念和技术有一定的了解，并且可能需要调查消息队列服务器的配置和状态，以找到并解决问题的根本原因。</p>
</li>
</ol>
<h2 id="12-canal"><a href="#12-canal" class="headerlink" title="12 canal"></a>12 canal</h2><p> 数据实时同步：即改动数据库需要像mysql,elasticsearch等实时更新，采用binary log 的方法，[ mysql() – binary log ]  –&gt; canal -&gt; ela </p>
<h2 id="14spring-cloud："><a href="#14spring-cloud：" class="headerlink" title="14spring cloud："></a>14spring cloud：</h2><p>Spring Cloud是一个用于构建分布式系统和微服务架构的开源框架，它基于Spring Boot构建，提供了一系列工具和库，用于快速开发和部署分布式应用程序。Spring Cloud使开发人员能够轻松处理分布式系统中的常见问题，如配置管理、服务发现、负载均衡、断路器、分布式数据、消息传递等。</p>
<ol>
<li><p><strong>服务注册与发现</strong>：Spring Cloud提供了服务注册与发现机制，使微服务能够自动注册和发现其他微服务。Eureka和Consul是常见的服务注册与发现组件。</p>
</li>
<li><p><strong>负载均衡</strong>：Spring Cloud支持负载均衡，可以在多个实例之间分发请求，提高系统的性能和可用性。Ribbon是用于负载均衡的组件。</p>
</li>
<li><p><strong>断路器</strong>：Spring Cloud提供了断路器模式，可以防止故障的微服务影响整个系统。Hystrix是一个常用的断路器库。</p>
</li>
<li><p><strong>配置管理</strong>：Spring Cloud Config允许将配置中心化管理，实现配置的集中存储和动态刷新。</p>
</li>
<li><p><strong>API网关</strong>：Spring Cloud Gateway和Zuul是用于构建API网关的组件，用于处理请求路由、认证、授权、日志记录等功能。</p>
</li>
<li><p><strong>分布式消息传递</strong>：Spring Cloud Stream和Apache Kafka等允许微服务之间进行异步通信，以支持事件驱动架构。</p>
</li>
<li><p><strong>分布式追踪和监控</strong>：Spring Cloud Sleuth和Zipkin等工具用于分布式系统的追踪和监控，帮助诊断性能问题。</p>
</li>
<li><p><strong>批处理和任务调度</strong>：Spring Cloud Data Flow和Spring Cloud Task支持批处理和任务调度。</p>
</li>
<li><p><strong>安全性</strong>：Spring Cloud Security提供了安全性和认证授权的功能，可以用于保护微服务和API。</p>
</li>
<li><p><strong>分布式数据存储</strong>：Spring Cloud提供了对分布式数据存储的支持，如Spring Cloud Data Redis和Spring Cloud Data MongoDB。</p>
<h3 id="FeignClient"><a href="#FeignClient" class="headerlink" title="@FeignClient"></a>@FeignClient</h3><p><code>@FeignClient</code> 是 Spring Cloud 中的一个注解，用于创建基于声明式 REST 客户端。通过 <code>@FeignClient</code> 注解，您可以声明一个接口，该接口将自动映射到远程的 HTTP 服务端点，从而使您能够以面向接口的方式调用远程服务，而不需要编写具体的 HTTP 请求代码。</p>
<ul>
<li><p><strong>用途</strong>：<code>@FeignClient</code> 主要用于微服务架构中，用于简化服务间通信。它允许您定义接口，这些接口映射到远程服务的 API 端点，然后通过调用接口的方法来发起 HTTP 请求。</p>
</li>
<li><p><strong>属性</strong>：<code>@FeignClient</code> 注解有一些重要的属性，其中两个主要的属性是：</p>
<ol>
<li><code>value</code>（或 <code>name</code>）：用于指定要访问的远程服务的名称，通常是注册中心中服务的名称。通过这个属性，Feign 将找到并与远程服务建立连接。</li>
<li><code>url</code>：用于指定远程服务的基本 URL。如果您知道远程服务的确切位置，可以直接指定 <code>url</code>。</li>
</ol>
</li>
<li><p><strong>其他配置属性</strong>：除了上述两个属性外，<code>@FeignClient</code> 还支持其他配置属性，用于配置 Feign 客户端的行为，例如请求和响应的编解码器、超时设置、拦截器等。</p>
</li>
<li><p><strong>接口定义</strong>：在使用 <code>@FeignClient</code> 注解时，您需要定义一个 Java 接口，接口中的方法与远程服务的 API 端点相匹配。这些方法通常使用 Spring MVC 注解来定义请求映射和参数绑定。</p>
</li>
<li><p><strong>自动代理</strong>：Spring Cloud 会自动为使用 <code>@FeignClient</code> 注解的接口创建代理实现，该代理实现会自动将方法调用转发到远程服务。</p>
</li>
<li><p><strong>熔断降级</strong>：<code>@FeignClient</code> 还支持集成熔断降级机制，以处理远程服务的故障情况。您可以通过配置降级类或工厂来定义降级逻辑，以确保系统在远程服务不可用时仍然能够提供一定程度的可用性。</p>
</li>
<li><p><strong>fallbackfactory</strong></p>
<p>页面静态化，雪崩需要，熔断处理，，上游降级处理</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.content.feignclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xuecheng.content.config.MultipartSupportConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestPart;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 远程调用媒资服务的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/22 10:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用fallback定义降级类是无法拿到熔断异常,使用FallbackFactory可以拿到熔断的异常信息</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;media-api&quot;,configuration = &#123;MultipartSupportConfig.class&#125;,fallbackFactory = MediaServiceClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MediaServiceClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/media/upload/coursefile&quot;,consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestPart(&quot;filedata&quot;)</span> MultipartFile filedata,</span></span><br><span class="line"><span class="params">                                      <span class="meta">@RequestParam(value= &quot;objectName&quot;,required=false)</span> String objectName)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.content.feignclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.hystrix.FallbackFactory;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/22 14:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearchServiceClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;SearchServiceClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SearchServiceClient <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SearchServiceClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Boolean <span class="title function_">add</span><span class="params">(CourseIndex courseIndex)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;添加课程索引发生熔断,索引信息:&#123;&#125;,熔断异常:&#123;&#125;&quot;</span>,courseIndex,throwable.toString(),throwable);</span><br><span class="line">                <span class="comment">//走降级了返回 false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="15spring-security："><a href="#15spring-security：" class="headerlink" title="15spring security："></a>15spring security：</h2><p>进行认证授权认证框架，就是需要登录。授权模式：就是给谁访问什么资源的权限。过滤器拦截请求，</p>
<p>OAuth2：</p>
<p>授权码模式，携带授权码申请令牌，code&#x3D;TBiipf; acess_code &#x3D; ;        </p>
<p>密码模式，loadusername：连接数据库认证 userdetailservice: </p>
<p>单点登录 统一认证入口:账号密码，微信，手机验证码 </p>
<p>1.认证请求参数，</p>
<p>2.屏蔽密码校验 自定义 DaoAuthenticationProvider</p>
<p>3.自定义实现方法exeute();</p>
<p>登录成功有cookie</p>
<ol>
<li><p><strong>身份验证（Authentication）</strong>：Spring Security 提供了多种身份验证机制，包括基于用户名和密码的认证、基于令牌的认证（如OAuth2和JWT）、LDAP、OpenID Connect 等。它支持自定义身份验证提供者，使您能够集成不同的身份验证方法。</p>
<p><strong>JWT</strong></p>
<p>(JSON web Token)令牌：自验证令牌合法性，客户端(申请令牌) – 认证服务（签名生成JWT令牌） – 资源服务（当客户端携带jwt令牌访问资源时，检验令牌合法性）对称加密。对资源进管控。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.auth.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenConfig</span> &#123;</span><br><span class="line">    <span class="comment">//JWT令牌</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">SIGNING_KEY</span> <span class="operator">=</span> <span class="string">&quot;mq123&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public TokenStore tokenStore() &#123;</span></span><br><span class="line"><span class="comment">//        //使用内存存储令牌（普通令牌）</span></span><br><span class="line"><span class="comment">//        return new InMemoryTokenStore();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter accessTokenConverter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TokenStore <span class="title function_">tokenStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JwtTokenStore</span>(accessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JwtAccessTokenConverter <span class="title function_">accessTokenConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JwtAccessTokenConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JwtAccessTokenConverter</span>();</span><br><span class="line">        converter.setSigningKey(SIGNING_KEY);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//令牌管理服务</span></span><br><span class="line">    <span class="meta">@Bean(name=&quot;authorizationServerTokenServicesCustom&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationServerTokenServices <span class="title function_">tokenService</span><span class="params">()</span> &#123;</span><br><span class="line">        DefaultTokenServices service=<span class="keyword">new</span> <span class="title class_">DefaultTokenServices</span>();</span><br><span class="line">        service.setSupportRefreshToken(<span class="literal">true</span>);<span class="comment">//支持刷新令牌</span></span><br><span class="line">        service.setTokenStore(tokenStore);<span class="comment">//令牌存储策略</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TokenEnhancerChain</span> <span class="variable">tokenEnhancerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TokenEnhancerChain</span>();</span><br><span class="line">        tokenEnhancerChain.setTokenEnhancers(Arrays.asList(accessTokenConverter));</span><br><span class="line">        service.setTokenEnhancer(tokenEnhancerChain);</span><br><span class="line"></span><br><span class="line">        service.setAccessTokenValiditySeconds(<span class="number">7200</span>); <span class="comment">// 令牌默认有效期2小时</span></span><br><span class="line">        service.setRefreshTokenValiditySeconds(<span class="number">259200</span>); <span class="comment">// 刷新令牌默认有效期3天</span></span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>OAuth2</strong>配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span></span><br><span class="line">         <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  clients.inMemory()<span class="comment">// 使用in-memory存储</span></span><br><span class="line">          .withClient(<span class="string">&quot;XcWebApp&quot;</span>)<span class="comment">// client_id</span></span><br><span class="line"><span class="comment">//                .secret(&quot;secret&quot;)//客户端密钥</span></span><br><span class="line">          .secret(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">&quot;XcWebApp&quot;</span>))<span class="comment">//客户端密钥</span></span><br><span class="line">          .resourceIds(<span class="string">&quot;xuecheng-plus&quot;</span>)<span class="comment">//资源列表</span></span><br><span class="line">          .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>, <span class="string">&quot;password&quot;</span>,<span class="string">&quot;client_credentials&quot;</span>,<span class="string">&quot;implicit&quot;</span>,<span class="string">&quot;refresh_token&quot;</span>)<span class="comment">// 该client允许的授权类型authorization_code,password,refresh_token,implicit,client_credentials</span></span><br><span class="line">          .scopes(<span class="string">&quot;all&quot;</span>)<span class="comment">// 允许的授权范围</span></span><br><span class="line">          .autoApprove(<span class="literal">false</span>)<span class="comment">//false跳转到授权页面</span></span><br><span class="line">          <span class="comment">//客户端接收授权码的重定向地址</span></span><br><span class="line">          .redirectUris(<span class="string">&quot;http://www.51xuecheng.cn&quot;</span>)</span><br><span class="line">  ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.content.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 资源服务配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/18 16:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"> <span class="meta">@EnableResourceServer</span></span><br><span class="line"> <span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResouceServerConfig</span> <span class="keyword">extends</span> <span class="title class_">ResourceServerConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//资源服务标识</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RESOURCE_ID</span> <span class="operator">=</span> <span class="string">&quot;xuecheng-plus&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> &#123;</span><br><span class="line">   resources.resourceId(RESOURCE_ID)<span class="comment">//资源 id</span></span><br><span class="line">           .tokenStore(tokenStore)</span><br><span class="line">           .stateless(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  http.csrf().disable()</span><br><span class="line">          .authorizeRequests()</span><br><span class="line"><span class="comment">//          .antMatchers(&quot;/r/**&quot;,&quot;/course/**&quot;).authenticated()//所有/r/**的请求必须认证通过</span></span><br><span class="line">          .anyRequest().permitAll()</span><br><span class="line">  ;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>授权（Authorization）</strong>：Spring Security 允许您定义细粒度的访问控制策略，以决定用户是否有权访问应用程序的特定资源和功能。它支持基于角色、权限和表达式的授权。</p>
<p><strong>18RABC</strong></p>
<p>基于角色的访问控制（Role-Based Access Control）基于资源的访问控制（Resource-Based Access Control)@PreAuthorize(“hasAuthority(‘xc_teachmanager_course_list’)”)&#x2F;&#x2F;拥有课程列表查询的权限方可访问授权，解开access_token，其中就有用户的信息和该用户所拥有的权限。数据库中的表对应不同角色的权限。在mapper中写sql语句查询权限，通过UserDeatailService()获取数据返回到前端，当用户访问资源时，即可判断是否拥有权限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;课程查询接口&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;xc_teachmanager_course_list&#x27;)&quot;)</span><span class="comment">//拥有课程列表查询的权限方可访问</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/course/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> PageResult&lt;CourseBase&gt; <span class="title function_">list</span><span class="params">(PageParams pageParams, <span class="meta">@RequestBody</span> QueryCourseParamsDto queryCourseParams)</span>&#123;</span><br><span class="line">    SecurityUtil.<span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> SecurityUtil.getUser();</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="comment">//获取到用户所属机构的id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">companyId</span> <span class="operator">=</span> user.getCompanyId();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> courseBaseInfoService.queryCourseBaseList(Long.parseLong(companyId),pageParams,queryCourseParams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>授权拿到的jwt令牌中包含从数据库查到的信息，解开后这其中就含有对应角色应有的权限，这时候在对比方法上所限制的权限看是否相同，相同则可执行该方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#&#123;</span><br><span class="line">#  &quot;aud&quot;: [</span><br><span class="line">#    &quot;xuecheng-plus&quot;</span><br><span class="line">#  ],</span><br><span class="line">#  &quot;user_name&quot;: &quot;&#123;\&quot;birthday\&quot;:\&quot;2022-09-28T19:28:46\&quot;,\&quot;createTime\&quot;:\&quot;2022-09-28T08:32:03\&quot;,\&quot;id\&quot;:\&quot;50\&quot;,\&quot;name\&quot;:\&quot;学生1\&quot;,\&quot;nickname\&quot;:\&quot;大水牛\&quot;,\&quot;sex\&quot;:\&quot;1\&quot;,\&quot;status\&quot;:\&quot;1\&quot;,\&quot;username\&quot;:\&quot;stu1\&quot;,\&quot;userpic\&quot;:\&quot;http://file.51xuecheng.cn/dddf\&quot;,\&quot;utype\&quot;:\&quot;101001\&quot;&#125;&quot;,</span><br><span class="line">#  &quot;scope&quot;: [</span><br><span class="line">#    &quot;all&quot;</span><br><span class="line">#  ],</span><br><span class="line">#  &quot;active&quot;: true,</span><br><span class="line">#  &quot;exp&quot;: 1691154163,</span><br><span class="line">#  &quot;authorities&quot;: [</span><br><span class="line">#    &quot;p1&quot;</span><br><span class="line">#  ],</span><br><span class="line">#  &quot;jti&quot;: &quot;658a7d2a-83fb-42a4-860e-88233f637756&quot;,</span><br><span class="line">#  &quot;client_id&quot;: &quot;XcWebApp&quot;</span><br><span class="line">#&#125;</span><br><span class="line">#Response file saved.</span><br><span class="line">#&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>攻击防护（Attack Protection）</strong>：Spring Security 提供了内置的攻击防护机制，包括跨站请求伪造（CSRF）防护、跨站脚本攻击（XSS）防护、点击劫持防护等。它还支持 HTTP 头部控制和内容安全策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置安全拦截机制</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">            .csrf().disable() </span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/r/**&quot;</span>).authenticated()<span class="comment">//访问/r开始的请求需要认证通过</span></span><br><span class="line">            .anyRequest().permitAll()<span class="comment">//其它请求全部放行</span></span><br><span class="line">            .and()</span><br><span class="line">            .formLogin().successForwardUrl(<span class="string">&quot;/login-success&quot;</span>);<span class="comment">//登录成功跳转到/login-success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>会话管理（Session Management）</strong>：Spring Security 允许您管理用户会话，包括限制同一用户的并发会话数量、会话超时设置、会话注销等。</p>
</li>
<li><p><strong>单点登录（Single Sign-On，SSO）</strong>：Spring Security 可以与其他单点登录解决方案（如Spring Security OAuth2、Keycloak等）集成，以支持单点登录和单点注销。</p>
<p><strong>先建立统一的数据模型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.model.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 认证用户请求参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 10:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthParamsDto</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">//域  用于扩展</span></span><br><span class="line">    <span class="keyword">private</span> String cellphone;<span class="comment">//手机号</span></span><br><span class="line">    <span class="keyword">private</span> String checkcode;<span class="comment">//验证码</span></span><br><span class="line">    <span class="keyword">private</span> String checkcodekey;<span class="comment">//验证码key</span></span><br><span class="line">    <span class="keyword">private</span> String authType; <span class="comment">// 认证的类型   password:用户名密码模式类型    sms:短信模式类型</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; payload = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//附加数据，作为扩展，不同认证类型可拥有不同的附加数据。如认证类型为短信时包含smsKey : sms:3d21042d054548b08477142bbca95cfa; 所有情况下都包含clientId</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>建立统一的登录入口当登录时都会走userdeatailservice方法，根据解析出来的登录的不同方式去执行不同的excute()方法，账号密码，微信登录，自定义UserDetailsService用来对接Spring Security 统一认证入口，具体的实现取对应功能的service</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 自定义UserDetailsService用来对接Spring Security 统一认证入口，具体的实现取对应功能的service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/28 18:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    AuthService authService;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 查询用户信息组成用户身份信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s  AuthParamsDto类型的json数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.security.core.userdetails.UserDetails</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/28 18:30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AuthParamsDto</span> <span class="variable">authParamsDto</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将认证参数转为AuthParamsDto类型</span></span><br><span class="line">            authParamsDto = JSON.parseObject(s, AuthParamsDto.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;认证请求不符合项目要求:&#123;&#125;&quot;</span>,s);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;认证请求数据格式不对&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//认证方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authType</span> <span class="operator">=</span> authParamsDto.getAuthType();</span><br><span class="line">        <span class="type">AuthService</span> <span class="variable">authService</span> <span class="operator">=</span>  applicationContext.getBean(authType + <span class="string">&quot;_authservice&quot;</span>,AuthService.class);</span><br><span class="line">        <span class="type">XcUserExt</span> <span class="variable">user</span> <span class="operator">=</span> authService.execute(authParamsDto);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getUserPrincipal(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要实现的登录方法都要实现这个接口，实现不同的excute方法即可</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.dto.AuthParamsDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.dto.XcUserExt;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 认证service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 12:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authParamsDto 认证参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> com.xuecheng.ucenter.model.po.XcUser 用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/29 12:11</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    XcUserExt <span class="title function_">execute</span><span class="params">(AuthParamsDto authParamsDto)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>微信第三方登录</strong></p>
<p>code + appid +appsecret 换取access_token 用户授权同意，申请令牌，发放令牌，保存用户，自动登录，认证通过。RestTemplate第三方远程调用 , 收到code调用微信接口申请access_token，哪access_token查询用户信息，将用户信息保存到数据库代理对象控制事务，</p>
<p>1改nacos(填写appid和secret)weixin:appid: wxed9954c01bb89b47secret: a7482517235173ddb4083788de60b90e</p>
<p>2改wxlogin.html(填写appid和重定向地址)appid: “wxed9954c01bb89b47”,scope: “snsapi_login”,redirect_uri: “<a href="http://localhost:8160/api/auth/wxLogin">http://localhost:8160/api/auth/wxLogin</a>“,</p>
<p>3改nginx，开8610端口server {listen 8160;server_name localhost;<br>location &#x2F;api {proxy_pass <a href="http://gatewayserver;/">http://gatewayserver;</a>#proxy_pass <a href="http://localhost:63010;/">http://localhost:63010;</a>proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br># 这里需要添加一个rewrite规则，把请求中的&#x2F;api去掉rewrite ^&#x2F;api(.*)$ $1 break;}}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 微信扫码认证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 12:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service(&quot;wx_authservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthService</span>, WxAuthService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WxAuthServiceImpl currentProxy;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;weixin.appid&#125;&quot;)</span></span><br><span class="line">    String appid;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;weixin.secret&#125;&quot;)</span></span><br><span class="line">    String secret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//和微信对接完成后，重定向地址后，自动登录</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> XcUserExt <span class="title function_">execute</span><span class="params">(AuthParamsDto authParamsDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//账号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authParamsDto.getUsername();</span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getUsername, username));</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//返回空表示用户不存在</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;账号不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">XcUserExt</span> <span class="variable">xcUserExt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XcUserExt</span>();</span><br><span class="line">        BeanUtils.copyProperties(user,xcUserExt);</span><br><span class="line">        <span class="keyword">return</span> xcUserExt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//和微信对接的方法</span></span><br><span class="line">    <span class="keyword">public</span> XcUser <span class="title function_">wxAuth</span><span class="params">(String code)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收到code调用微信接口申请access_token</span></span><br><span class="line">        Map&lt;String, String&gt; access_token_map = getAccess_token(code);</span><br><span class="line">        <span class="keyword">if</span>(access_token_map==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(access_token_map);</span><br><span class="line">        <span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> access_token_map.get(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">access_token</span> <span class="operator">=</span> access_token_map.get(<span class="string">&quot;access_token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿access_token查询用户信息</span></span><br><span class="line">        Map&lt;String, String&gt; userinfo = getUserinfo(access_token, openid);</span><br><span class="line">        <span class="keyword">if</span>(userinfo==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将用户信息保存到数据库</span></span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> currentProxy.addWxUser(userinfo);</span><br><span class="line">        <span class="keyword">return</span> xcUser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 申请访问令牌,响应示例</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">         &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,</span></span><br><span class="line"><span class="comment">         &quot;expires_in&quot;:7200,</span></span><br><span class="line"><span class="comment">         &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span></span><br><span class="line"><span class="comment">         &quot;openid&quot;:&quot;OPENID&quot;,</span></span><br><span class="line"><span class="comment">         &quot;scope&quot;:&quot;SCOPE&quot;,</span></span><br><span class="line"><span class="comment">         &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Map&lt;String,String&gt; <span class="title function_">getAccess_token</span><span class="params">(String code)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">wxUrl_template</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=%s&amp;secret=%s&amp;code=%s&amp;grant_type=authorization_code&quot;</span>;</span><br><span class="line">            <span class="comment">//请求微信地址</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">wxUrl</span> <span class="operator">=</span> String.format(wxUrl_template, appid, secret, code);</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;调用微信接口申请access_token, url:&#123;&#125;&quot;</span>, wxUrl);</span><br><span class="line">            <span class="comment">//远程调用URL</span></span><br><span class="line">            ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(wxUrl, HttpMethod.POST, <span class="literal">null</span>, String.class);</span><br><span class="line">            <span class="comment">//响应结果</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> exchange.getBody();</span><br><span class="line">            log.info(<span class="string">&quot;调用微信接口申请access_token: 返回值:&#123;&#125;&quot;</span>, result);</span><br><span class="line">            <span class="comment">//result转为map</span></span><br><span class="line">            Map&lt;String,String&gt; resultMap = JSON.parseObject(result, Map.class);</span><br><span class="line">            <span class="keyword">return</span> resultMap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**获取用户信息，示例如下：</span></span><br><span class="line"><span class="comment">     &#123;</span></span><br><span class="line"><span class="comment">     &quot;openid&quot;:&quot;OPENID&quot;,</span></span><br><span class="line"><span class="comment">     &quot;nickname&quot;:&quot;NICKNAME&quot;,</span></span><br><span class="line"><span class="comment">     &quot;sex&quot;:1,</span></span><br><span class="line"><span class="comment">     &quot;province&quot;:&quot;PROVINCE&quot;,</span></span><br><span class="line"><span class="comment">     &quot;city&quot;:&quot;CITY&quot;,</span></span><br><span class="line"><span class="comment">     &quot;country&quot;:&quot;COUNTRY&quot;,</span></span><br><span class="line"><span class="comment">     &quot;headimgurl&quot;: &quot;https://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0&quot;,</span></span><br><span class="line"><span class="comment">     &quot;privilege&quot;:[</span></span><br><span class="line"><span class="comment">     &quot;PRIVILEGE1&quot;,</span></span><br><span class="line"><span class="comment">     &quot;PRIVILEGE2&quot;</span></span><br><span class="line"><span class="comment">     ],</span></span><br><span class="line"><span class="comment">     &quot;unionid&quot;: &quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; <span class="title function_">getUserinfo</span><span class="params">(String access_token,String openid)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">wxUrl_template</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/sns/userinfo?access_token=%s&amp;openid=%s&quot;</span>;</span><br><span class="line">        <span class="comment">//请求微信地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">wxUrl</span> <span class="operator">=</span> String.format(wxUrl_template, access_token,openid);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;调用微信接口申请access_token, url:&#123;&#125;&quot;</span>, wxUrl);</span><br><span class="line"></span><br><span class="line">        ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(wxUrl, HttpMethod.POST, <span class="literal">null</span>, String.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//防止乱码进行转码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span>     <span class="title class_">String</span>(exchange.getBody().getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);</span><br><span class="line">        log.info(<span class="string">&quot;调用微信接口申请access_token: 返回值:&#123;&#125;&quot;</span>, result);</span><br><span class="line">        <span class="comment">//map转json</span></span><br><span class="line">        Map&lt;String,String&gt; resultMap = JSON.parseObject(result, Map.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserRoleMapper xcUserRoleMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> XcUser <span class="title function_">addWxUser</span><span class="params">(Map&lt;String,String&gt; userInfo_map)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">unionid</span> <span class="operator">=</span> userInfo_map.get(<span class="string">&quot;unionid&quot;</span>).toString();</span><br><span class="line">        <span class="comment">//根据unionid查询数据库</span></span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getWxUnionid, unionid));</span><br><span class="line">        <span class="keyword">if</span>(xcUser!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> xcUser;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        xcUser = <span class="keyword">new</span> <span class="title class_">XcUser</span>();</span><br><span class="line">        xcUser.setId(userId);</span><br><span class="line">        xcUser.setWxUnionid(unionid);</span><br><span class="line">        <span class="comment">//记录从微信得到的昵称</span></span><br><span class="line">        xcUser.setNickname(userInfo_map.get(<span class="string">&quot;nickname&quot;</span>).toString());</span><br><span class="line">        xcUser.setUserpic(userInfo_map.get(<span class="string">&quot;headimgurl&quot;</span>).toString());</span><br><span class="line">        xcUser.setName(userInfo_map.get(<span class="string">&quot;nickname&quot;</span>).toString());</span><br><span class="line">        xcUser.setUsername(unionid);</span><br><span class="line">        xcUser.setPassword(unionid);</span><br><span class="line">        xcUser.setUtype(<span class="string">&quot;101001&quot;</span>);<span class="comment">//学生类型</span></span><br><span class="line">        xcUser.setStatus(<span class="string">&quot;1&quot;</span>);<span class="comment">//用户状态</span></span><br><span class="line">        xcUser.setCreateTime(LocalDateTime.now());</span><br><span class="line">        xcUserMapper.insert(xcUser);</span><br><span class="line">        <span class="type">XcUserRole</span> <span class="variable">xcUserRole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XcUserRole</span>();</span><br><span class="line">        xcUserRole.setId(UUID.randomUUID().toString());</span><br><span class="line">        xcUserRole.setUserId(userId);</span><br><span class="line">        xcUserRole.setRoleId(<span class="string">&quot;17&quot;</span>);<span class="comment">//学生角色</span></span><br><span class="line">        xcUserRoleMapper.insert(xcUserRole);</span><br><span class="line">        <span class="keyword">return</span> xcUser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自定义过滤器链（Custom Filter Chain）</strong>：Spring Security 允许您配置自定义的过滤器链，以便处理特定的安全性需求，如自定义身份验证、审计等。</p>
<p>不是所有的登录方式都需要密码验证，屏蔽掉密码验证，重写该方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.auth.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.BadCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.dao.DaoAuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 自定义DaoAuthenticationProvider</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 10:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoAuthenticationProviderCustom</span> <span class="keyword">extends</span> <span class="title class_">DaoAuthenticationProvider</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDetailsService</span><span class="params">(UserDetailsService userDetailsService)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setUserDetailsService(userDetailsService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//屏蔽密码对比</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>集成性</strong>：Spring Security 可以与 Spring 框架以及其他常见的 Java Web 框架（如Spring Boot、Spring MVC、Spring Cloud等）无缝集成。</p>
</li>
<li><p><strong>可扩展性</strong>：Spring Security 是高度可扩展的，允许您编写自定义的安全性组件和扩展点，以满足应用程序的特定需求。</p>
</li>
<li><p><strong>社区支持</strong>：Spring Security 拥有强大的社区支持和活跃的开发团队，定期发布更新和修复漏洞。</p>
</li>
</ol>
<h2 id="16支付宝支付"><a href="#16支付宝支付" class="headerlink" title="16支付宝支付"></a>16支付宝支付</h2><p><strong>流程：登录–选课–支付 （用户登录，教师发布课程，选择付费课程（付费的状态），选课表的id在订单表中为out_bussinisse_id, 订单明细表记录订单id）</strong></p>
<p>（用户下单，查询支付结果，结果通知）<strong>心态崩了，一个端口搞得我好几天，真服了，还是太马虎了</strong> <a href="hhtp://192.168.1.103:63030/orders/requestpay?payNo=%S;">hhtp:&#x2F;&#x2F;192.168.1.103:63030&#x2F;orders&#x2F;requestpay?payNo&#x3D;%S;</a></p>
<p><strong>非事务方法调用事务方法需要通过代理对象，该proxy即是本实现类的复制。 @Autowired OrederServiceImpl currentproxy;</strong><br>nacos配置appid，秘钥，注入到程序中。下载沙箱进行测试；用户–商户–支付宝。下单，支付请求，返回url，通知结果url，请求关闭订单，返回结果。 退款，对账。</p>
<p>生成支付的二维码: ZXing是用Java编写的多格式的1D &#x2F; 2D条码图像处理库，使用ZXing可以生成、识别QR Code（二维码）。</p>
<p>base工程utils下配置二维码类内网穿透的域名暂时没有买：9块钱一个月，就是需要每次启动内网穿透让后修改notify的地址。</p>
<p>alipayRequest.setNotifyUrl(<a href="http://xxx/orders/receivenotify);%E8%AE%A2%E5%8D%95%E7%BB%93%E6%9E%9C%E9%80%9A%E7%9F%A5%EF%BC%9A">http://xxx/orders/receivenotify);订单结果通知：</a></p>
<p>雪花算法生成订单号，保证唯一不重复</p>
<h2 id="17-注册和找回密码；"><a href="#17-注册和找回密码；" class="headerlink" title="17:注册和找回密码；"></a>17:注册和找回密码；</h2><p>QQ邮箱找回密码：看配置，有模版。在找回密码方法的最后，实现了一些前端代码，清空和重定向。</p>
<p>注册：手机号码和邮箱一样即可。按回车登录：钩子监听事件，在created 钩子中添加键盘监听事件。在destroy中移除键盘监听事件。</p>
<h2 id="18项目部署："><a href="#18项目部署：" class="headerlink" title="18项目部署："></a>18项目部署：</h2><p>一次部署一劳永逸，DevOps：CI&#x2F;CD:类生产环境：Kubernetes:</p>
<h1 id="19项目优化："><a href="#19项目优化：" class="headerlink" title="19项目优化："></a>19项目优化：</h1><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试:"></a>压力测试:</h2><p>吞吐量TPS:(Transaction per second)每秒可以处理的事务，一次完整的业务流程。        </p>
<p>响应时间:从发送请求到响应结果所需的时间       </p>
<p> 每秒查询次数，(Queries per second) 每秒可以查询接口的次数，可以多次TPS        </p>
<p> 错误率 :错误次数占总次数的比率。        </p>
<p> 网盘io：压测软件：Apache jmeter 新建接口测试，看汇总报告和结果。       </p>
<p>  log4j2-dev.xml : &lt;Root level : “info” &gt;debug输出日志太耗费内存 </p>
<p><img src="/img/yace.png"></p>
<h2 id="缓存优化："><a href="#缓存优化：" class="headerlink" title="缓存优化："></a>缓存优化：</h2><p>以下东西放缓存：白名单:不用登录就可试学视频。客户端需要的东西：redis键值对key-value, key:自定义的”course” + courseId (course18); value 即为16进制下的缓存在redis中的数据。查询课程发布信息，先查缓存再查数据库，缓存中没有就查询数据库，然后保存到缓存中。吞吐量：1000</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   RedisTemplate redisTemplate;</span><br><span class="line">   <span class="keyword">public</span> CoursePublish <span class="title function_">getCoursePublishCache</span><span class="params">(Long courseId)</span>&#123;</span><br><span class="line">       <span class="comment">//查询缓存</span></span><br><span class="line">       <span class="type">Object</span>  <span class="variable">jsonObj</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);</span><br><span class="line">       <span class="keyword">if</span>(jsonObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> jsonObj.toString();</span><br><span class="line">           System.out.println(<span class="string">&quot;=================从缓存查=================&quot;</span>);</span><br><span class="line">           <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);</span><br><span class="line">           <span class="keyword">return</span> coursePublish;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;从数据库查询...&quot;</span>);</span><br><span class="line">           <span class="comment">//从数据库查询</span></span><br><span class="line">           <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> getCoursePublish(courseId);</span><br><span class="line">           <span class="keyword">if</span>(coursePublish!=<span class="literal">null</span>)&#123;</span><br><span class="line">               redisTemplate.opsForValue().set(<span class="string">&quot;course:&quot;</span> + courseId, JSON.toJSONString(coursePublish));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> coursePublish;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h2><p>查询不数据库中不存在的数据导致缓存失效，即缓存被穿透了。 </p>
<p> <img src="/img/hcct.png">       </p>
<p>一般发生在高并发请求。假设查询存在的课程，多个线程第一次过来，都没有缓存，都从数据库查了。 假设查询不存在的课程，缓存中肯定没有，那么都会从数据库中查询了。</p>
<p>解决缓存穿透：</p>
<p>1.请求校验机制：合适的数据格式，            </p>
<p>2.布隆过滤器：缓存预热：先把所有的课程id保存在HashMap中，先校验是否存在HashMap，再决定是否查询数据库。相当于一层过滤。返回0，表示一定不存在。返回1，表示Map中存在courseId的Hash值。     </p>
<p>3.缓存null值或特殊值  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line">    <span class="keyword">public</span> CoursePublish <span class="title function_">getCoursePublishCache</span><span class="params">(Long courseId)</span>&#123;</span><br><span class="line">        <span class="comment">//查询缓存</span></span><br><span class="line">        <span class="type">Object</span>  <span class="variable">jsonObj</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);</span><br><span class="line">        <span class="keyword">if</span>(jsonObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> jsonObj.toString();</span><br><span class="line">            <span class="keyword">if</span>(jsonString.equals(<span class="string">&quot;null&quot;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//缓存中value是null，直接返回null即可。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;=================从缓存查=================&quot;</span>);</span><br><span class="line">            <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);</span><br><span class="line">            <span class="keyword">return</span> coursePublish;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;从数据库查询...&quot;</span>);</span><br><span class="line">            <span class="comment">//从数据库查询</span></span><br><span class="line">            <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> getCoursePublish(courseId);</span><br><span class="line"><span class="comment">//            if(coursePublish!=null)&#123;</span></span><br><span class="line"><span class="comment">//            redisTemplate.opsForValue().set(&quot;course:&quot; + courseId, JSON.toJSONString(coursePublish));</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;course:&quot;</span> + courseId, JSON.toJSONString(coursePublish),<span class="number">30</span>, TimeUnit.SECONDS); <span class="comment">//从数据库中查到value为null，照样存到数据库中，其值为null，设置过期时间30s（尽量较小） ，避免未来有正确的课程时其值还是null。 \xAC\xED\x00\x05t\x00\x04null</span></span><br><span class="line">            <span class="keyword">return</span> coursePublish;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>吞吐量1800。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩:"></a>缓存雪崩:</h2><p>在高并发的场景下，比如缓存1w个课程，有1w个key，但是这1w个课程的key过期时间一致，即key同时失效。这时候，大量的请求又会同时去请求数据库，造成数据库资源耗尽，最终造成雪崩。</p>
<p>解决缓存雪崩：</p>
<p>1.用锁解决：synchronized( Obj ){ }；效率不高。       </p>
<p> 2.key设置不同的时间即可：尽量避免再次同时访问数据库。对某一类的key缓存的时间是不一样的：入课程信息：300s，媒体信息：400s。&#x2F;&#x2F;设置过期时间300秒 redisTemplate.opsForValue().set(“course:” + courseId, JSON.<em>toJSONString</em>(coursePublish),300+new Random().nextInt(100), TimeUnit.<em>SECONDS</em>); </p>
<p>3.缓存预热：写个定时任务：发现key快失效了，再重新将key写入缓存。10s缓存一次。</p>
<h2 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h2><p>大量的并发同时访问同一个热点数据，当这个热点数据失效时，并发请求会同时去请求数据库，数据库资源耗尽。如某新品手机发布会，当缓存失效，大量并发到来，同时访问数据数据库。</p>
<p><img src="/img/hcjc.png"></p>
<p>解决缓存击穿：</p>
<p>1.加同步锁：使用同步锁控制查询数据库的代码，只允许有一个线程去查询数据库，查询得到的数据再存入缓存。synchronized(this){ 需要查询数据库的代码 };service ： 单例，多个线程共享实例，共同争抢这把锁，才能锁住。</p>
<p>   2.key-vlaue缓存时间不过期，后台做好缓存的同步即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  CoursePublish <span class="title function_">getCoursePublishCache</span><span class="params">(Long courseId)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询缓存</span></span><br><span class="line">    <span class="type">Object</span>  <span class="variable">jsonObj</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);</span><br><span class="line">    <span class="keyword">if</span>(jsonObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> jsonObj.toString();</span><br><span class="line">        <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);</span><br><span class="line">        <span class="keyword">return</span> coursePublish;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="comment">//第一次进来缓存肯定是空的，当第一个线程查完数据库，存入redis，第二个线程拿到锁直接查缓存，不需要再次查数据库。</span></span><br><span class="line">            <span class="type">Object</span>  <span class="variable">jsonObj</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);</span><br><span class="line">            <span class="keyword">if</span>(jsonObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> jsonObj.toString();</span><br><span class="line">                <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);</span><br><span class="line">                <span class="keyword">return</span> coursePublish;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;=========从数据库查询==========&quot;</span>);</span><br><span class="line">            <span class="comment">//从数据库查询</span></span><br><span class="line">            <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> getCoursePublish(courseId);</span><br><span class="line">            <span class="comment">//设置过期时间300秒</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;course:&quot;</span> + courseId, JSON.toJSONString(coursePublish),<span class="number">300</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">return</span> coursePublish;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="速记："><a href="#速记：" class="headerlink" title="速记："></a>速记：</h3><p>无中生有是穿透，布隆过滤null隔离。缓存击穿key过期， 锁与非期解难题。大量过期成雪崩，过期时间要随机。面试必考三兄弟，可用限流来保底。</p>
<h3 id="限流技术方案："><a href="#限流技术方案：" class="headerlink" title="限流技术方案："></a>限流技术方案：</h3><p>alibaba&#x2F;Sentinel nginx+Lua分布式锁：一个同步锁只能保证同一个虚拟中的多个进程，其中只有一个线程去查数据库。那么存在多个虚拟机，高并发网关通过网关负载均衡转发给各个虚拟机，此时就会存在多个线程去查数据库。        </p>
<h3 id="此时需要分布式锁："><a href="#此时需要分布式锁：" class="headerlink" title="此时需要分布式锁："></a>此时需要分布式锁：</h3><p>分布式环境下：所有虚拟机的线程去同步执行，让多个虚拟机去抢同一个锁。         此时的锁是一个单独的程序：提供解锁，上锁的服务，谁抢到锁，谁去查询数据库</p>
<p><img src="/img/fbss.png"></p>
<h1 id="实现分布式锁："><a href="#实现分布式锁：" class="headerlink" title="实现分布式锁："></a>实现分布式锁：</h1><h2 id="1-基于数据库实现："><a href="#1-基于数据库实现：" class="headerlink" title="1.基于数据库实现："></a>1.基于数据库实现：</h2><p>利用数据库主键唯一性的特点，索引唯一性，多个线程同时去插入相同的记录·，谁插入成功，谁抢到锁。（乐观锁，悲观锁）媒体资源的视频上传文件当中就运用了此分布式上传文件的方法。             </p>
<h2 id="2-基于redis实现锁："><a href="#2-基于redis实现锁：" class="headerlink" title="2.基于redis实现锁："></a>2.基于redis实现锁：</h2><p>SETNX，redission。SETNX的命令的工作过程是：去set一个不存在的key，多个线程去设置同一个key，只会有一个线程设置成功，设置成功的即拿到锁。             </p>
<h2 id="3-使用zookeeper实现。"><a href="#3-使用zookeeper实现。" class="headerlink" title="3.使用zookeeper实现。"></a>3.使用zookeeper实现。</h2><p>zookeeper的结构类似的文件目录，多线程向zookeeper创建一个子目录(节点)只会有一个创建成功，利用此特点可以实现分布式锁，谁创建该结点成功谁就获得锁实现分布式锁： </p>
<p>1.SETNX <a href="http://www.redis.cn/commands/set.html">http://www.redis.cn/commands/set.html</a> set lock01 01 NX EX 30  EX <em>seconds</em> – 设置键key的过期时间，单位时秒PX <em>milliseconds</em> – 设置键key的过期时间，单位时毫秒NX – 只有键key不存在的时候才会设置key的值XX – 只有键key存在的时候才会设置key的值</p>
<h2 id="如何释放锁："><a href="#如何释放锁：" class="headerlink" title="如何释放锁："></a>如何释放锁：</h2><h3 id="1-key过期自动释放"><a href="#1-key过期自动释放" class="headerlink" title="1.key过期自动释放"></a>1.key过期自动释放</h3><p>过期时间不好把控，快了则任务没处理完成，其他线程再来重复操作，慢了则增加其他线程等待时间。          </p>
<h3 id="2-手动删除"><a href="#2-手动删除" class="headerlink" title="2.手动删除"></a>2.手动删除</h3><p> if(缓存中有){<br> 返回缓存中的数据}else{<br> 获取分布式锁: Boolean lock01 &#x3D; redisTemplate.opsForValue().setIfAbsent(“coursequerylock”+courseId , 01，200，TimeUtil. Second) if(获取锁成功）{    try{     查询数据库   }finally{     if(redis.call(“get”,”lock”)&#x3D;&#x3D;”01”){      释放锁: redis.call(“del”,”lock”)     }}}}<br>这整个操作(拿锁，查数据库，释放锁)是原子性的：但是需要借助Lua脚本，即要么都成功，要么都失败，不能给CPu轮转时间片调度。最后，释放时间还是不好把控。   </p>
<h2 id="2-redisson"><a href="#2-redisson" class="headerlink" title="2.redisson:"></a>2.redisson:</h2><p>Redisson的文档地址：<a href="https://github.com/redisson/redisson/wiki/Table-of-Content">https://github.com/redisson/redisson/wiki/Table-of-Content</a> </p>
<p><img src="/img/reddison.png"></p>
<p>Redisson的执行逻辑：         </p>
<ol>
<li><h3 id="加锁机制："><a href="#加锁机制：" class="headerlink" title="加锁机制："></a>加锁机制：</h3><p>线程去获取锁，获取成功: 执行lua脚本，保存数据到redis数据库。线程去获取锁，获取失败: 一直通过while循环尝试获取锁，获取成功后，执行lua脚本，保存数据到redisRLock继承JDK的Lock接口，所以他有Lock接口的所有特性，比如lock、unlock、trylock等特性,同时它还有很多新特性：强制锁释放，带有效期的锁,使用Redisson可以方便的把Java本地内存中常用的数据结构对象搬到分布式缓存redis中。       ReentrantLock rtl &#x3D; new  ReentrantLock();       rtl.trylock();       try{       &#x2F;&#x2F;代码执行逻辑     }finally{     rtl.unlock();   }</p>
</li>
<li><h3 id="watchdog"><a href="#watchdog" class="headerlink" title="watchdog:"></a>watchdog:</h3><p>启动一个watch dog后台线程，不断的延长锁key的生存时间。对锁进行续期，30s后当前线程未完成再续时间。</p>
</li>
<li><h3 id="lua脚本："><a href="#lua脚本：" class="headerlink" title="lua脚本："></a>lua脚本：</h3><p>保证原子性操作：主要是如果你的业务逻辑复杂的话，通过封装在lua脚本中发送给redis，而且redis是单线程的，这样就保证这段复杂业务逻辑执行的原子性</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RRLock</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//----------------------Lock接口方法-----------------------</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁 锁的有效期默认30秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁 可以手动设置锁的有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁有效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit      时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tryLock()方法是有返回值的，用来尝试获取锁，</span></span><br><span class="line"><span class="comment">     * 如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false .</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，</span></span><br><span class="line"><span class="comment">     * 只不过区别在于这个方法在拿不到锁时会等待一定的时间，</span></span><br><span class="line"><span class="comment">     * 在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比上面多一个参数，多添加一个锁的有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waitTime  等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁有效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit      时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     * waitTime 大于 leaseTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>lock()<strong>：此方法为加锁，但是锁的有效期采用</strong>默认<strong><strong>30</strong></strong>秒</strong>如果主线程未释放，且当前锁未调用unlock方法，则进入到<strong>watchDog****机制</strong>如果主线程未释放，且当前锁调用unlock方法，则直接释放锁<br>代码编写：添加依赖。nacos中配置redisson的配置文件目录。在代码中添加singerServerConfig.yml文件：单机实例配置文件。    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  		<span class="meta">@Autowired</span></span><br><span class="line">        RedisTemplate redisTemplate;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        RedissonClient redissonClient;</span><br><span class="line">    <span class="comment">//Redisson分布式锁</span></span><br><span class="line">    <span class="keyword">public</span>  CoursePublish <span class="title function_">getCoursePublishCache</span><span class="params">(Long courseId)</span>&#123;</span><br><span class="line">        <span class="comment">//查询缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotEmpty(jsonString))&#123;</span><br><span class="line">            <span class="keyword">if</span>(jsonString.equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);</span><br><span class="line">            <span class="keyword">return</span> coursePublish;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//每门课程设置一个锁</span></span><br><span class="line">            <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;coursequerylock:&quot;</span>+courseId);</span><br><span class="line">            <span class="comment">//获取分布式锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                jsonString = (String) redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);</span><br><span class="line">                <span class="keyword">if</span>(StringUtils.isNotEmpty(jsonString))&#123;</span><br><span class="line">                    <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);</span><br><span class="line">                    <span class="keyword">return</span> coursePublish;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;=========从数据库查询==========&quot;</span>);</span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    Thread.sleep(60000);</span></span><br><span class="line"><span class="comment">//                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                    throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                <span class="comment">//从数据库查询</span></span><br><span class="line">                <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> getCoursePublish(courseId);</span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">&quot;course:&quot;</span> + courseId, JSON.toJSONString(coursePublish),<span class="number">1</span>,TimeUnit.DAYS);</span><br><span class="line">                <span class="keyword">return</span> coursePublish;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//手动释放锁，lua脚本</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/TTl.png"></p>
<p>TTL:自动续期：watchdog,不足30s，自动延期到30s，因为拿到锁还没有做完事情，做完事情会手动释放锁。最终测试：开启多个实例，只会有一个实例拿到锁，在过期时间前，进行数据库查询，再写入缓存。而另一个实例的线程进行等待。</p>
]]></content>
      <categories>
        <category>java项目</category>
      </categories>
      <tags>
        <tag>mybatis,java,ssm.spring,</tag>
      </tags>
  </entry>
</search>
