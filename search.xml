<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>driverlicense</title>
    <url>/2023/09/07/drivelicense/</url>
    <content><![CDATA[<h1 id="简简单单的练车日记"><a href="#简简单单的练车日记" class="headerlink" title="简简单单的练车日记"></a>简简单单的练车日记</h1><h2 id="科目一"><a href="#科目一" class="headerlink" title="科目一"></a>科目一</h2><p>哦对对对，科目一花了三天刷题，一天时间来模拟。91分飘过。</p>
<h2 id="科目二"><a href="#科目二" class="headerlink" title="科目二"></a>科目二</h2><p>8.31号开始练车，第一天熟悉地形和开车的手感，然后练了两天的侧方位，练了一天的直角转弯和曲线行驶，(<em>这里的一天指单指的45分钟或一小时</em>) ,约了18号的科二，2个星期搞定。一个星期也就练车3天，一天45分钟，但是一人一车是真的爽，教练就指导你一个，但是这教练仅仅只教了一遍点位，（此处省略C语言），抽烟，脾气不是一般的暴躁，不得不说这很符合教练的刻板印象。收了我100空调费。还是说全国的驾校教练都是统一的吗?但是总归来说，正常的教练还是希望你考证过的，不然一堆人堆积在那，驾校领导以为这个教练水平有问题，带个学员没几个考证的，可能考证之后还会有绩效什么之类的，总的来说还是希望你考过的，但是这过程注定不是轻松的。</p>
<p>倒库教了一遍就会了，9.8号所有科目都会了，再模拟几遍即可。</p>
<h3 id="技巧篇"><a href="#技巧篇" class="headerlink" title="技巧篇"></a>技巧篇</h3><p>1.车速一定是慢的，快了不好调整回来。</p>
<p>2.打方向盘一定要快，车速慢，方向盘必须快。</p>
<p>3.记点位即可，科二都是点位的。</p>
<p>4.科三还没练，不知道技巧。</p>
]]></content>
      <categories>
        <category>日常生活</category>
      </categories>
  </entry>
  <entry>
    <title>lqb</title>
    <url>/2023/09/08/lq/</url>
    <content><![CDATA[<h1 id="近几年的题目分类："><a href="#近几年的题目分类：" class="headerlink" title="近几年的题目分类："></a>近几年的题目分类：</h1><h2 id="2022填空："><a href="#2022填空：" class="headerlink" title="2022填空："></a>2022填空：</h2><p>1.大数（BigInteger）2.回文字串（String.compareTo（new StringBuider().reverse().toString()）&#x3D;&#x3D;0 ）只有String之间才能进行比较3.次数最多的字母(HashMap List Collections)Collections.sort(list);桶排序   4.数组排序数组（非常好用）：Arrays.sort();<br>6.最大子矩阵暴力循环（四重循环）左上角开始循环矩阵，寻找子矩阵中的最大值最小值，计算limit，每次记录矩阵的最大面积，最后遍历结束即可输出最大的子矩阵；<br>7.</p>
<h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><p>1.ASCII码2.卡片拼数字  数位拆分：Arrays.fill(a,2021);3.直线:Set 不含重复元素的集合(纯纯考数学，不写了)4.货物摆放：ArrayList保存因子，暴力</p>
<h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p>1.ASCII码(译码 -&gt; 编码)2.纪念日( 日期)3.核酸4.分配口罩（位运算）1&lt;&lt;5 &#x3D; 将二进制下的1左移5位 即 2^6i &amp; (1&lt;&lt;j) :i &amp; (2^6) 表示i和2^6的按位与，即检测i的j位是否为1 ,为1给第一家，为0给第二家 i&#x3D;5 101 : for(j:0循环) i &amp; (1&lt;&lt;j) i &amp;(1) 101                                     1 数位相同，结果为1，分配给第一家医院 )    </p>
<h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><p>1.组队（签到题）2.不同的字串（HashSet）3.数列求值（开long，取余）4.数的分解（排列组合）</p>
<h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><p>（只会写第一题，好难！！！s）1.签到题2.求圆内的小方格(模拟坐标，判断直线)数学题3.复数（纯纯数学。。。。。）4.测试次数（二分 + 动态规划 ）</p>
<h1 id="按照题型分类的考点"><a href="#按照题型分类的考点" class="headerlink" title="按照题型分类的考点:"></a>按照题型分类的考点:</h1><p>题目的数据范围决定了变量的数据类型</p>
<h2 id="快读"><a href="#快读" class="headerlink" title="快读:"></a>快读:</h2><p> BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(System.in));读数据：long n &#x3D; Long.parseLong(in.readLine());字符串 : String str &#x3D; in.readLine(); 数组 :String nums[] &#x3D; in.readLine().split(“ “)；   int[] arr &#x3D; new int[nums.length];   for (int i &#x3D; 0; i &lt; nums.length; i++) {  arr[i] &#x3D; Integer.parseInt(nums[i]);} 多个数据：      String nums[] &#x3D; in.readLine().split(“ “)； int n &#x3D; Integer.parseInt(nums[0]);  int m &#x3D; Integer.parseInt(nums[1]);  多行输入：StringBuilder sb &#x3D; new StringBuilder();String line;while ((line &#x3D; in.readLine()) !&#x3D; null &amp;&amp; !line.isEmpty()) {  sb.append(line).append(“\n”);}String input &#x3D; sb.toString();</p>
<h2 id="快写"><a href="#快写" class="headerlink" title="快写:"></a>快写:</h2><p> PrintWriter out &#x3D; new PrintWriter(new OutputStreamWriter(System.out));out.print(n);out.flush();</p>
<h2 id="1-搜索spfa（路径）"><a href="#1-搜索spfa（路径）" class="headerlink" title="1.搜索spfa（路径）"></a>1.搜索spfa（路径）</h2><p>求单源起点到任意点的距离，图的权值有题目决定设置中间节点和距离简单的dfs（灌溉，长草，扫雷,受伤的皇后）板子题难一点的dfs（全球变暖，滑雪，剪格子）滑雪：dp数组保存最大的距离     剪格子：回溯，剪枝全球变暖：简单的bfs（迷宫带路径输出，01迷宫）队列操作，取节点，用节点，进节点难一点的bfs（青蛙跳杯子）每次比较队列里的不同的字符串，字符串保存在set集合中，每次bfs和当前两串‘*’之间的距离，</p>
<h2 id="2-字符串StringBuilder"><a href="#2-字符串StringBuilder" class="headerlink" title="2.字符串StringBuilder"></a>2.字符串StringBuilder</h2><p>StringBuffer 回文：String.compareto (StringB(String str).reverse.toString) &#x3D;&#x3D; 0;桶排序：记录每个字符串中每个字母出现的次数int book []&#x3D;new int [26];for(int i:n){book[str.charAt(i)-‘A’]++;}sysout((char)(‘A’+i));取所有子串：for(int i&#x3D;0;i&lt;n;i++){for(int j&#x3D;i;j&lt;n;j++){ String str &#x3D; s.subString(i,j+1);}}是否单调递增：abb型：最长平衡子串：Excel：卡片：数组存放每一张卡片，循环字符串数组减去。删除字符：留下的字典序最小，while(t&gt;0){ 每次比较两个字符即可; t–;}</p>
<h2 id="3-数论欧拉筛"><a href="#3-数论欧拉筛" class="headerlink" title="3.数论欧拉筛"></a>3.数论欧拉筛</h2><p>– 求解范围内的质数以及判断某个数是否是质数：private static boolean isprime(int n){  if(n&lt;2){return false;}<br>  boolean [] isprime &#x3D; new boolean[n+1];  Arrays.fill(isprime,true);    &#x2F;&#x2F;通过标记每个质数的倍数来筛选出所有的合数，如果一个数没有  for(int i&#x3D;2;i * i &lt;&#x3D; n;i++){    if(isprime[i]){    for(int j&#x3D; i * i;j&lt;&#x3D;n;j+&#x3D;i){      isprime[j] &#x3D; false;    }  }}  return isprime[n];}因子&#x2F;质因子分解–求解质因子个数：private static int zyfj(int n) {  if(n&lt;2) {    return 0;  }  int count&#x3D;0;  for(int i&#x3D;2;i<em>i&lt;&#x3D;n;i++){    while(n % i&#x3D;&#x3D;0) {      count++;      n&#x2F;&#x3D;i;    }  }  if(n&gt;1) {    count++;  }  return count;}唯一分解定理–求解约数个数：private static int wyfj(int n) {  int count &#x3D;1;  for(int i&#x3D;2;i</em>i&lt;&#x3D;n;i++) {    int ans &#x3D;0;    while(n % i &#x3D;&#x3D;0) {      ans++;      n&#x2F;&#x3D;i;    }    if(ans&gt;0) {      count *&#x3D; (ans+1);    }  }  if(n&gt;1) {    count *&#x3D;2;  }  return count;}<br>仓库：所有的因子添加到集合中，遍历找答案纯质数：数位拆分判断每一位是否为质数，boolean数组保存0-9[]的数是否为质数大数：BigInteger,含有mod，mutiply，divide，pow, abs, 利用大数的gcd求(1-n的)lcm：等差数列：d &#x3D; (an - a1) &#x2F; (n-1); Sn &#x3D; n * (an+a1) &#x2F; 2;等比数列：q &#x3D; an &#x2F; a1 ^ (1&#x2F;(n-1)); Sn &#x3D; a1 * (1-q^n) &#x2F; (1-q); 斐波那契数列：每60项数字的余数形成一个周期；分数的表示：printf(“%d &#x2F; %d”,a,b);小数的表示：printf(“%.2f”,（double) a);阶乘约数：求100!有多少个约数，(1-100)的唯一分解定理，桶排序存放因子的出现的次数；等差素数数列：模拟数字和公差 ,while(isp(a+j)){a &#x3D; a+j; cnt++;}寻找10个连续素数的公差 约数个数：取sqrt，每次+2；大数取余，%即可取后n位；</p>
<h2 id="4-日期判断日期的合法性以及模拟一个日期："><a href="#4-日期判断日期的合法性以及模拟一个日期：" class="headerlink" title="4.日期判断日期的合法性以及模拟一个日期："></a>4.日期判断日期的合法性以及模拟一个日期：</h2><p>记得重置二月份的天数：day[2] &#x3D; 28;格式化日期：SimpleDateFormat sdf &#x3D; new SDF(“yyyy-MM-dd HH:mm:ss”);将long-&gt;Date : Date d &#x3D; new Date(long start);将Date-&gt;long : long start &#x3D; sdf.parse(“2023-04-08 00:00:00”).getTime();跑步锻炼：每天星期一跑步：new Date(long start).toString.contains(“01 “); – 1后面含空格</p>
<h2 id="5-模拟枚举枚举："><a href="#5-模拟枚举枚举：" class="headerlink" title="5.模拟枚举枚举："></a>5.模拟枚举枚举：</h2><p>顺子日期：刷题统计：每天打卡题数形成数组，模拟天数（注意i++的位置）和日期换瓶盖：模拟瓶盖数和饮料总数<br>模拟：天干地支：两个数组分别存放天干地支，分别模拟1960年前后的年份，前面天干地支–，后面天干地支++，注意达到数组界限时，天干地支取数组上界或下界；玩具：直接找规律模拟即可纸张尺寸：A1，for(int i&#x3D;48;i&lt;c[1];i++){ } – 太妙了，模拟的是Ax尺寸的尺寸的次数翻硬币：两个数组，遍历，若元素不同则翻动两个硬币，三元符号表示： c[i] &#x3D;&#x3D;’<em>‘?’o’:’</em>‘;</p>
<h2 id="6-二分贪心贪心"><a href="#6-二分贪心贪心" class="headerlink" title="6.二分贪心贪心:"></a>6.二分贪心贪心:</h2><p>答疑：题目要求的是在中间时刻开始时，(即前一次答疑结束到下一次答疑的开始)，数组含多个元素的快速排序：Arrays.sort(nums,(a,b) -&gt; (a[0]+a[1]+a[2]) - (b[0]+b[1]+b[2]))for(int i&#x3D;0;i&lt;n;i++){for(int j&#x3D;0;j&lt;3;j++){ sum+&#x3D;nums[i][j]; if(j &#x3D;&#x3D; 1) ans+&#x3D;sum; }}谈判：付账：判断一个人的钱乘以n是否恰好等于总数   money *(n-1)&lt;s?需要付完 : 选择方差最小的金额付款; </p>
<p>二分：int l&#x3D;0,r &#x3D; 10000;while(l&lt;&#x3D;r){  int mid &#x3D; (l+r)&gt;&gt;1;  if(check()){ ret &#x3D; mid ; r &#x3D; mid -1;}else{ l &#x3D; mid+1;}} ret即是答案递增三元组：双指针，a和c数组分别模拟一个指针的移动，遍历b数组，直到找到满足条件的下标；数组a找最后一个，数组c找第一个分巧克力：按题目要求是分成正方形,即二分的题目求出符合题意的check()即可，count +&#x3D; (ab[i][0] &#x2F; mid) * (ab[i][1] &#x2F; mid );路标：两个路标之间的距离&lt;mid,不需要设置，否则在当前路标设置一个距离为mid的路标，不断重复模拟合适的mid。</p>
<h2 id="7-基础知识"><a href="#7-基础知识" class="headerlink" title="7.基础知识"></a>7.基础知识</h2><p>拷贝：答案存在小数+1的情况；ASCII码:’0’:48 A’65’ a’97’进制转换：Integer.toHex &#x2F; toOct &#x2F; toBina (将十进制转化为16 &#x2F; 8 &#x2F; 2 进制)一次向List添加多个数据ArrayList&lt;&gt;list &#x3D; new ; list.addAll(Arrays.asList(2,3,23,32,32,23,32));读文件 String Path &#x3D; “D:\lq\b.txt”;BuffR in &#x3D; new br(new inps(new fileinpt(new file(Path))));String line &#x3D; “”; while(){(line &#x3D; in.readline())!&#x3D; null}</p>
<h2 id="8-暴力位运算："><a href="#8-暴力位运算：" class="headerlink" title="8.暴力位运算："></a>8.暴力位运算：</h2><p>(左移)两家医院分15批口罩，求分得的口罩数的差值尽可能的小&#x2F;&#x2F;模拟1-2^15种所有的可能sfor(int i&#x3D;0;i&lt;(1&lt;&lt;15);i++) {      int sum1&#x3D;0;int sum2&#x3D;0;      &#x2F;&#x2F;j表示枚举每次的口罩将给那一家医院，在15位二进制数的      &#x2F;&#x2F;情况下，1给第一家,0给第二家      for(int j&#x3D;0;j&lt;15;j++) {        if( (i &amp; (1&lt;&lt;j) ) !&#x3D;0) {          sum1 +&#x3D;nums[j];        }else {          sum2 +&#x3D;nums[j];        }      }      &#x2F;&#x2F;每一种情况下，两家医院口罩数量的差值，保留最小的na一个      ans &#x3D; Math.min(ans, Math.abs(sum1 -sum2));    }<br>倍数问题：一个数组找三个数，是k的倍数，求三数之和从尾部开始暴力，for(int i&#x3D;n-1;i&gt;&#x3D;2;i–) {                for(int j&#x3D;i-1;j&gt;&#x3D;1;j–) {                  for(int q &#x3D; j-1;q&gt;&#x3D;0;q–) {                     &#x2F;&#x2F;剪枝 if(sum&lt;ans) break;                           &#x2F;&#x2F;后面都小于，不必再判断                           if(a[i]+a[j]+a[j-1]&lt;ans) {                             break;}}                           &#x2F;&#x2F;后面都小于，不必再判断                             if(a[i]+a[i-1]+a[i-2]&lt;ans) {                               break;                                    }&#x2F;&#x2F;(60%)<br>灯塔：暴力枚举每个点，计算它到灯塔的距离是否小于半径，即可判断能否被照到递增序列：暴力枚举每个点的中心散发的左下，右上，右下，同一行，同一列的直线是否递增<br>真-暴力: &#x2F;&#x2F;直接暴力三重循环  int count &#x3D; 0;  for (int i &#x3D; 0; i &lt; 30; i++) {    for (int j &#x3D; 0; j &lt; 50; j++) {        int num &#x3D; a[i][j];        &#x2F;&#x2F;每一行        for(int t &#x3D; i+1;t&lt;30;t++) {          if(num&lt;a[t][j]) {            count++;          }        }                &#x2F;&#x2F;每一列        for(int t&#x3D;j+1;t&lt;50;t++) {          if(num&lt;a[i][t]) {            count++;          }        }        &#x2F;&#x2F;左下斜线        for(int t &#x3D; i+1,tt &#x3D;j-1;t&lt;30&amp;&amp;tt&gt;&#x3D;0;t++,tt–){          if(num&lt;a[t][tt]) {            count++;          }        }        &#x2F;&#x2F;右上斜线        for(int t &#x3D; i-1,tt&#x3D;j+1;t&gt;&#x3D;0&amp;&amp;tt&lt;50;t–,tt++) {          if(num&lt;a[t][tt]) {            count++;          }        }        &#x2F;&#x2F;右下斜线        for(int t&#x3D;i+1,tt&#x3D;j+1;t&lt;30&amp;&amp;tt&lt;50;t++,tt++) {          if(num&lt;a[t][tt]) {            count++;          }        }      }    }<br>2019分解： 分解为3个不同数的和，有顺序：i取前1&#x2F;3,j取i后面，k取j后面，能保证取到的数不重复for(int i&#x3D;1;i&lt;s&#x2F;3+1;i++) {      for(int j&#x3D;i+1;j&lt;s;j++) {        for(int k&#x3D;j+1;k&lt;s;k++) {<br>卡片：三种卡片有6个不同的组合，n人至少需要i个：两层循环解决；4平方和：拉格朗日定理可以取相同的数：20 &#x3D; 0 0 2 4，后面的数一定是最大的，for (int i1&#x3D;0;i1<em>i1&lt;&#x3D;n;i1++)     for (int i2&#x3D;i1;i2</em>i2&lt;&#x3D;n;i2++)       for (int i3&#x3D;i2;i3<em>i3&lt;&#x3D;n;i3++)         for (int i4&#x3D;i3;i4</em>i4&lt;&#x3D;n;i4++)           if (i1<em>i1+i2</em>i2+i3<em>i3+i4</em>i4&#x3D;&#x3D;n) {</p>
<p>字母阵列：求中心散射的八个方向直线上形成”lanqiao”直接枚举8个点的方向：for(int i&#x3D;0;i&lt;n;i++) {        for(int j&#x3D;0;j&lt;n;j++) {          if(zhi[i][j]&#x3D;&#x3D;’L’) {&#x2F;&#x2F;向8个方向寻找搜索            if(j+6&lt;n&amp;&amp;zhi[i][j+1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i][j+2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i][j+3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i][j+4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i][j+5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i][j+6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向右寻找            }            if(i+6&lt;n&amp;&amp;zhi[i+1][j]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+2][j]&#x3D;&#x3D;’N’&amp;&amp;zhi[i+3][j]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i+4][j]&#x3D;&#x3D;’I’&amp;&amp;zhi[i+5][j]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+6][j]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向下寻找            }            if(j-6&gt;&#x3D;0&amp;&amp;zhi[i][j-1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i][j-2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i][j-3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i][j-4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i][j-5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i][j-6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向左寻找            }            if(i-6&gt;&#x3D;0&amp;&amp;zhi[i-1][j]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-2][j]&#x3D;&#x3D;’N’&amp;&amp;zhi[i-3][j]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i-4][j]&#x3D;&#x3D;’I’&amp;&amp;zhi[i-5][j]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-6][j]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向上寻找            }            if(j+6&lt;n&amp;&amp;i+6&lt;n&amp;&amp;zhi[i+1][j+1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+2][j+2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i+3][j+3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i+4][j+4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i+5][j+5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+6][j+6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向右下寻找            }            if(j-6&gt;&#x3D;0&amp;&amp;i+6&lt;n&amp;&amp;zhi[i+1][j-1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+2][j-2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i+3][j-3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i+4][j-4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i+5][j-5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i+6][j-6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向左下寻找            }            if(i-6&gt;&#x3D;0&amp;&amp;j-6&gt;&#x3D;0&amp;&amp;zhi[i-1][j-1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-2][j-2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i-3][j-3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i-4][j-4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i-5][j-5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-6][j-6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向左上寻找            }            if(i-6&gt;&#x3D;0&amp;&amp;j+6&lt;n&amp;&amp;zhi[i-1][j+1]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-2][j+2]&#x3D;&#x3D;’N’&amp;&amp;zhi[i-3][j+3]&#x3D;&#x3D;’Q’&amp;&amp;zhi[i-4][j+4]&#x3D;&#x3D;’I’&amp;&amp;zhi[i-5][j+5]&#x3D;&#x3D;’A’&amp;&amp;zhi[i-6][j+6]&#x3D;&#x3D;’O’) {              num++;&#x2F;&#x2F;向右上寻找            }<br>最大子矩阵：四层循环遍历矩阵，从左上角遍历到右下角,每次取不同的子块来遍历，子矩阵最大最小值&lt;limit     for(int i&#x3D;N;i&gt;0;i–) {      for(int j&#x3D;M;j&gt;0;j–) { &#x2F;&#x2F; i*j的矩阵(右下角的坐标)        for(int x&#x3D;0;x&lt;&#x3D;N-i;x++) {          for(int y&#x3D;0;y&lt;&#x3D;M-j;y++) { &#x2F;&#x2F;左上角坐标            int max &#x3D; find_max(i,j,x,y);            int min &#x3D; find_min(i,j,x,y);<br>private static int find_max(int i, int j, int x, int y) {    &#x2F;&#x2F; 寻找最大值    int res &#x3D; Integer.MIN_VALUE;    for(int n&#x3D;x;n&lt;x+i;n++) {      for(int m&#x3D;y;m&lt;y+j;m++) {        res &#x3D; Math.max(res, arr[n][m]);      }    }    return res;  }</p>
<h1 id="其他知识点："><a href="#其他知识点：" class="headerlink" title="其他知识点："></a>其他知识点：</h1><p>1M&#x3D;1024kb 1kb&#x3D;1024字节 1字节&#x3D;8bit ASCII码：A:65 a:97<br>计算机算法：枚举、排序、搜索、计数、贪心、动态规划、图论、数论、博弈论<em>、概率论</em>、计算几何<em>、字符串算法等。数据结构：数组、对象&#x2F;结构、字符串、队列、栈、树、图、堆、平衡树&#x2F;线段树、复杂数据结构</em>、嵌套数据结构<em>等 暴力枚举需要注意变量的重置为0，即枚举下一个新的数时，需要将之前计算的值清零<br>ArrayList.addAll(Arrays.aslist(xx,xx,xx))ArrayList<Integer> arr &#x3D; new ArrayList<E>();添加数据到数组中，多用于求因子类的题目 remove()去掉首项 get()[从0开始]取元素Arrays.sort(数组自然排序)<br>基础：1.数位拆分 x % y x &#x2F; y &#x2F;&#x2F;计算一个数字每个位数之和public static int getsum(int num){int sum&#x3D;0;while(num !&#x3D;0){  sum +&#x3D; num %10;  num &#x2F;&#x3D;10;}return sum;}&#x2F;&#x2F;模拟字母public static String gename(int n){StringBuilder sb &#x3D; new StringBuilder();while(n&gt;0){n–;sb.append((char)(‘A’ + n % 26));n &#x2F;&#x3D;26;     }return sb.reverse().toString();   }}2.进制模拟String hexNum &#x3D; Integer.toHexString(var).toUpperCase();&#x2F;&#x2F;将十进制转化为十六进制且全部字母都为大写 Integer.toBinaryString(var) 十进制转为二进制 Integer.toOctalString(var)十进制转化八进制 匹配二进制 “^[01]+$” 八进制 “^[0-7]+$” 十六进制 “^[a-fA-F0-9]+$”<br>其他进制转化为十进制String Bin &#x3D; “01”;int x &#x3D; Integrt.parseInt(binary,2);int y &#x3D; Integer.parseInt(octal,8);String Hex &#x3D; “ABD”;int z &#x3D; Integer.parseInt(hex,16);<br>3.最大公约数 &amp; 最小公倍数public static int gcd(int x,int y) {      return y&#x3D;&#x3D;0?x:gcd(y,x % y);    }public static int lcm(int x,int y){    return x * y &#x2F; gcd(x,y);}4.位运算：if(i &amp; (1&gt;&gt;j) )!&#x3D;0 {};5.高精度模拟：printf(“%.2f”,a);6.素数初步： private static boolean isP(int num){  if(num &lt;&#x3D;1){  return false;} for(int i&#x3D;2;i&lt;&#x3D;Math.sqrt(num);i++){if(num % i &#x3D;&#x3D;0){return false;}}return true;}<br>7.余数及相关：%8.大数系列：BigInteger类大数可以+-<em>&#x2F; % 等操作(一般对数字进行的操作都会有)add,subtract,mod,BigInteger num &#x3D; new BigIntger(“20”);BigInteger ans &#x3D; new BigInteger(“1”);for(int i&#x3D;1;i&lt;&#x3D;22;i++){     ans &#x3D; ans.mutiply(num);}9.唯一分解定理：10.日期类：&#x2F;&#x2F;判断是否是闰年public static boolean isLeap(int year){ return (year % 4 &#x3D;&#x3D;0 &amp;&amp; year % 100 !&#x3D;0) || year % 400 &#x3D;&#x3D;0};&#x2F;&#x2F;计算某个月的天数public static int getDays(int year,int month){if(month &#x3D;&#x3D;2){  return isLeap(year)?29:28;}else if(month &#x3D;&#x3D; 4||month &#x3D;&#x3D;6||month&#x3D;&#x3D;9||month&#x3D;&#x3D;11){  return 30;}else{ return 31;}}<br>runningMax:例子SimpleDateformatlong (模拟毫秒数，以毫秒为单位模拟一天的增加)日期之间不能比较。但是转换为毫秒数之后可以相比Date(模拟日期) d &#x3D; new Date(long);SimpleDateFormat sdf &#x3D; new SimpleDateFormat(“yyyy-HH-dd hh:mm:ss”);用来格式化日期的格式，即题目给的日期格式Long start &#x3D; sdf.parse(“2022-02-02 02:02:02”).getTime(); &#x2F;&#x2F;将指定的格式化日期转化为相应的毫秒数Date d &#x3D; new Date(start);&#x2F;&#x2F;再将指定的毫秒数转为对应的日期sysout d.toString();&#x2F;&#x2F;输出日期&#x2F;&#x2F;模拟一天过去start &#x3D; new Date(start).getTime() + 24<em>60<em>60</em>1000L;<br>Calender(模拟日期)<br>字符串：<br> &#x2F;&#x2F;取一个字符串的所有的子串        for(int i&#x3D;0 ; i&lt;str.length(); i++){          for(int k&#x3D; i; k&lt;str.length(); k++){            String res &#x3D; str.substring(i,k+1);            System.<strong>out**.println(res)          }        }回文字符串使用一个方法private static boolean ishuiwen(String str){  int left &#x3D;0;int right &#x3D;str.length()-1;while(left &lt; right){if(str.charAt(leftt) !&#x3D; str.charAt(right)){  return false;}left++;right–;}sreturn true;}简单字符串统计：桶排序：int []a &#x3D; new int [n];char [] c &#x3D; a.tocharArray();a[(chatAt(c) - ‘A’)]++&#x2F;&#x2F;得出相应字母在数组中保存的数量(char)( i + ‘A’) &#x2F;&#x2F; 输出相对应的字母String 1.比较：compareTo() 返回0 表示相等2.String[] arr &#x3D; str.split(“”);切割字符串,形成字符串数组<br>Stringbuffer StringBuilder (反转：reverse())String 转型 int : str.valueOf();int 转型 String : 1 +“ ”   有字串的题目可以使用老白嫖方法-》》详情见字串分值<br>解密：模拟：周期串：困难串：<br>OJ几类格式训练：字符串hash+二分：正则表达式：<br>排序：冒泡+插入+选择+希尔+计数+堆排序….java对象排序：<br>数据结构：栈和队列：链表：Set<String> set &#x3D; new HashSet&lt;&gt;();set.add();set.contains();去重:(求不同的字符串子串）HashMap&lt;Character,Integer&gt; map &#x3D; new HashMap&lt;&gt;();(本质就是一个函数映射的关系，一个值对应一个数量,如 a ：2 ，b : 3）求出现字符最多的次数map.put( c , map.getorDefalut(c,0) +1);map.get(Object o);&#x2F;&#x2F;求一个值的数量循环map中的元素for(char c : map.keyset(){  map.get(c) ;}ArrayList<Integer> list &#x3D; new ArrayList&lt;&gt;();Collections.sort(list);&#x2F;&#x2F;运用集合对动态数组进行排序TreeMap 哈希表<br>穷举-模拟：   百钱白鸡凶手分糖果接雨水<br>递归：汉诺塔连分数<br>分治：归并快排快速幂<br>搜索：DFS:矩阵搜索，最短路径，迷宫1.设置矩阵的范围2.访问数组 visited[] ，访问一个位置后，修改它的值3.初始化需要求的数值（面积，数的和等）4.上下左右四个方向递归BFS<br>回溯剪枝<br>贪心：找零动态规划：1.返回值（避免重复遍历，只要dp[i][j] !&#x3D;0）if(dp[i][j!&#x3D;0]){return dp[i][j];}2.设置初值int max &#x3D;1;3.模拟每个位置的上下左右移动for(int k&#x3D;0;k&lt;4;k++){int x &#x3D; i+dx[k]; int y &#x3D; j + dy[k];}4.判断条件if(不符合的情况){continue;}5.状态转移方程(注意是否要+1)是取最大值还是数的和6.保存所求值LCSLISLPS最大子矩阵背包专题<br>二叉树：前中后层次遍历建树遍历二叉树还原字典树哈夫曼编码并查集<br>图：图的存储1.邻接矩阵2.邻接表<br>DFS<br>BFS最小生成树最短路径：有模板Dijkstra 算法是一种贪心算法，用于求加权图的单源最短路径问题，其中所有边的权重都必须是非负数。这个算法的基本思路是从起点开始，先确定起点到所有点的最短路径，然后不断扩大已确定最短路径的节点集合，直到到达终点。<br>难点：素数进阶矩阵快速幂前缀和与差分具体题目：</strong>“k倍区间”</em></em></em><em>一维数组的前缀和数组a[1,2,3,4,5] 前缀和sum[1,3,6,10,15] 余数[1,1,0,0,1] 余数(数量)[2,3];&#x2F;&#x2F;余数等于数组相应下标的个数</em>*   **余数为0的自成一个k倍区间 count+&#x3D;v[0];**<strong>余数不为0(余数相同)1.存储余数的数量。两两组合(求和公式)可以构成一个k倍区间 count+&#x3D;(v[i] *( v[ i ] - 1 ) ) &#x2F;2</strong> **2.存储余数。的根据同余定理，如果两个前缀和对 k 取余数的结果相同，那么它们的差or和一定是 k 的倍数(23%2 &#x3D; 1 ;13% 2&#x3D;&#x3D;1；|(13+-23)| %2 &#x3D;&#x3D;0)**小木棍 - 剪枝过关数位DPs区间DP状压DP线段树</p>
]]></content>
      <categories>
        <category>lqb</category>
      </categories>
      <tags>
        <tag>lqb</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2023/09/08/mst/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>rk</title>
    <url>/2023/09/08/rk/</url>
    <content><![CDATA[<p>按照题型分类补充一些知识点：</p>
]]></content>
      <categories>
        <category>rk</category>
      </categories>
      <tags>
        <tag>rk</tag>
      </tags>
  </entry>
  <entry>
    <title>linux</title>
    <url>/2023/09/08/linux/</url>
    <content><![CDATA[<h1 id="一-：开始："><a href="#一-：开始：" class="headerlink" title="一 ：开始："></a>一 ：开始：</h1><p>操作ctrl+alt+f2:进入shell界面 ctrl+alt+f1:进入图像界面ls &#x2F;usr&#x2F;sbin&#x2F; | grep service 查找子文件是否存在</p>
<h1 id="二：基本操作："><a href="#二：基本操作：" class="headerlink" title="二：基本操作："></a>二：基本操作：</h1><p>基本文件编辑cd:进入文件 vim：</p>
<p>文本编辑器（一 “:”进入命令模式 u 回撤 w 保存 q 退出 wq保存并退出!q强制退出 set nu 显示行号                i&#x2F;a当前光标头尾插入，I&#x2F;A行头尾插入 o&#x2F;O下上一行插入                     </p>
<p>普通模式 数字&amp;yy 复制 数字&amp;p 粘贴 数字&amp;dd 删除          </p>
<p>剪切一个字符 X 剪切光标的前一个字符            </p>
<p>y&#x2F;d&amp;w 复制删除一个单词 y&#x2F;d&amp;$复制删除光标之前      y&#x2F;d&amp;^复制删除光标之后            </p>
<p>r 替换字符 R 进入替换模式            </p>
<p>^行头 $行尾 w下一个词头 b上一个词头 e当前词尾 gg页头 G页尾 数字N&amp;G移动到目标行      </p>
<p>&#x2F;查找 n查找下一个 N查找上一个         </p>
<p>s&#x2F;old&#x2F;new替换首个 s&#x2F;old&#x2F;new&#x2F;g替换整行 %s&#x2F;old&#x2F;new替换所有行的首个                         %s&#x2F;old&#x2F;new&#x2F;g替换全篇)</p>
<h1 id="三：网络编辑"><a href="#三：网络编辑" class="headerlink" title="三：网络编辑"></a>三：网络编辑</h1><h2 id="windows网络高级设置："><a href="#windows网络高级设置：" class="headerlink" title="windows网络高级设置："></a>windows网络高级设置：</h2><p>可查看vmware虚拟网卡的ip（NAT）ping ip地址 进行网络连接cmd下：ipconfig查看所有连接网络的IP地址linux下: ifconfig查看所有连接网络的IP地址</p>
<h2 id="修改静态ip："><a href="#修改静态ip：" class="headerlink" title="修改静态ip："></a>修改静态ip：</h2><p>vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33添加#IP地址 IPADDR&#x3D;192.168.xxx.100(从100开始对应相应的主机名称)    #网关 GATEWAY&#x3D;192.168.xxx.2   #域名解释器 DNS1&#x3D;192.168.xxx.2重启网络配置：service network restart</p>
<h2 id="修改主机名："><a href="#修改主机名：" class="headerlink" title="修改主机名："></a>修改主机名：</h2><p>hostname set-hostname xx创建主机名和ip地址的映射关系: vim &#x2F;etc&#x2F;hosts192.168.32.100 hadoop100…</p>
<h1 id="四：远程登录cmd"><a href="#四：远程登录cmd" class="headerlink" title="四：远程登录cmd"></a>四：远程登录cmd</h1><p>：ssh root@hadoop100 yes 输入密码进入 linux 退出exit用XSell操作和Xftp传文件</p>
<h1 id="五：系统管理进程："><a href="#五：系统管理进程：" class="headerlink" title="五：系统管理进程："></a>五：系统管理进程：</h1><p>正在执行的程序或命令服务(.d结尾)：需要一直存在的进程，由守护进程来执行，形成服务。类似mysql80的自动启动（常驻后台）systemctl start&#x2F;stop&#x2F;restart&#x2F;status 服务名</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>xc-plus-project</title>
    <url>/2023/09/07/xc-plus-project/</url>
    <content><![CDATA[<h1 id="技术架构："><a href="#技术架构：" class="headerlink" title="技术架构："></a>技术架构：</h1><p>1.VMwarepro 虚拟机</p>
<p>充当云服务器，docker 中开启 nacos，xxl-job，minio，redis，elsticsearch，kibana，gogs,rabbitmq,mysql服务，xshell远程连接，Navicat开启数据库。<br>2.前端静态页面存在D:&#x2F;&#x2F;JAVA&#x2F;xc-res&#x2F;中，修改相关内容即可。还有一个前端工程，Vue编写的。<br>3.后端代码存在ideacode中，分每个微服务来写。<br>4.nacos是每个微服务的配置，xx-dev.yml文件，服务启动后会显示<br>5.xxl-job是分布式任务的处理，视频的处理，和课程的发布。分布式任务显示<br>6.minio存储需要的media和video，相当于一个数据库，存储文件，<br>7.e&amp;k,索引，搜索，把数据库表中的字段和值，通过映射到e&amp;k中，用于网页的索引和搜索。<br>8.gogs实现git代码的管理，每天一次commit到本地和push到远程。<br>9.redis存储本地的验证码，登录账户密码，图片验证码</p>
<p>11.rabbitmq消息队列，处理每个任务之间的逻辑，当前一个任务完成的时候，在队列中通知下一个任务的可以进行</p>
<p>10.在前端修改上传文件的大小和浏览器设置上传文件的服务器设置</p>
<p>11代理对象，事务控制(事务优化，代理对象处理事务需要在方法上添加@Transaction注解)</p>
<h1 id="详细技术介绍："><a href="#详细技术介绍：" class="headerlink" title="详细技术介绍："></a>详细技术介绍：</h1><h2 id="0-gogs"><a href="#0-gogs" class="headerlink" title="0 gogs"></a>0 gogs</h2><p>相当于git</p>
<h2 id="1swagger-ui"><a href="#1swagger-ui" class="headerlink" title="1swagger-ui"></a>1swagger-ui</h2><p>写接口文档的，也可拿来测试接口</p>
<h2 id="2nacos"><a href="#2nacos" class="headerlink" title="2nacos"></a>2nacos</h2><p>配置项目的网关，</p>
<h2 id="3minio"><a href="#3minio" class="headerlink" title="3minio"></a>3minio</h2><p>文件中转站和存储站</p>
<h2 id="5xxl-job"><a href="#5xxl-job" class="headerlink" title="5xxl-job"></a>5xxl-job</h2><p>任务处理，任务调度，什么是乐观锁、悲观锁？synchronized是一种悲观锁，在执行被synchronized包裹的代码时需要首先获取锁，没有拿到锁则无法执行，是总悲观的认为别的线程会去抢，所以要悲观锁。乐观锁的思想是它不认为会有线程去争抢，尽管去执行，如果没有执行成功就再去重试。 update media_process m set m.status&#x3D;’4’ where (m.status&#x3D;’1’ or m.status&#x3D;’3’) and m.fail_count&lt;3 and m.id&#x3D;?update media_process t set t.count &#x3D; t.count + 1,t.version&#x3D;2 where t.version &#x3D; 1</p>
<h2 id="6nginx"><a href="#6nginx" class="headerlink" title="6nginx:"></a>6nginx:</h2><p>网页前端页面，部署网页的位置，config文件，配置网页，拿图片，视频</p>
<h2 id="7freemarker"><a href="#7freemarker" class="headerlink" title="7freemarker:"></a>7freemarker:</h2><p>动态模板拿数据，从数据库拿数据展示到网页<a href="http://freemarker.foofun.cn/ref_directives.html">http://freemarker.foofun.cn/ref_directives.html</a></p>
<h2 id="8-fallbackfactory"><a href="#8-fallbackfactory" class="headerlink" title="8.fallbackfactory"></a>8.fallbackfactory</h2><p>页面静态化，雪崩需要，熔断处理，，上游降级处理</p>
<h2 id="9elasticsearch"><a href="#9elasticsearch" class="headerlink" title="9elasticsearch"></a>9elasticsearch</h2><p>作为索引及搜索服务。kibana 是 ELK（Elasticsearch , Logstash, Kibana ）之一，kibana 一款开源的数据分析和可视化平台，通过可视化界面访问elasticsearch的索引库，并可以生成一个数据报表。开发中主要使用kibana通过api对elasticsearch进行索引和搜索操作，<em>docker-compose up：安装docker-compose.yml中的配置启动kibana和ela</em></p>
<h2 id="10redis"><a href="#10redis" class="headerlink" title="10redis"></a>10redis</h2><p>存储验证码调用redis需要再bootstrap.yml文件中调用nacos中的配置，还有pom.xml文件中引入相关的依赖。</p>
<h2 id="11rabbitmq"><a href="#11rabbitmq" class="headerlink" title="11rabbitmq"></a>11rabbitmq</h2><h2 id="12-canal"><a href="#12-canal" class="headerlink" title="12 canal"></a>12 canal</h2><p> 数据实时同步：即改动数据库需要像mysql,elasticsearch等实时更新，采用binary log 的方法，[ mysql() – binary log ]  –&gt; canal -&gt; ela </p>
<h2 id="14spring-cloud"><a href="#14spring-cloud" class="headerlink" title="14spring cloud,"></a>14spring cloud,</h2><h2 id="15spring-security："><a href="#15spring-security：" class="headerlink" title="15spring security："></a>15spring security：</h2><p>进行认证授权认证框架，就是需要登录。授权模式：就是给谁访问什么资源的权限。过滤器拦截请求，OAuth2：授权码模式，携带授权码申请令牌，code&#x3D;TBiipf; acess_code &#x3D; ;         密码模式，loadusername：连接数据库认证 userdetailservice: 单点登录 统一认证入口:账号密码，微信，手机验证码 1.认证请求参数，2.屏蔽密码校验 自定义 DaoAuthenticationProvider3.自定义实现方法exeute();登录成功有cookie<br>在WebSecurityConfig中设置一下，disable掉csrf保护就可以了，因为post等会更改服务器内的状态的方法会触发跨站请求保护。@OverRideprotected void configure(HttpSecurity http) throws Exception {http.csrf().disable().authorizeRequests().anyRequest().permitAll().and().formLogin().successForwardUrl(“&#x2F;login-success”);</p>
<h2 id="16JWT"><a href="#16JWT" class="headerlink" title="16JWT"></a>16JWT</h2><p>(JSON web Token)令牌：自验证令牌合法性，客户端(申请令牌) – 认证服务（签名生成JWT令牌） – 资源服务（当客户端携带jwt令牌访问资源时，检验令牌合法性）对称加密。对资源进管控。</p>
<h2 id="17微信第三方登录"><a href="#17微信第三方登录" class="headerlink" title="17微信第三方登录"></a>17微信第三方登录</h2><p>code + appid +appsecret 换取access_token 用户授权同意，申请令牌，发放令牌，保存用户，自动登录，认证通过。RestTemplate第三方远程调用 , 收到code调用微信接口申请access_token，哪access_token查询用户信息，将用户信息保存到数据库代理对象控制事务，</p>
<p>1改nacos(填写appid和secret)weixin:appid: wxed9954c01bb89b47secret: a7482517235173ddb4083788de60b90e</p>
<p>2改wxlogin.html(填写appid和重定向地址)appid: “wxed9954c01bb89b47”,scope: “snsapi_login”,redirect_uri: “<a href="http://localhost:8160/api/auth/wxLogin">http://localhost:8160/api/auth/wxLogin</a>“,</p>
<p>3改nginx，开8610端口server {listen 8160;server_name localhost;<br>location &#x2F;api {proxy_pass <a href="http://gatewayserver;/">http://gatewayserver;</a>#proxy_pass <a href="http://localhost:63010;/">http://localhost:63010;</a>proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br># 这里需要添加一个rewrite规则，把请求中的&#x2F;api去掉rewrite ^&#x2F;api(.*)$ $1 break;}}</p>
<h2 id="18RABC"><a href="#18RABC" class="headerlink" title="18RABC"></a>18RABC</h2><p>基于角色的访问控制（Role-Based Access Control）基于资源的访问控制（Resource-Based Access Control)@PreAuthorize(“hasAuthority(‘xc_teachmanager_course_list’)”)&#x2F;&#x2F;拥有课程列表查询的权限方可访问授权，解开access_token，其中就有用户的信息和该用户所拥有的权限。数据库中的表对应不同角色的权限。在mapper中写sql语句查询权限，通过UserDeatailService()获取数据返回到前端，当用户访问资源时，即可判断是否拥有权限。</p>
<h2 id="19feign"><a href="#19feign" class="headerlink" title="19feign"></a>19feign</h2><p>远程调用@JsonFormat(shape &#x3D; JsonFormat.Shape.STRING,pattern &#x3D; “yyyy-MM-dd HH:mm:ss”)</p>
<h2 id="20支付宝支付"><a href="#20支付宝支付" class="headerlink" title="20支付宝支付"></a>20支付宝支付</h2><p>（用户下单，查询支付结果，结果通知）<strong>心态崩了，一个端口搞得我好几天，真服了，还是太马虎了</strong> <a href="hhtp://192.168.1.103:63030/orders/requestpay?payNo=%S;">hhtp:&#x2F;&#x2F;192.168.1.103:63030&#x2F;orders&#x2F;requestpay?payNo&#x3D;%S;</a></p>
<p><strong>非事务方法调用事务方法需要通过代理对象，该proxy即是本实现类的复制。 @Autowired OrederServiceImpl currentproxy;</strong><br>nacos配置appid，秘钥，注入到程序中。下载沙箱进行测试；用户–商户–支付宝。下单，支付请求，返回url，通知结果url，请求关闭订单，返回结果。 退款，对账。</p>
<p>生成支付的二维码: ZXing是用Java编写的多格式的1D &#x2F; 2D条码图像处理库，使用ZXing可以生成、识别QR Code（二维码）。base工程utils下配置二维码类内网穿透的域名暂时没有买：9块钱一个月，就是需要每次启动内网穿透让后修改notify的地址。alipayRequest.setNotifyUrl(<a href="http://xxx/orders/receivenotify);%E8%AE%A2%E5%8D%95%E7%BB%93%E6%9E%9C%E9%80%9A%E7%9F%A5%EF%BC%9A">http://xxx/orders/receivenotify);订单结果通知：</a></p>
<p>雪花算法生成订单号，保证唯一不重复</p>
<p>流程：登录–选课–支付 （用户登录，教师发布课程，选择付费课程（付费的状态），选课表的id在订单表中为out_bussinisse_id, 订单明细表记录订单id）</p>
<h2 id="21-注册和找回密码；"><a href="#21-注册和找回密码；" class="headerlink" title="21:注册和找回密码；"></a>21:注册和找回密码；</h2><p>QQ邮箱找回密码：看配置，有模版。在找回密码方法的最后，实现了一些前端代码，清空和重定向。</p>
<p>注册：手机号码和邮箱一样即可。按回车登录：钩子监听事件，在created 钩子中添加键盘监听事件。在destroy中移除键盘监听事件。</p>
<h2 id="22：消息队列"><a href="#22：消息队列" class="headerlink" title="22：消息队列"></a>22：消息队列</h2><p>处理支付完成之后的插入课程表。<a href="http://192.168.101.65:15672/#/exchanges%E7%94%9F%E4%BA%A7%E6%96%B9%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5%E5%88%B0%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%80%9A%E8%BF%87%E5%B9%BF%E6%92%AD%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%91%E9%80%81%E7%BB%99%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E6%B6%88%E8%B4%B9%E6%96%B9%E9%80%9A%E8%BF%87%E7%9B%91%E5%90%AC%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BF%A1%E6%81%AF%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82">http://192.168.101.65:15672/#/exchanges生产方发送通知到交换机，交换机通过广播的方式发送给消息队列，消费方通过监听消息队列的信息进行相应的操作。</a></p>
<p>rabbitMq，消息持久化，交换机持久化。</p>
<p>PayNotifyconfig配置 生产端：orders服务，消费端：learning（创建交换机和队列，队列绑定交换机）发送：消息发送到交换机，删除数据库中的消息。发送失败则向数据库中callback插入消息。接受：监听消息队列发送的消息。进行数据的处理，插表改状态等操作。</p>
<h2 id="26项目部署："><a href="#26项目部署：" class="headerlink" title="26项目部署："></a>26项目部署：</h2><p>一次部署一劳永逸，DevOps：CI&#x2F;CD:类生产环境：Kubernetes:</p>
<h1 id="27项目优化："><a href="#27项目优化：" class="headerlink" title="27项目优化："></a>27项目优化：</h1><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试:"></a>压力测试:</h2><p>吞吐量TPS:(Transaction per second)每秒可以处理的事务，一次完整的业务流程。        </p>
<p>响应时间:从发送请求到响应结果所需的时间       </p>
<p> 每秒查询次数，(Queries per second) 每秒可以查询接口的次数，可以多次TPS        </p>
<p> 错误率 :错误次数占总次数的比率。        </p>
<p> 网盘io：压测软件：Apache jmeter 新建接口测试，看汇总报告和结果。       </p>
<p>  log4j2-dev.xml : &lt;Root level : “info” &gt;debug输出日志太耗费内存 </p>
<p><img src="/img/yace.png"></p>
<h2 id="缓存优化："><a href="#缓存优化：" class="headerlink" title="缓存优化："></a>缓存优化：</h2><p>以下东西放缓存：白名单:不用登录就可试学视频。客户端需要的东西：redis键值对key-value, key:自定义的”course” + courseId (course18); value 即为16进制下的缓存在redis中的数据。查询课程发布信息，先查缓存再查数据库，缓存中没有就查询数据库，然后保存到缓存中。吞吐量：1000</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutowiredRedisTemplate</span> redisTemplate;</span><br><span class="line"><span class="keyword">public</span> CoursePublish <span class="title function_">getCoursePublishCache</span><span class="params">(Long courseId)</span>&#123;  <span class="comment">//查询缓存  </span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">jsonObj</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);  <span class="keyword">if</span>(jsonObj!=<span class="literal">null</span>)&#123;    <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> jsonObj.toString();    System.out.println(<span class="string">&quot;=================从缓存查=================&quot;</span>);    <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);    <span class="keyword">return</span> coursePublish;  &#125; <span class="keyword">else</span> &#123;    System.out.println(<span class="string">&quot;从数据库查询...&quot;</span>);    <span class="comment">//从数据库查询    </span></span><br><span class="line">    <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> getCoursePublish(courseId);    <span class="keyword">if</span>(coursePublish!=<span class="literal">null</span>)&#123;      redisTemplate.opsForValue().set(<span class="string">&quot;course:&quot;</span> + courseId, JSON.toJSONString(coursePublish));    &#125;    <span class="keyword">return</span> coursePublish;  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h2><p>查询不数据库中不存在的数据导致缓存失效，即缓存被穿透了。         </p>
<p>一般发生在高并发请求。假设查询存在的课程，多个线程第一次过来，都没有缓存，都从数据库查了。 假设查询不存在的课程，缓存中肯定没有，那么都会从数据库中查询了。</p>
<p>解决缓存穿透：</p>
<p>1.请求校验机制：合适的数据格式，            </p>
<p>2.布隆过滤器：缓存预热：先把所有的课程id保存在HashMap中，先校验是否存在HashMap，再决定是否查询数据库。相当于一层过滤。返回0，表示一定不存在。返回1，表示Map中存在courseId的Hash值。     </p>
<p>3.缓存null值或特殊值  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>  RedisTemplate redisTemplate;  <span class="keyword">public</span> CoursePublish <span class="title function_">getCoursePublishCache</span><span class="params">(Long courseId)</span>&#123;    <span class="comment">//查询缓存    </span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">jsonObj</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);    <span class="keyword">if</span>(jsonObj!=<span class="literal">null</span>)&#123;      <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> jsonObj.toString();      <span class="keyword">if</span>(jsonString.equals(<span class="string">&quot;null&quot;</span>))        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 缓存中value是null，直接返回null即可。     </span></span><br><span class="line">                                                                                                 System.out.println(<span class="string">&quot;=================从缓存查=================&quot;</span>);      <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);      <span class="keyword">return</span> coursePublish;    &#125; <span class="keyword">else</span> &#123;      System.out.println(<span class="string">&quot;从数据库查询...&quot;</span>);      <span class="comment">//从数据库查询     </span></span><br><span class="line">    <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> getCoursePublish(courseId);<span class="comment">//      if(coursePublish!=null)&#123;//    redisTemplate.opsForValue().set(&quot;course:&quot; + courseId, JSON.toJSONString(coursePublish));//      &#125;      redisTemplate.opsForValue().set(&quot;course:&quot; + courseId, JSON.toJSONString(coursePublish),30, TimeUnit.SECONDS); </span></span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;从数据库中查到value为null，照样存到数据库中，其值为null，设置过期时间30s（尽量较小） ，避免未来有正确的课程时其值还是null。 \xAC\xED\x00\x05t\x00\x04null      return coursePublish;    }  } 吞吐量1800。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩:"></a>缓存雪崩:</h2><p>在高并发的场景下，比如缓存1w个课程，有1w个key，但是这1w个课程的key过期时间一致，即key同时失效。这时候，大量的请求又会同时去请求数据库，造成数据库资源耗尽，最终造成雪崩。</p>
<p>解决缓存雪崩：</p>
<p>1.用锁解决：synchronized( Obj ){ }；效率不高。       </p>
<p> 2.key设置不同的时间即可：尽量避免再次同时访问数据库。对某一类的key缓存的时间是不一样的：入课程信息：300s，媒体信息：400s。&#x2F;&#x2F;设置过期时间300秒 redisTemplate.opsForValue().set(“course:” + courseId, JSON.<em>toJSONString</em>(coursePublish),300+new Random().nextInt(100), TimeUnit.<em>SECONDS</em>); </p>
<p>3.缓存预热：写个定时任务：发现key快失效了，再重新将key写入缓存。10s缓存一次。</p>
<h2 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h2><p>大量的并发同时访问同一个热点数据，当这个热点数据失效时，并发请求会同时去请求数据库，数据库资源耗尽。如某新品手机发布会，当缓存失效，大量并发到来，同时访问数据数据库。</p>
<p>解决缓存击穿：</p>
<p>1.加同步锁：使用同步锁控制查询数据库的代码，只允许有一个线程去查询数据库，查询得到的数据再存入缓存。synchronized(this){ 需要查询数据库的代码 };service ： 单例，多个线程共享实例，共同争抢这把锁，才能锁住。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CoursePublish <span class="title function_">getCoursePublishCache</span><span class="params">(Long courseId)</span>&#123;</span><br><span class="line">    <span class="comment">//查询缓存    </span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">jsonObj</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);     <span class="keyword">if</span>(jsonObj!=<span class="literal">null</span>)&#123;      <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> jsonObj.toString();      <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);      <span class="keyword">return</span> coursePublish;    &#125;<span class="keyword">else</span>&#123;      <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;         <span class="comment">//第一次进来缓存肯定是空的，当第一个线程查完数据库，存入redis，第二个线程拿到锁直接查缓存，不需要再次查数据库。       </span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">jsonObj</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);        <span class="keyword">if</span>(jsonObj!=<span class="literal">null</span>)&#123;          <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> jsonObj.toString();          <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);          <span class="keyword">return</span> coursePublish;        &#125;         System.out.println(<span class="string">&quot;=========从数据库查询==========&quot;</span>);        <span class="comment">//从数据库查询        </span></span><br><span class="line">        <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> getCoursePublish(courseId);       <span class="comment">//设置过期时间300秒 </span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;course:&quot;</span> + courseId, JSON.toJSONString(coursePublish),<span class="number">300</span>, TimeUnit.SECONDS);        <span class="keyword">return</span> coursePublish;      &#125;    &#125;&#125;    </span><br></pre></td></tr></table></figure>

<p>​             2.key-vlaue缓存时间不过期，后台做好缓存的同步即可。</p>
<h3 id="速记："><a href="#速记：" class="headerlink" title="速记："></a>速记：</h3><p>无中生有是穿透，布隆过滤null隔离。缓存击穿key过期， 锁与非期解难题。大量过期成雪崩，过期时间要随机。面试必考三兄弟，可用限流来保底。</p>
<h3 id="限流技术方案："><a href="#限流技术方案：" class="headerlink" title="限流技术方案："></a>限流技术方案：</h3><p>alibaba&#x2F;Sentinel nginx+Lua分布式锁：一个同步锁只能保证同一个虚拟中的多个进程，其中只有一个线程去查数据库。那么存在多个虚拟机，高并发网关通过网关负载均衡转发给各个虚拟机，此时就会存在多个线程去查数据库。        </p>
<h3 id="此时需要分布式锁："><a href="#此时需要分布式锁：" class="headerlink" title="此时需要分布式锁："></a>此时需要分布式锁：</h3><p>分布式环境下：所有虚拟机的线程去同步执行，让多个虚拟机去抢同一个锁。         此时的锁是一个单独的程序：提供解锁，上锁的服务，谁抢到锁，谁去查询数据库</p>
<h1 id="实现分布式锁："><a href="#实现分布式锁：" class="headerlink" title="实现分布式锁："></a>实现分布式锁：</h1><h2 id="1-基于数据库实现："><a href="#1-基于数据库实现：" class="headerlink" title="1.基于数据库实现："></a>1.基于数据库实现：</h2><p>利用数据库主键唯一性的特点，索引唯一性，多个线程同时去插入相同的记录·，谁插入成功，谁抢到锁。（乐观锁，悲观锁）媒体资源的视频上传文件当中就运用了此分布式上传文件的方法。             </p>
<h2 id="2-基于redis实现锁："><a href="#2-基于redis实现锁：" class="headerlink" title="2.基于redis实现锁："></a>2.基于redis实现锁：</h2><p>SETNX，redission。SETNX的命令的工作过程是：去set一个不存在的key，多个线程去设置同一个key，只会有一个线程设置成功，设置成功的即拿到锁。             </p>
<h2 id="3-使用zookeeper实现。"><a href="#3-使用zookeeper实现。" class="headerlink" title="3.使用zookeeper实现。"></a>3.使用zookeeper实现。</h2><p>zookeeper的结构类似的文件目录，多线程向zookeeper创建一个子目录(节点)只会有一个创建成功，利用此特点可以实现分布式锁，谁创建该结点成功谁就获得锁实现分布式锁： </p>
<p>1.SETNX <a href="http://www.redis.cn/commands/set.html">http://www.redis.cn/commands/set.html</a> set lock01 01 NX EX 30  EX <em>seconds</em> – 设置键key的过期时间，单位时秒PX <em>milliseconds</em> – 设置键key的过期时间，单位时毫秒NX – 只有键key不存在的时候才会设置key的值XX – 只有键key存在的时候才会设置key的值</p>
<h2 id="如何释放锁："><a href="#如何释放锁：" class="headerlink" title="如何释放锁："></a>如何释放锁：</h2><h3 id="1-key过期自动释放"><a href="#1-key过期自动释放" class="headerlink" title="1.key过期自动释放"></a>1.key过期自动释放</h3><p>过期时间不好把控，快了则任务没处理完成，其他线程再来重复操作，慢了则增加其他线程等待时间。          </p>
<h3 id="2-手动删除"><a href="#2-手动删除" class="headerlink" title="2.手动删除"></a>2.手动删除</h3><p> if(缓存中有){<br> 返回缓存中的数据}else{<br> 获取分布式锁: Boolean lock01 &#x3D; redisTemplate.opsForValue().setIfAbsent(“coursequerylock”+courseId , 01，200，TimeUtil. Second) if(获取锁成功）{    try{     查询数据库   }finally{     if(redis.call(“get”,”lock”)&#x3D;&#x3D;”01”){      释放锁: redis.call(“del”,”lock”)     }}}}<br>这整个操作(拿锁，查数据库，释放锁)是原子性的：但是需要借助Lua脚本，即要么都成功，要么都失败，不能给CPu轮转时间片调度。最后，释放时间还是不好把控。   </p>
<h2 id="2-redisson"><a href="#2-redisson" class="headerlink" title="2.redisson:"></a>2.redisson:</h2><p>Redisson的文档地址：<a href="https://github.com/redisson/redisson/wiki/Table-of-Content">https://github.com/redisson/redisson/wiki/Table-of-Content</a> </p>
<p><img src="/img/reddison.png"></p>
<p>Redisson的执行逻辑：         </p>
<ol>
<li><h3 id="加锁机制："><a href="#加锁机制：" class="headerlink" title="加锁机制："></a>加锁机制：</h3><p>线程去获取锁，获取成功: 执行lua脚本，保存数据到redis数据库。线程去获取锁，获取失败: 一直通过while循环尝试获取锁，获取成功后，执行lua脚本，保存数据到redisRLock继承JDK的Lock接口，所以他有Lock接口的所有特性，比如lock、unlock、trylock等特性,同时它还有很多新特性：强制锁释放，带有效期的锁,使用Redisson可以方便的把Java本地内存中常用的数据结构对象搬到分布式缓存redis中。       ReentrantLock rtl &#x3D; new  ReentrantLock();       rtl.trylock();       try{       &#x2F;&#x2F;代码执行逻辑     }finally{     rtl.unlock();   }</p>
</li>
<li><h3 id="watchdog"><a href="#watchdog" class="headerlink" title="watchdog:"></a>watchdog:</h3><p>启动一个watch dog后台线程，不断的延长锁key的生存时间。对锁进行续期，30s后当前线程未完成再续时间。</p>
</li>
<li><h3 id="lua脚本："><a href="#lua脚本：" class="headerlink" title="lua脚本："></a>lua脚本：</h3><p>保证原子性操作：主要是如果你的业务逻辑复杂的话，通过封装在lua脚本中发送给redis，而且redis是单线程的，这样就保证这段复杂业务逻辑执行的原子性</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RRLock</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//----------------------Lock接口方法-----------------------</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁 锁的有效期默认30秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁 可以手动设置锁的有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁有效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit      时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tryLock()方法是有返回值的，用来尝试获取锁，</span></span><br><span class="line"><span class="comment">     * 如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false .</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，</span></span><br><span class="line"><span class="comment">     * 只不过区别在于这个方法在拿不到锁时会等待一定的时间，</span></span><br><span class="line"><span class="comment">     * 在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比上面多一个参数，多添加一个锁的有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waitTime  等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁有效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit      时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     * waitTime 大于 leaseTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>lock()<strong>：此方法为加锁，但是锁的有效期采用</strong>默认<strong><strong>30</strong></strong>秒</strong>如果主线程未释放，且当前锁未调用unlock方法，则进入到<strong>watchDog****机制</strong>如果主线程未释放，且当前锁调用unlock方法，则直接释放锁<br>代码编写：添加依赖。nacos中配置redisson的配置文件目录。在代码中添加singerServerConfig.yml文件：单机实例配置文件。    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>    RedisTemplate redisTemplate;    <span class="meta">@Autowired</span>    RedissonClient redissonClient;  <span class="comment">//Redisson分布式锁  </span></span><br><span class="line"><span class="keyword">public</span> CoursePublish <span class="title function_">getCoursePublishCache</span><span class="params">(Long courseId)</span>&#123;    <span class="comment">//查询缓存    </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);    <span class="keyword">if</span>(StringUtils.isNotEmpty(jsonString))&#123;      <span class="keyword">if</span>(jsonString.equals(<span class="string">&quot;null&quot;</span>))&#123;        <span class="keyword">return</span> <span class="literal">null</span>;      &#125;      <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);      <span class="keyword">return</span> coursePublish;    &#125;<span class="keyword">else</span>&#123;      <span class="comment">//每门课程设置一个锁      </span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;coursequerylock:&quot;</span>+courseId);      <span class="comment">//获取分布式锁</span></span><br><span class="line">        lock.lock();      <span class="keyword">try</span> &#123;        jsonString = (String) redisTemplate.opsForValue().get(<span class="string">&quot;course:&quot;</span> + courseId);        <span class="keyword">if</span>(StringUtils.isNotEmpty(jsonString))&#123;          <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublish.class);          <span class="keyword">return</span> coursePublish;        &#125;        System.out.println(<span class="string">&quot;=========从数据库查询==========&quot;</span>);         <span class="keyword">try</span> &#123;          Thread.sleep(<span class="number">60000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="comment">//测试watchdog自动延期</span></span><br><span class="line">                               <span class="comment">//从数据库查询        </span></span><br><span class="line">                               <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> getCoursePublish(courseId);        redisTemplate.opsForValue().set(<span class="string">&quot;course:&quot;</span> + courseId, JSON.toJSONString(coursePublish),<span class="number">1</span>,TimeUnit.DAYS);        <span class="keyword">return</span> coursePublish;      &#125;<span class="keyword">finally</span> &#123;        <span class="comment">//手动释放锁，lua脚本        </span></span><br><span class="line">            lock.unlock();      &#125;    &#125;  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/TTl.png"></p>
<p>TTL:自动续期：watchdog,不足30s，自动延期到30s，因为拿到锁还没有做完事情，做完事情会手动释放锁。最终测试：开启多个实例，只会有一个实例拿到锁，在过期时间前，进行数据库查询，再写入缓存。而另一个实例的线程进行等待。</p>
]]></content>
      <categories>
        <category>java项目</category>
      </categories>
      <tags>
        <tag>mybatis,java,ssm.spring,</tag>
      </tags>
  </entry>
</search>
